Source: Backport from later version of opensync

Index: core/src/lib/osw/inc/osw.h
===================================================================
--- core.orig/src/lib/osw/inc/osw.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#ifndef OSW_H
-#define OSW_H
-
-void
-osw_init(void);
-
-#endif /* OSW_H */
Index: core/src/lib/osw/inc/osw_bss_map.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_bss_map.h
@@ -0,0 +1,63 @@
+#ifndef OSW_BSS_MAP_H
+#define OSW_BSS_MAP_H
+
+struct osw_bss_entry;
+struct osw_bss_provider;
+struct osw_bss_map_observer;
+
+typedef void
+osw_bss_set_fn_t(struct osw_bss_map_observer *observer,
+                 const struct osw_hwaddr *bssid,
+                 const struct osw_bss_entry *bss_entry);
+
+typedef void
+osw_bss_unset_fn_t(struct osw_bss_map_observer *observer,
+                   const struct osw_hwaddr *bssid);
+
+struct osw_bss_map_observer {
+    const char *const name;
+    osw_bss_set_fn_t *const set_fn; /* Called on addition and/or modification */
+    osw_bss_unset_fn_t *const unset_fn; /* Called when lasst prvider frees BSS's entry */
+
+    struct ds_dlist_node node;
+};
+
+struct osw_bss_provider*
+osw_bss_map_register_provider(void);
+
+void
+osw_bss_map_unregister_provider(struct osw_bss_provider *provider);
+
+void
+osw_bss_map_register_observer(struct osw_bss_map_observer *observer);
+
+void
+osw_bss_map_unregister_observer(struct osw_bss_map_observer *observer);
+
+struct osw_bss_entry*
+osw_bss_map_entry_new(struct osw_bss_provider *provider,
+                      const struct osw_hwaddr *bssid);
+
+void
+osw_bss_map_entry_free(struct osw_bss_provider *provider,
+                       struct osw_bss_entry* entry);
+
+#define OSW_BSS_ENTRY_SET_PROTOTYPE(attr_type, attr)                        \
+    void                                                                    \
+    osw_bss_entry_set_ ## attr(struct osw_bss_entry* entry,                 \
+                               const attr_type *attr);
+
+#define OSW_BSS_GET_PROTOTYPE(attr_type, attr)                              \
+    const attr_type*                                                        \
+    osw_bss_get_ ## attr(const struct osw_hwaddr* bssid);
+
+OSW_BSS_ENTRY_SET_PROTOTYPE(struct osw_ssid, ssid);
+OSW_BSS_ENTRY_SET_PROTOTYPE(struct osw_channel, channel);
+
+OSW_BSS_GET_PROTOTYPE(struct osw_ssid, ssid);
+OSW_BSS_GET_PROTOTYPE(struct osw_channel, channel);
+
+#undef OSW_BSS_SET_PROTOTYPE
+#undef OSW_BSS_GET_PROTOTYPE
+
+#endif /* OSW_BSS_MAP_H */
Index: core/src/lib/osw/inc/osw_btm.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_btm.h
@@ -0,0 +1,61 @@
+#ifndef OSW_BTM_H
+#define OSW_BTM_H
+
+#define OSW_BTM_REQ_NEIGH_SIZE 16 /* TODO Check! */
+
+struct osw_btm_sta_observer;
+struct osw_btm_sta;
+struct osw_btm_desc;
+struct osw_btm_req_neigh;
+struct osw_btm_req_params;
+
+typedef
+void osw_btm_req_tx_complete_fn_t(struct osw_btm_sta_observer *observer);
+
+typedef
+void osw_btm_req_tx_error_fn_t(struct osw_btm_sta_observer *observer);
+
+struct osw_btm_sta_observer {
+    osw_btm_req_tx_complete_fn_t *const req_tx_complete_fn;
+    osw_btm_req_tx_error_fn_t *const req_tx_error_fn;
+};
+
+struct osw_btm_req_neigh {
+    struct osw_hwaddr bssid;
+    uint32_t bssid_info;
+    uint8_t op_class;
+    uint8_t channel;
+    uint8_t phy_type;
+};
+
+struct osw_btm_req_params {
+    struct osw_btm_req_neigh neigh[OSW_BTM_REQ_NEIGH_SIZE];
+    size_t neigh_len;
+    uint8_t valid_int;
+    bool abridged;
+    bool disassoc_imminent;
+    bool bss_term;
+};
+
+void
+osw_btm_init(void);
+
+struct osw_btm_desc*
+osw_btm_get_desc(const struct osw_hwaddr *sta_addr,
+                 struct osw_btm_sta_observer *observer);
+
+void
+osw_btm_desc_free(struct osw_btm_desc *desc);
+
+bool
+osw_btm_desc_set_req_params(struct osw_btm_desc *desc,
+                            const struct osw_btm_req_params *req_params);
+
+struct osw_btm_sta*
+osw_btm_desc_get_sta(struct osw_btm_desc *desc);
+
+void
+osw_btm_sta_set_throttle(struct osw_btm_sta *btm_sta,
+                         struct osw_throttle *throttle);
+
+#endif /* OSW_BTM_H */
Index: core/src/lib/osw/inc/osw_conf.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_conf.h
+++ core/src/lib/osw/inc/osw_conf.h
@@ -1,13 +1,10 @@
-#ifndef OSW_CONF_H
-#define OSW_CONF_H
+#ifndef OSW_CONF_H_INCLUDED
+#define OSW_CONF_H_INCLUDED
 
 #include <osw_types.h>
 #include <ds_dlist.h>
 #include <ds_tree.h>
 
-struct osw_conf;
-struct osw_conf_phy;
-
 struct osw_conf_acl {
     struct ds_tree_node node;
     struct osw_hwaddr mac_addr;
@@ -33,13 +30,26 @@ struct osw_conf_vif_ap {
     bool mcast2ucast;
 };
 
+struct osw_conf_net {
+    struct ds_dlist_node node;
+    struct osw_ssid ssid;
+    struct osw_hwaddr bssid;
+    struct osw_psk psk;
+    struct osw_wpa wpa;
+};
+
 struct osw_conf_vif_sta {
-    /* TODO */
+    /* FIXME: for multi-ap, this will need:
+       struct osw_ifname bridge_if_name;
+       bool multi_ap;
+     */
+    struct ds_dlist net_list;
 };
 
 struct osw_conf_vif {
     struct ds_tree_node phy_node;
     struct osw_conf_phy *phy;
+    struct osw_hwaddr mac_addr;
     char *vif_name;
     bool enabled;
     enum osw_vif_type vif_type;
@@ -51,7 +61,7 @@ struct osw_conf_vif {
 
 struct osw_conf_phy {
     struct ds_tree_node conf_node;
-    struct osw_conf *conf;
+    struct ds_tree *phy_tree;
     char *phy_name;
     bool enabled;
     int tx_chainmask;
@@ -59,19 +69,11 @@ struct osw_conf_phy {
     struct ds_tree vif_tree;
 };
 
-struct osw_conf {
-    struct ds_tree phy_tree;
-};
-
 struct osw_conf_mutator;
 struct osw_conf_observer;
 
 typedef void osw_conf_mutate_fn_t(struct osw_conf_mutator *mutator,
-                                  struct osw_conf *conf);
-
-typedef void osw_conf_backup_fn_t(struct osw_conf_mutator *mutator);
-
-typedef void osw_conf_rollback_fn_t(struct osw_conf_mutator *mutator);
+                                  struct ds_tree *phy_tree);
 
 typedef void osw_conf_mutated_fn_t(struct osw_conf_observer *observer);
 
@@ -83,42 +85,37 @@ enum osw_conf_type {
 struct osw_conf_mutator {
     struct ds_dlist_node node;
     const char *name;
-    const enum osw_conf_type type;
-    osw_conf_mutate_fn_t *const mutate_fn;
-    osw_conf_backup_fn_t *const backup_fn;
-    osw_conf_rollback_fn_t *const rollback_fn;
+    enum osw_conf_type type;
+    osw_conf_mutate_fn_t *mutate_fn;
 };
 
 struct osw_conf_observer {
     struct ds_dlist_node node;
     const char *name;
-    osw_conf_mutated_fn_t *const mutated_fn;
+    osw_conf_mutated_fn_t *mutated_fn;
 };
 
 void
 osw_conf_register_mutator(struct osw_conf_mutator *mutator);
 
 void
+osw_conf_unregister_mutator(struct osw_conf_mutator *mutator);
+
+void
 osw_conf_register_observer(struct osw_conf_observer *observer);
 
-struct osw_conf *
+struct ds_tree *
 osw_conf_build_from_state(void);
 
-struct osw_conf *
+struct ds_tree *
 osw_conf_build(void);
 
 void
-osw_conf_free(struct osw_conf *conf);
+osw_conf_free(struct ds_tree *phy_tree);
 
 void
 osw_conf_invalidate(struct osw_conf_mutator *mutator);
 
-void
-osw_conf_backup(void);
-
-void
-osw_conf_rollback(void);
-
 bool
 osw_conf_ap_psk_tree_changed(struct ds_tree *a, struct ds_tree *b);
 
@@ -131,4 +128,4 @@ osw_conf_ap_psk_tree_to_str(char *out, s
 void
 osw_conf_ap_acl_tree_to_str(char *out, size_t len, const struct ds_tree *a);
 
-#endif /* OSW_CONF_H */
+#endif /* OSW_CONF_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_confsync.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_confsync.h
+++ core/src/lib/osw/inc/osw_confsync.h
@@ -1,51 +1,83 @@
-#ifndef OSW_CONFSYNC_H
-#define OSW_CONFSYNC_H
+#ifndef OSW_CONFSYNC_H_INCLUDED
+#define OSW_CONFSYNC_H_INCLUDED
 
-#include <ev.h>
-#include <osw_conf.h>
-#include <osw_state.h>
-
-#define OSW_CONFSYNC_RETRY_SECONDS_DEFAULT 30.0
+/**
+ * This modules provides logic that pits intended config
+ * (from osw_conf) against state (from osw_state) and
+ * generates (re)configuration commands to the underlying
+ * OSW driver(s) through osw_mux.
+ *
+ * It is possible to observe this module's progression.
+ */
 
 struct osw_confsync;
+struct osw_confsync_changed;
 
-typedef void osw_confsync_agitated_fn_t(struct osw_confsync *cs);
-typedef void osw_confsync_settled_fn_t(struct osw_confsync *cs);
-typedef void osw_confsync_idle_fn_t(struct osw_confsync *cs);
-typedef void osw_confsync_busy_fn_t(struct osw_confsync *cs);
-
-struct osw_confsync {
-    /* public */
-    osw_confsync_agitated_fn_t *const agitated_fn;
-    osw_confsync_settled_fn_t *const settled_fn;
-    osw_confsync_idle_fn_t *const idle_fn;
-    osw_confsync_busy_fn_t *const busy_fn;
-    int retry_seconds;
-
-    /* private */
-    struct osw_conf *conf;
-    struct osw_conf *state;
-    struct osw_state_observer obs;
-    ev_timer work;
-    ev_timer retry;
-    bool forced;
-    bool settled;
-    bool idle;
-};
-
-void
-osw_confsync_init(struct osw_confsync *cs);
+typedef void osw_confsync_changed_fn_t(struct osw_confsync *cs, void *priv);
 
-void
-osw_confsync_fini(struct osw_confsync *cs);
+enum osw_confsync_state {
+    OSW_CONFSYNC_IDLE,
+    OSW_CONFSYNC_REQUESTING,
+    OSW_CONFSYNC_WAITING,
+    OSW_CONFSYNC_VERIFYING,
+};
 
+/**
+ * Fetch global singleton instance of osw_confsync.
+ *
+ * The returned object is guaranteed to be initialized and
+ * ready for use.
+ */
+struct osw_confsync *
+osw_confsync_get(void);
+
+/**
+ * Fetch the progression state.
+ *
+ * Expected to be called from within
+ * osw_confsync_changed_fn_t callbacks.
+ */
+enum osw_confsync_state
+osw_confsync_get_state(struct osw_confsync *cs);
+
+/**
+ * Convert the enum into a string.
+ *
+ * Intended for logging purposes.
+ */
+const char *
+osw_confsync_state_to_str(enum osw_confsync_state s);
+
+/**
+ * Register an observer callback against changes.
+ *
+ * Whenever confsync's state changes the provided callback
+ * (fn) will be called. Before this function exists (fn)
+ * will be called too.
+ *
+ * @param name Used for logging. Must not be NULL.
+ *             Recommended: __FILE__.
+ * @param fn The callback.
+ * @param fn_priv This pointer will be provided back to the
+ *                callback upon notification.
+ * @return Handle that can be used to unregister through
+ *         osw_confsync_unregister_changed.
+ */
+struct osw_confsync_changed *
+osw_confsync_register_changed_fn(struct osw_confsync *cs,
+                                 const char *name,
+                                 osw_confsync_changed_fn_t *fn,
+                                 void *fn_priv);
+
+/**
+ * Unregister an observer callback. After calling this the
+ * osw_confsync_changed handle becomes invalid and the
+ * pointer must be discarded.
+ */
 void
-osw_confsync_set(struct osw_confsync *cs,
-                 struct osw_conf *conf,
-                 struct osw_conf *state,
-                  bool force);
+osw_confsync_unregister_changed(struct osw_confsync_changed *c);
 
-bool
-osw_confsync_is_settled(struct osw_confsync *cs);
+/* FIXME. osw_confsync_set_retry_seconds() */
+/* FIXME. osw_confsync_set_enabled() */
 
-#endif /* OSW_CONFSYNC_H */
+#endif /* OSW_CONFSYNC_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_cqm.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_cqm.h
@@ -0,0 +1,41 @@
+#ifndef OSW_CQM_H_INCLUDED
+#define OSW_CQM_H_INCLUDED
+
+#include <osw_types.h>
+
+enum osw_cqm_link_state {
+    OSW_CQM_LINK_DECONFIGURED,
+    OSW_CQM_LINK_DISCONNECTED,
+    OSW_CQM_LINK_CONNECTED,
+    OSW_CQM_LINK_RECOVERING,
+    OSW_CQM_LINK_TIMING_OUT,
+    OSW_CQM_LINK_TIMED_OUT,
+};
+
+struct osw_cqm;
+struct osw_cqm_notify;
+struct osw_cqm_ops;
+
+typedef void osw_cqm_notify_fn_t(const char *vif_name,
+                                 enum osw_cqm_link_state state,
+                                 const struct osw_channel *last_channel,
+                                 void *priv);
+
+typedef struct osw_cqm *osw_cqm_alloc_fn_t(struct osw_cqm_ops *ops);
+typedef void osw_cqm_set_timeout_sec_fn_t(struct osw_cqm *cqm, float seconds);
+typedef struct osw_cqm_notify *osw_cqm_add_notify_fn_t(struct osw_cqm *cqm,
+                                                       const char *name,
+                                                       osw_cqm_notify_fn_t *fn,
+                                                       void *fn_priv);
+typedef void osw_cqm_del_notify_fn_t(struct osw_cqm_notify *n);
+typedef void osw_cqm_free_fn_t(struct osw_cqm *cqm);
+
+struct osw_cqm_ops {
+    osw_cqm_alloc_fn_t *alloc_fn;
+    osw_cqm_free_fn_t *free_fn;
+    osw_cqm_set_timeout_sec_fn_t *set_timeout_sec_fn;
+    osw_cqm_add_notify_fn_t *add_notify_fn;
+    osw_cqm_del_notify_fn_t *del_notify_fn;
+};
+
+#endif /* OSW_CQM_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_drv.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_drv.h
+++ core/src/lib/osw/inc/osw_drv.h
@@ -1,10 +1,14 @@
-#ifndef OSW_DRV_H
-#define OSW_DRV_H
+#ifndef OSW_DRV_H_INCLUDED
+#define OSW_DRV_H_INCLUDED
 
 #include <osw_types.h>
+#include <osw_tlv.h>
+#include <osw_stats_enum.h>
+#include <osw_module.h>
 #include <module.h>
 
 struct osw_drv;
+struct osw_drv_frame_tx_desc;
 
 struct osw_drv_vif_config_ap {
     struct osw_ifname bridge_if_name;
@@ -48,8 +52,25 @@ struct osw_drv_vif_config_ap {
     bool radius_list_changed;
 };
 
+struct osw_drv_vif_sta_network {
+    struct osw_hwaddr bssid;
+    struct osw_ssid ssid;
+    struct osw_psk psk;
+    struct osw_wpa wpa;
+    struct osw_drv_vif_sta_network *next;
+};
+
+enum osw_drv_vif_config_sta_operation {
+    OSW_DRV_VIF_CONFIG_STA_NOP,
+    OSW_DRV_VIF_CONFIG_STA_CONNECT,
+    OSW_DRV_VIF_CONFIG_STA_RECONNECT,
+    OSW_DRV_VIF_CONFIG_STA_DISCONNECT,
+};
+
 struct osw_drv_vif_config_sta {
-    /* TBD */
+    enum osw_drv_vif_config_sta_operation operation;
+    struct osw_drv_vif_sta_network *network;
+    bool network_changed;
 };
 
 struct osw_drv_vif_config {
@@ -94,13 +115,32 @@ struct osw_drv_vif_state_ap_vlan {
     /* TBD */
 };
 
+enum osw_drv_vif_state_sta_link_status {
+    OSW_DRV_VIF_STATE_STA_LINK_UNKNOWN,
+    OSW_DRV_VIF_STATE_STA_LINK_CONNECTED,
+    OSW_DRV_VIF_STATE_STA_LINK_CONNECTING,
+    OSW_DRV_VIF_STATE_STA_LINK_DISCONNECTED,
+};
+
 struct osw_drv_vif_state_sta_link {
-    /* TBD */
+    enum osw_drv_vif_state_sta_link_status status;
+    struct osw_channel channel;
+    struct osw_hwaddr bssid;
+    struct osw_ssid ssid;
+    struct osw_psk psk;
+    struct osw_wpa wpa;
 };
 
 struct osw_drv_vif_state_sta {
+    /* The link describes the current, actual link state. It
+     * may not match any of the data in network.
+     */
     struct osw_drv_vif_state_sta_link link;
-    /* TBD */
+
+    /* The network defines a (list of) network(s) that the
+     * driver currently has set for roaming purposes.
+     */
+    struct osw_drv_vif_sta_network *network;
 };
 
 struct osw_drv_vif_state {
@@ -132,9 +172,22 @@ struct osw_drv_phy_config {
     struct osw_drv_vif_config_list vif_list;
 };
 
+enum osw_drv_reg_dfs {
+    OSW_DRV_REG_DFS_UNDEFINED,
+    OSW_DRV_REG_DFS_FCC,
+    OSW_DRV_REG_DFS_ETSI,
+};
+
+struct osw_drv_reg_domain {
+    char ccode[3]; /* 2-letter ISO name, \0-terminated */
+    int revision; /* vendor specific value */
+    enum osw_drv_reg_dfs dfs;
+};
+
 struct osw_drv_phy_state {
     struct osw_channel_state *channel_states;
     size_t n_channel_states;
+    struct osw_drv_reg_domain reg_domain;
     struct osw_hwaddr mac_addr;
     bool exists;
     bool enabled;
@@ -186,7 +239,7 @@ osw_drv_get_sta_list_fn_t(struct osw_drv
                           osw_drv_report_sta_fn_t *report_sta_fn,
                           void *fn_priv);
 
-typedef void 
+typedef void
 osw_drv_request_phy_state_fn_t(struct osw_drv *drv,
                                const char *phy_name);
 
@@ -208,6 +261,13 @@ osw_drv_request_config_fn_t(struct osw_d
 typedef void
 osw_drv_request_wps_pbc_fn_t(struct osw_drv *drv);
 
+/* FIXME: This should actually re-use the
+ * push_frame_tx_fn and expect that to be handled
+ * by the underlying driver appropriately. If the
+ * driver has a dedicated interface/API call
+ * internally to do deauth, instead of just mgmt
+ * or action tx, then it can call that.
+ */
 typedef void
 osw_drv_request_sta_deauth_fn_t(struct osw_drv *drv,
                                 const char *phy_name,
@@ -215,6 +275,15 @@ osw_drv_request_sta_deauth_fn_t(struct o
                                 const struct osw_hwaddr *mac_addr,
                                 int dot11_reason_code);
 
+typedef void
+osw_drv_request_stats_fn_t(struct osw_drv *drv);
+
+typedef void
+osw_drv_push_frame_tx_fn_t(struct osw_drv *drv,
+                           const char *phy_name,
+                           const char *vif_name,
+                           struct osw_drv_frame_tx_desc *desc);
+
 struct osw_drv_ops {
     const char *name;
     osw_drv_init_fn_t *init_fn;
@@ -227,6 +296,8 @@ struct osw_drv_ops {
     osw_drv_request_sta_deauth_fn_t *request_sta_deauth_fn;
     osw_drv_request_wps_pbc_fn_t *request_wps_pbc_fn;
     osw_drv_request_config_fn_t *request_config_fn;
+    osw_drv_request_stats_fn_t *request_stats_fn;
+    osw_drv_push_frame_tx_fn_t *push_frame_tx_fn;
 
     /* TODO
     request_vif_deauth_fn_t
@@ -241,18 +312,10 @@ struct osw_drv_ops {
     */
 };
 
-struct osw_drv_report_sta_probe_req_arg {
-    unsigned int snr;
-    bool ssid_present;
-};
-
-struct osw_drv_report_sta_auth_fail_arg {
-    unsigned int snr;
-};
-
-struct osw_drv_report_sta_action_frame_arg {
-    const void *action_frame;
-    size_t action_frame_len;
+struct osw_drv_report_vif_probe_req {
+    struct osw_hwaddr sta_addr;
+    unsigned int snr; /* TODO Replace with osw_signal */
+    struct osw_ssid ssid;
 };
 
 void
@@ -284,11 +347,36 @@ osw_drv_report_phy_state(struct osw_drv
                          const struct osw_drv_phy_state *state);
 
 void
+osw_drv_report_vif_probe_req(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_drv_report_vif_probe_req *probe_req);
+
+void
+osw_drv_report_vif_rrm_report(struct osw_drv *drv,
+                              const char *phy_name,
+                              const char *vif_name,
+                              const uint8_t *data,
+                              size_t len);
+
+void
 osw_drv_report_vif_changed(struct osw_drv *drv,
                            const char *phy_name,
                            const char *vif_name);
 
 void
+osw_drv_report_vif_connected(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_ssid *ssid,
+                             const struct osw_hwaddr *bssid);
+
+void
+osw_drv_report_vif_disconnected(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name);
+
+void
 osw_drv_report_vif_state(struct osw_drv *drv,
                          const char *phy_name,
                          const char *vif_name,
@@ -300,6 +388,18 @@ osw_drv_report_vif_channel_change_starte
                                           const char *vif_name,
                                           const struct osw_channel *target_channel);
 
+/* When STA link is active and the root AP advertises a CSA
+ * - either through Beacon or Action frame - then this
+ * function shall be called, regardless of whether the
+ * target channel is serviciable by the STA link's radio or
+ * not.
+ */
+void
+osw_drv_report_vif_channel_change_advertised(struct osw_drv *drv,
+                                             const char *phy_name,
+                                             const char *vif_name,
+                                             const struct osw_channel *channel);
+
 void
 osw_drv_report_sta_changed(struct osw_drv *drv,
                            const char *phy_name,
@@ -314,44 +414,28 @@ osw_drv_report_sta_state(struct osw_drv
                          const struct osw_drv_sta_state *state);
 
 void
-osw_drv_report_sta_connected(struct osw_drv *drv,
-                             const char *phy_name,
-                             const char *vif_name,
-                             const struct osw_hwaddr *mac_addr);
+osw_drv_report_stats(struct osw_drv *drv,
+                     const struct osw_tlv *tlv);
 
 void
-osw_drv_report_sta_disconnected(struct osw_drv *drv,
-                                const char *phy_name,
-                                const char *vif_name,
-                                const struct osw_hwaddr *mac_addr);
+osw_drv_conf_free(struct osw_drv_conf *conf);
 
-void
-osw_drv_report_sta_probe_req(struct osw_drv *drv,
-                             const char *phy_name,
-                             const char *vif_name,
-                             const struct osw_hwaddr *mac_addr,
-                             const struct osw_drv_report_sta_probe_req_arg *arg);
+bool
+osw_drv_work_is_settled(void);
 
 void
-osw_drv_report_sta_auth_fail(struct osw_drv *drv,
-                             const char *phy_name,
-                             const char *vif_name,
-                             const struct osw_hwaddr *mac_addr,
-                             const struct osw_drv_report_sta_auth_fail_arg *arg);
+osw_drv_report_frame_tx_state_submitted(struct osw_drv *drv);
 
 void
-osw_drv_report_sta_action_frame(struct osw_drv *drv,
-                                const char *phy_name,
-                                const char *vif_name,
-                                const struct osw_hwaddr *mac_addr,
-                                const struct osw_drv_report_sta_action_frame_arg *arg);
+osw_drv_report_frame_tx_state_failed(struct osw_drv *drv);
 
 void
-osw_drv_conf_free(struct osw_drv_conf *conf);
-
-bool
-osw_drv_work_is_settled(void);
-
+osw_drv_report_sta_assoc_ies(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *sta_addr,
+                             const void *ies,
+                             const size_t ies_len);
 /* TODO
 void osw_drv_report_sta_deauth_tx
 void osw_drv_report_sta_deauth_rx
@@ -364,7 +448,6 @@ void osw_drv_report_sta_associate_tx
 void osw_drv_report_sta_authorize
 void osw_drv_report_sta_deauthorize
 void osw_drv_report_sta_low_ack
-void osw_drv_report_sta_assoc_ies
 void osw_drv_report_phy_radar_detected
 void osw_drv_report_vif_channel_changed
 void osw_drv_report_vif_channel_change_started
@@ -383,9 +466,6 @@ void osw_drv_report_rx_probe_request
 void osw_drv_report_rx_action_frame
 */
 
-#define OSW_DRV_DEFINE(ops) \
-    static void ops##module_start(void *data) { osw_drv_register_ops(&ops); } \
-    static void ops##module_stop(void *data) {} \
-    MODULE(ops##module, ops##module_start, ops##module_stop)
+#define OSW_DRV_DEFINE(ops) OSW_MODULE(ops) { osw_drv_register_ops(&ops); return NULL; }
 
-#endif /* OSW_DRV_H */
+#endif /* OSW_DRV_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_drv_common.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_drv_common.h
@@ -0,0 +1,200 @@
+#ifndef OSW_DRV_COMMON_H
+#define OSW_DRV_COMMON_H
+
+#include <stdint.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+
+#define OSW_DRV_FRAME_TX_DESC_BUF_SIZE 4096
+
+#define DOT11_RRM_MEAS_REP_IE_CATEGORY_CODE 0x05
+#define DOT11_RRM_MEAS_REQ_IE_ACTION_CODE 0x00
+#define DOT11_RRM_MEAS_REP_IE_ACTION_CODE 0x01
+#define DOT11_RRM_MEAS_REP_IE_TAG 0x27
+#define DOT11_RRM_MEAS_REP_IE_REP_MODE_REFUSED_MSK 0x04
+
+struct osw_drv;
+struct osw_drv_frame;
+struct osw_drv_frame_tx_desc;
+
+enum osw_frame_tx_result {
+    OSW_FRAME_TX_RESULT_SUBMITTED,
+    OSW_FRAME_TX_RESULT_FAILED,
+    OSW_FRAME_TX_RESULT_DROPPED,
+};
+
+typedef void
+osw_drv_frame_tx_result_fn_t(const struct osw_drv_frame_tx_desc *desc,
+                             enum osw_frame_tx_result result,
+                             void *caller_priv);
+
+struct osw_drv_dot11_frame_header {
+    uint16_t frame_control;
+    uint16_t duration;
+    uint8_t da[6];
+    uint8_t sa[6];
+    uint8_t bssid[6];
+    uint16_t seq_ctrl;
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_frame_action_bss_tm_req {
+    uint8_t action;
+    uint8_t dialog_token;
+    uint8_t options;
+    uint16_t disassoc_timer;
+    uint8_t validity_interval;
+    /*
+     * Variable and optional IE:
+     * - BSS Termination Duration
+     * - Session Information URL
+     * - BSS Transition Candidate List Entries
+     */
+    uint8_t variable[];
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_frame_action_bss_tm_resp {
+    uint8_t action;
+    uint8_t dialog_token;
+    uint8_t status_code;
+    uint8_t bss_termination_delay;
+    /*
+     * Variable and optional IE:
+     * - Target BSSID
+     * - BSS Transition Candidate List Entries
+     */
+    uint8_t variable[];
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_frame_action_rrm_meas_req {
+    uint8_t action;
+    uint8_t dialog_token;
+    uint16_t repetitions;
+    /*
+     * Variable and required IE:
+     * - Measurement Request IE (>=1)
+     */
+    uint8_t variable[];
+} __attribute__((__packed__));
+
+
+struct osw_drv_dot11_frame_action_rrm_meas_rep {
+    uint8_t action;
+    uint8_t dialog_token;
+    uint8_t variable[];
+} __attribute__((__packed__));
+
+
+struct osw_drv_dot11_frame_action {
+    uint8_t category;
+    union {
+        struct osw_drv_dot11_frame_action_bss_tm_req bss_tm_req;
+        struct osw_drv_dot11_frame_action_bss_tm_resp bss_tm_resp;
+        struct osw_drv_dot11_frame_action_rrm_meas_req rrm_meas_req;
+        struct osw_drv_dot11_frame_action_rrm_meas_rep rrm_meas_rep;
+    } u;
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_frame {
+    struct osw_drv_dot11_frame_header header;
+    union {
+        struct osw_drv_dot11_frame_action action;
+    } u;
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_neighbor_report {
+    uint8_t tag;
+    uint8_t tag_len;
+    uint8_t bssid[6];
+    uint32_t bssid_info;
+    uint8_t op_class;
+    uint8_t channel;
+    uint8_t phy_type;
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_meas_req_ie {
+    uint8_t tag;
+    uint8_t tag_len;
+    uint8_t token;
+    uint8_t req_mode;
+    uint8_t req_type;
+    uint8_t op_class;
+    uint8_t channel;
+    uint16_t rand_interval;
+    uint16_t duration;
+    uint8_t meas_mode;
+    uint8_t bssid[6];
+    /*
+     * SubElements
+     * - SSID
+     * - Beacon Reporting Information
+     * - Reporting Detail
+     */
+    uint8_t variable[];
+} __attribute__((__packed__));
+
+/* SSID SubElement  */
+struct osw_drv_dot11_meas_req_ie_subel_ssid {
+    uint8_t tag;
+    uint8_t tag_len;
+    uint8_t ssid[];
+} __attribute__((__packed__));
+
+/* Beacon Reporting Information SubElement */
+struct osw_drv_dot11_meas_req_ie_subel_bri {
+    uint8_t tag;
+    uint8_t tag_len;
+    uint8_t reporting_condition;
+    /* Threshold / Offset*/
+    uint8_t thr_offs;
+} __attribute__((__packed__));
+
+/* Reporting Detail */
+struct osw_drv_dot11_meas_req_ie_subel_rep_det {
+    uint8_t tag;
+    uint8_t tag_len;
+    uint8_t reporting_detail;
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_meas_rep_ie {
+    uint8_t tag;
+    uint8_t tag_len;
+    uint8_t token;
+    uint8_t report_mode;
+    uint8_t report_type;
+    uint8_t op_class;
+    uint8_t channel;
+    uint64_t start_time;
+    uint16_t duration;
+    uint8_t frame_info;
+    uint8_t rcpi;
+    uint8_t rsni;
+    uint8_t bssid[6];
+    uint8_t antenna_id;
+    uint32_t parent_tsf;
+    /*
+     * SubElements
+     * - Reported Frame Body Fragment ID
+     */
+    uint8_t variable[];
+} __attribute__((__packed__));
+
+struct osw_drv_dot11_meas_rep_ie_subel_rep_frag_id {
+    uint8_t tag;
+    uint8_t tag_len;
+    uint16_t fragment_id;
+} __attribute__((__packed__));
+
+const char*
+osw_frame_tx_result_to_cstr(enum osw_frame_tx_result result);
+
+const uint8_t*
+osw_drv_frame_tx_desc_get_frame(const struct osw_drv_frame_tx_desc *desc);
+
+size_t
+osw_drv_frame_tx_desc_get_frame_len(const struct osw_drv_frame_tx_desc *desc);
+
+const struct osw_channel *
+osw_drv_frame_tx_desc_get_channel(const struct osw_drv_frame_tx_desc *desc);
+
+#endif /* OSW_DRV_COMMON_H */
Index: core/src/lib/osw/inc/osw_drv_dummy.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_drv_dummy.h
+++ core/src/lib/osw/inc/osw_drv_dummy.h
@@ -1,15 +1,37 @@
-#ifndef OSW_DRV_DUMMY_H
-#define OSW_DRV_DUMMY_H
+#ifndef OSW_DRV_DUMMY_H_INCLUDED
+#define OSW_DRV_DUMMY_H_INCLUDED
 
 #include <ds_tree.h>
 #include <ds_dlist.h>
+#include <osw_drv_common.h>
 #include <osw_drv.h>
 
-struct osw_drv_dummy_phy;
-struct osw_drv_dummy_vif;
-struct osw_drv_dummy_sta;
 struct osw_drv_dummy;
 
+struct osw_drv_dummy_phy {
+    struct ds_tree_node node;
+    struct osw_ifname phy_name;
+    struct osw_drv_phy_state state;
+};
+
+struct osw_drv_dummy_vif {
+    struct ds_tree_node node;
+    struct osw_ifname phy_name;
+    struct osw_ifname vif_name;
+    struct osw_drv_vif_state state;
+};
+
+struct osw_drv_dummy_sta {
+    struct ds_dlist_node node;
+    struct osw_ifname phy_name;
+    struct osw_ifname vif_name;
+    struct osw_hwaddr sta_addr;
+    struct osw_drv_sta_state state;
+    void *ies;
+    size_t ies_len;
+};
+
+
 typedef void osw_drv_dummy_fini_phy_fn_t(struct osw_drv_dummy *dummy, struct osw_drv_phy_state *phy);
 typedef void osw_drv_dummy_fini_vif_fn_t(struct osw_drv_dummy *dummy, struct osw_drv_vif_state *vif);
 typedef void osw_drv_dummy_fini_sta_fn_t(struct osw_drv_dummy *dummy, struct osw_drv_sta_state *sta);
@@ -31,6 +53,9 @@ struct osw_drv_dummy {
     osw_drv_dummy_fini_sta_fn_t *const fini_sta_fn;
     osw_drv_init_fn_t *const init_fn;
     osw_drv_request_config_fn_t *const request_config_fn;
+    osw_drv_request_stats_fn_t *const request_stats_fn;
+    osw_drv_request_sta_deauth_fn_t *request_sta_deauth_fn;
+    osw_drv_push_frame_tx_fn_t *const push_frame_tx_fn;
 };
 
 void
@@ -58,9 +83,17 @@ osw_drv_dummy_set_sta(struct osw_drv_dum
                       struct osw_drv_sta_state *state);
 
 void
+osw_drv_dummy_set_sta_ies(struct osw_drv_dummy *dummy,
+                          const char *phy_name,
+                          const char *vif_name,
+                          const struct osw_hwaddr *sta_addr,
+                          const void *ies,
+                          size_t ies_len);
+
+void
 osw_drv_dummy_iter_sta(struct osw_drv_dummy *dummy,
                        osw_drv_dummy_iter_sta_fn_t *fn,
                        void *fn_data);
 
 
-#endif /* OSW_DRV_DUMMY_H */
+#endif /* OSW_DRV_DUMMY_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_drv_mediator.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_drv_mediator.h
@@ -0,0 +1,22 @@
+#ifndef OSW_DRV_MEDIATOR_H
+#define OSW_DRV_MEDIATOR_H
+
+struct osw_drv_frame_tx_desc*
+osw_drv_frame_tx_desc_new(osw_drv_frame_tx_result_fn_t *result_fn,
+                          void *caller_priv);
+
+void
+osw_drv_frame_tx_desc_free(struct osw_drv_frame_tx_desc *desc);
+
+void
+osw_drv_frame_tx_desc_cancel(struct osw_drv_frame_tx_desc *desc);
+
+bool
+osw_drv_frame_tx_desc_is_scheduled(const struct osw_drv_frame_tx_desc *desc);
+
+void
+osw_drv_frame_tx_desc_set_frame(struct osw_drv_frame_tx_desc *desc,
+                                const uint8_t *data,
+                                size_t data_len);
+
+#endif /* OSW_DRV_MEDIATOR_H */
Index: core/src/lib/osw/inc/osw_module.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_module.h
@@ -0,0 +1,45 @@
+#ifndef OSW_MODULE_H_INCLUDED
+#define OSW_MODULE_H_INCLUDED
+
+#include <module.h>
+#include <ds_tree.h>
+
+typedef void *osw_module_fn_t(void);
+
+struct osw_module {
+    struct ds_tree_node node;
+    const char *name;
+    const char *file;
+    void *data;
+    bool loaded;
+    osw_module_fn_t *fn;
+};
+
+void osw_module_register(struct osw_module *m);
+void osw_module_load(void);
+void *osw_module_load_name(const char *name);
+
+#define OSW_MODULE(mod_name) \
+    static void *osw_module_ ## mod_name ## _load_cb(void); \
+    static void osw_module_ ## mod_name ## _init_cb(void *arg) { \
+        static struct osw_module m = { \
+            .name = #mod_name, \
+            .file = __FILE__, \
+            .fn = osw_module_ ## mod_name ## _load_cb, \
+        }; \
+        osw_module_register(&m); \
+    } \
+    static void osw_module_ ## mod_name ## _fini_cb(void *arg) {} \
+    MODULE(osw_module_## mod_name, \
+           osw_module_## mod_name ## _init_cb, \
+           osw_module_## mod_name ## _fini_cb); \
+    static void *osw_module_ ## mod_name ## _load_cb(void)
+
+/* This can be called from within OSW_MODULE() function body
+ * only. It's intended to allow resolving dependencies
+ * regardless of their registering ordering.
+ */
+#define OSW_MODULE_LOAD(name) \
+    osw_module_load_name(#name)
+
+#endif /* OSW_MODULE_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_mux.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_mux.h
+++ core/src/lib/osw/inc/osw_mux.h
@@ -1,5 +1,8 @@
-#ifndef OSW_MUX_H
-#define OSW_MUX_H
+#ifndef OSW_MUX_H_INCLUDED
+#define OSW_MUX_H_INCLUDED
+
+#include <osw_drv.h>
+#include <osw_types.h>
 
 bool
 osw_mux_request_config(struct osw_drv_conf *conf);
@@ -10,4 +13,15 @@ osw_mux_request_sta_deauth(const char *p
                            const struct osw_hwaddr *mac_addr,
                            int dot11_reason_code);
 
-#endif /* OSW_MUX_H */
+void
+osw_mux_request_stats(void);
+
+bool
+osw_mux_frame_tx_schedule(const char *phy_name,
+                          const char *vif_name,
+                          struct osw_drv_frame_tx_desc *desc);
+
+void
+osw_mux_poll(void);
+
+#endif /* OSW_MUX_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_rrm_meas.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_rrm_meas.h
@@ -0,0 +1,72 @@
+#ifndef OSW_RRM_MEAS_H_INCLUDED
+#define OSW_RRM_MEAS_H_INCLUDED
+
+struct osw_rrm_meas_sta;
+struct osw_rrm_meas_sta_observer;
+struct osw_rrm_meas_desc;
+struct osw_rrm_meas_req_params;
+struct osw_rrm_meas_rep_neigh;
+
+/* FIXME use desc and void*priv */
+typedef
+void osw_rrm_meas_req_tx_complete_fn_t(const struct osw_rrm_meas_sta_observer *observer);
+
+typedef
+void osw_rrm_meas_req_tx_error_fn_t(const struct osw_rrm_meas_sta_observer *observer);
+
+struct osw_rrm_meas_sta_observer {
+    osw_rrm_meas_req_tx_complete_fn_t * req_tx_complete_fn;
+    osw_rrm_meas_req_tx_error_fn_t * req_tx_error_fn;
+};
+
+/* rrm measurement request parameters */
+struct osw_rrm_meas_req_params {
+    uint8_t op_class;
+    uint8_t channel;
+    struct osw_hwaddr bssid;
+    struct osw_ssid ssid;
+};
+
+/* rrm measurement report neighbor */
+struct osw_rrm_meas_rep_neigh {
+    struct osw_hwaddr bssid;
+    uint8_t op_class;
+    uint8_t channel;
+    uint8_t rcpi;
+    uint64_t scan_start_time;
+
+    ds_tree_node_t node;
+};
+
+void
+osw_rrm_meas_init(void);
+
+struct osw_rrm_meas_desc*
+osw_rrm_meas_get_desc(const struct osw_hwaddr *sta_addr,
+                      const struct osw_rrm_meas_sta_observer *observer,
+                      const char *phy_name,
+                      const char *vif_name);
+
+bool
+osw_rrm_meas_desc_set_req_params(struct osw_rrm_meas_desc *desc,
+                                 const struct osw_rrm_meas_req_params *req_params);
+
+struct osw_rrm_meas_sta*
+osw_rrm_meas_desc_get_sta(struct osw_rrm_meas_desc *desc);
+
+void
+osw_rrm_meas_sta_set_throttle(struct osw_rrm_meas_sta *rrm_meas_sta,
+                              struct osw_throttle *throttle);
+
+const struct osw_rrm_meas_rep_neigh *
+osw_rrm_meas_get_neigh(const struct osw_hwaddr *sta_addr,
+                       const struct osw_hwaddr *bssid);
+
+/* FIXME create function returning only neighbor list for a station.
+ * Make sure a neighbor list returned is separate from sta as
+ * otherwise it is going to be freed when freeing sta.
+ * For now neigh_tree fetched from get_sta can be used as
+ * long as sta is not freed.
+ */
+
+#endif /* OSW_RRM_MEAS_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_sampler.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_sampler.h
@@ -0,0 +1,34 @@
+#ifndef OSW_SAMPLER_H_INCLUDED
+#define OSW_SAMPLER_H_INCLUDED
+
+struct osw_sampler {
+    double next_poll_tstamp;
+    double poll_started_tstamp;
+    double period_seconds;
+    double poll_delay_seconds;
+};
+
+void
+osw_sampler_set_period_seconds(struct osw_sampler *s,
+                               const double seconds);
+
+bool
+osw_sampler_is_started(struct osw_sampler *s);
+
+double
+osw_sampler_adjust(struct osw_sampler *s,
+                   const double now);
+
+void
+osw_sampler_start_at(struct osw_sampler *s,
+                     const double now);
+
+double
+osw_sampler_get_remaining_seconds(const struct osw_sampler *s,
+                                  const double now);
+
+int
+osw_sampler_run(struct osw_sampler *s,
+                const double now);
+
+#endif /* OSW_SAMPLER_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_sta_cache.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_sta_cache.h
@@ -0,0 +1,73 @@
+#ifndef OSW_STA_CACHE_H
+#define OSW_STA_CACHE_H
+
+struct osw_sta;
+struct osw_sta_link;
+struct osw_sta_observer;
+struct osw_sta_cache_observer;
+
+typedef void
+osw_sta_cache_sta_appeared_fn_t(struct osw_sta_cache_observer *self,
+                                struct osw_sta *sta);
+
+typedef void
+osw_sta_cache_sta_vanished_fn_t(struct osw_sta_cache_observer *self,
+                                struct osw_sta *sta);
+
+typedef void
+osw_sta_connected_fn_t(struct osw_sta_observer *self,
+                       struct osw_sta *sta,
+                       const struct osw_sta_link *link);
+
+typedef void
+osw_sta_disconnected_fn_t(struct osw_sta_observer *self,
+                          struct osw_sta *sta,
+                          const struct osw_sta_link *link);
+
+typedef void
+osw_sta_probe_req_fn_t(struct osw_sta_observer *self,
+                       struct osw_sta *sta,
+                       const struct osw_sta_link *link,
+                       const struct osw_drv_report_vif_probe_req *probe_req);
+
+struct osw_sta_observer {
+    const char *name;
+    osw_sta_connected_fn_t *const connected_fn;
+    osw_sta_disconnected_fn_t *const disconnected_fn;
+    osw_sta_probe_req_fn_t *const probe_req_fn;
+
+    struct ds_dlist_node node;
+};
+
+struct osw_sta_cache_observer {
+    const char *name;
+    osw_sta_cache_sta_appeared_fn_t *const appeared_fn;
+    osw_sta_cache_sta_vanished_fn_t *const vanished_fn;
+
+    struct ds_dlist_node node;
+};
+
+void
+osw_sta_cache_register_observer(struct osw_sta_cache_observer *observer);
+
+void
+osw_sta_cache_unregister_observer(struct osw_sta_cache_observer *observer);
+
+struct osw_sta*
+osw_sta_cache_lookup_sta(const struct osw_hwaddr *sta_addr);
+
+void
+osw_sta_register_observer(struct osw_sta *sta,
+                          struct osw_sta_observer *observer);
+
+void
+osw_sta_unregister_observer(struct osw_sta *sta,
+                            struct osw_sta_observer *observer);
+
+const struct osw_hwaddr*
+osw_sta_get_mac_addr(const struct osw_sta *sta);
+
+const struct osw_state_vif_info*
+osw_sta_link_get_vif_info(const struct osw_sta_link *link);
+
+#endif /* OSW_STA_CACHE_H */
Index: core/src/lib/osw/inc/osw_state.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_state.h
+++ core/src/lib/osw/inc/osw_state.h
@@ -1,6 +1,7 @@
-#ifndef OSW_STATE_H
-#define OSW_STATE_H
+#ifndef OSW_STATE_H_INCLUDED
+#define OSW_STATE_H_INCLUDED
 
+#include <osw_drv_common.h>
 #include <osw_drv.h>
 #include <ds_dlist.h>
 
@@ -26,11 +27,6 @@ struct osw_state_sta_info {
     size_t assoc_req_ies_len;
 };
 
-struct osw_state_sta_probe_req_arg {
-    unsigned int snr;
-    bool ssid_present;
-};
-
 struct osw_state_sta_auth_fail_arg {
     unsigned int snr;
 };
@@ -83,27 +79,34 @@ osw_state_vif_changed_fn_t(struct osw_st
                            const struct osw_state_vif_info *vif);
 
 typedef void
-osw_state_sta_connected_fn_t(struct osw_state_observer *self,
-                             const struct osw_state_sta_info *sta);
+osw_state_vif_probe_req_fn_t(struct osw_state_observer *self,
+                             const struct osw_state_vif_info *vif,
+                             const struct osw_drv_report_vif_probe_req *probe_req);
 
 typedef void
-osw_state_sta_disconnected_fn_t(struct osw_state_observer *self,
-                                const struct osw_state_sta_info *sta);
+osw_state_vif_csa_rx_fn_t(struct osw_state_observer *self,
+                          const struct osw_state_vif_info *vif,
+                          const struct osw_channel *channel);
 
 typedef void
-osw_state_sta_probe_req_fn_t(struct osw_state_observer *self,
-                             const struct osw_state_sta_info *sta,
-                             const struct osw_state_sta_probe_req_arg *arg);
+osw_state_vif_rrm_rep_fn_t(struct osw_state_observer *self,
+                           const struct osw_state_vif_info *vif,
+                           const uint8_t *data,
+                           size_t len);
 
 typedef void
-osw_state_sta_auth_fail_fn_t(struct osw_state_observer *self,
-                             const struct osw_state_sta_info *sta,
-                             const struct osw_state_sta_auth_fail_arg *arg);
+osw_state_vif_csa_to_phy_fn_t(struct osw_state_observer *self,
+                              const struct osw_state_vif_info *vif,
+                              const struct osw_state_phy_info *to_phy,
+                              const struct osw_channel *channel);
 
 typedef void
-osw_state_sta_action_frame_fn_t(struct osw_state_observer *self,
-                                const struct osw_state_sta_info *sta,
-                                const struct osw_state_sta_action_frame_arg *arg);
+osw_state_sta_connected_fn_t(struct osw_state_observer *self,
+                             const struct osw_state_sta_info *sta);
+
+typedef void
+osw_state_sta_disconnected_fn_t(struct osw_state_observer *self,
+                                const struct osw_state_sta_info *sta);
 
 typedef void
 osw_state_sta_changed_fn_t(struct osw_state_observer *self,
@@ -111,21 +114,22 @@ osw_state_sta_changed_fn_t(struct osw_st
 
 struct osw_state_observer {
     struct ds_dlist_node node;
-    const char *const name;
-    osw_state_idle_fn_t *const idle_fn;
-    osw_state_busy_fn_t *const busy_fn;
-    osw_state_phy_added_fn_t *const phy_added_fn;
-    osw_state_phy_removed_fn_t *const phy_removed_fn;
-    osw_state_phy_changed_fn_t *const phy_changed_fn;
-    osw_state_vif_added_fn_t *const vif_added_fn;
-    osw_state_vif_removed_fn_t *const vif_removed_fn;
-    osw_state_vif_changed_fn_t *const vif_changed_fn;
-    osw_state_sta_connected_fn_t *const sta_connected_fn;
-    osw_state_sta_disconnected_fn_t *const sta_disconnected_fn;
-    osw_state_sta_probe_req_fn_t *const sta_probe_req_fn;
-    osw_state_sta_auth_fail_fn_t *const sta_auth_fail_fn;
-    osw_state_sta_action_frame_fn_t *const sta_action_frame_fn;
-    osw_state_sta_changed_fn_t *const sta_changed_fn;
+    const char *name;
+    osw_state_idle_fn_t *idle_fn;
+    osw_state_busy_fn_t *busy_fn;
+    osw_state_phy_added_fn_t *phy_added_fn;
+    osw_state_phy_removed_fn_t *phy_removed_fn;
+    osw_state_phy_changed_fn_t *phy_changed_fn;
+    osw_state_vif_added_fn_t *vif_added_fn;
+    osw_state_vif_removed_fn_t *vif_removed_fn;
+    osw_state_vif_changed_fn_t *vif_changed_fn;
+    osw_state_vif_probe_req_fn_t *vif_probe_req_fn;
+    osw_state_vif_csa_rx_fn_t *vif_csa_rx_fn;
+    osw_state_vif_rrm_rep_fn_t *vif_rrm_rep_fn;
+    osw_state_vif_csa_to_phy_fn_t *vif_csa_to_phy_fn;
+    osw_state_sta_connected_fn_t *sta_connected_fn;
+    osw_state_sta_disconnected_fn_t *sta_disconnected_fn;
+    osw_state_sta_changed_fn_t *sta_changed_fn;
 };
 
 void
@@ -141,6 +145,12 @@ const struct osw_state_vif_info *
 osw_state_vif_lookup(const char *phy_name,
                      const char *vif_name);
 
+const struct osw_state_vif_info *
+osw_state_vif_lookup_by_mac_addr(const struct osw_hwaddr *mac_addr);
+
+const struct osw_state_vif_info *
+osw_state_vif_lookup_by_vif_name(const char *vif_name);
+
 const struct osw_state_sta_info *
 osw_state_sta_lookup(const char *phy_name,
                      const char *vif_name,
@@ -169,4 +179,4 @@ osw_state_sta_get_list(osw_state_report_
     static void obs##module_stop(void *data) { osw_state_unregister_observer(&obj); } \
     MODULE(obs##module, obs##module_start, obs##module_stop)
 
-#endif /* OSW_STATE_H */
+#endif /* OSW_STATE_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_stats.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_stats.h
@@ -0,0 +1,23 @@
+#ifndef OSW_STATS_H_INCLUDED
+#define OSW_STATS_H_INCLUDED
+
+#include <stdbool.h>
+#include <time.h>
+
+#include <osw_tlv.h>
+#include <osw_stats_subscriber.h>
+
+typedef void osw_stats_reschedule_fn_t(void *priv);
+
+void
+osw_stats_run(bool *poll,
+              double *remaining_seconds,
+              const double now);
+
+void
+osw_stats_register_subscriber(struct osw_stats_subscriber *sub);
+
+void
+osw_stats_unregister_subscriber(struct osw_stats_subscriber *sub);
+
+#endif /* OSW_STATS_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_stats_defs.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_stats_defs.h
@@ -0,0 +1,21 @@
+#ifndef OSW_STATS_DEFS_H_INCLUDED
+#define OSW_STATS_DEFS_H_INCLUDED
+
+#include <osw_stats_enum.h>
+#include <osw_tlv.h>
+#include <osw_tlv_merge.h>
+
+typedef void osw_stats_defs_postprocess_fn_t(struct osw_tlv *data);
+
+struct osw_stats_defs {
+    osw_stats_defs_postprocess_fn_t *postprocess_fn;
+    const struct osw_tlv_policy *tpolicy;
+    const struct osw_tlv_merge_policy *mpolicy;
+    enum osw_tlv_merge_first_policy first;
+    size_t size;
+};
+
+const struct osw_stats_defs *
+osw_stats_defs_lookup(enum osw_stats_id stats_id);
+
+#endif /* OSW_STATS_DEFS_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_stats_enum.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_stats_enum.h
@@ -0,0 +1,74 @@
+#ifndef OSW_STATS_ENUM_H_INCLUDED
+#define OSW_STATS_ENUM_H_INCLUDED
+
+enum osw_stats_id {
+    OSW_STATS_PHY,
+    OSW_STATS_VIF,
+    OSW_STATS_STA,
+    OSW_STATS_CHAN,
+    OSW_STATS_BSS_SCAN,
+
+    OSW_STATS_MAX__, /* keep last */
+};
+
+enum osw_stats_sta_id {
+    OSW_STATS_STA_PHY_NAME,
+    OSW_STATS_STA_VIF_NAME,
+    OSW_STATS_STA_MAC_ADDRESS,
+    OSW_STATS_STA_SNR_DB,
+    OSW_STATS_STA_TX_BYTES,
+    OSW_STATS_STA_TX_FRAMES,
+    OSW_STATS_STA_TX_RETRIES,
+    OSW_STATS_STA_TX_ERRORS,
+    OSW_STATS_STA_TX_RATE_MBPS,
+    OSW_STATS_STA_RX_BYTES,
+    OSW_STATS_STA_RX_FRAMES,
+    OSW_STATS_STA_RX_RETRIES,
+    OSW_STATS_STA_RX_ERRORS,
+    OSW_STATS_STA_RX_RATE_MBPS,
+
+    OSW_STATS_STA_MAX__, /* keep last */
+};
+
+enum osw_stats_bss_scan_id {
+    OSW_STATS_BSS_SCAN_PHY_NAME,
+    OSW_STATS_BSS_SCAN_MAC_ADDRESS,
+    OSW_STATS_BSS_SCAN_FREQ_MHZ,
+    OSW_STATS_BSS_SCAN_SSID,
+    OSW_STATS_BSS_SCAN_WIDTH_MHZ,
+    OSW_STATS_BSS_SCAN_IES,
+    OSW_STATS_BSS_SCAN_SNR_DB,
+
+    OSW_STATS_BSS_SCAN_MAX__, /* keep last */
+};
+
+enum osw_stats_vif_id {
+    OSW_STATS_VIF_NAME,
+    OSW_STATS_VIF_PHY_NAME,
+};
+
+enum osw_stats_phy_id {
+    OSW_STATS_PHY_NAME,
+};
+
+enum osw_stats_chan_counter_id {
+    OSW_STATS_CHAN_CNT_TX,
+    OSW_STATS_CHAN_CNT_RX,
+    OSW_STATS_CHAN_CNT_RX_INBSS,
+    OSW_STATS_CHAN_CNT_BUSY,
+
+    OSW_STATS_CHAN_CNT_MAX__, /* keep last */
+};
+
+enum osw_stats_chan_id {
+    OSW_STATS_CHAN_PHY_NAME,
+    OSW_STATS_CHAN_FREQ_MHZ,
+    OSW_STATS_CHAN_ACTIVE_MSEC,
+    OSW_STATS_CHAN_CNT_MSEC, /* nested: osw_stats_chan_counter_id */
+    OSW_STATS_CHAN_CNT_PERCENT, /* nested: osw_stats_chan_counter_id */
+    OSW_STATS_CHAN_NOISE_FLOOR_DBM,
+
+    OSW_STATS_CHAN_MAX__, /* keep last */
+};
+
+#endif /* OSW_STATS_ENUM_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_stats_subscriber.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_stats_subscriber.h
@@ -0,0 +1,54 @@
+#ifndef OSW_STATS_SUBSCRIBER_H_INCLUDED
+#define OSW_STATS_SUBSCRIBER_H_INCLUDED
+
+#include <osw_stats_enum.h>
+#include <osw_tlv.h>
+#include <osw_sampler.h>
+
+struct osw_stats_subscriber;
+
+typedef void osw_stats_subscriber_report_fn_t(enum osw_stats_id id,
+                                              const struct osw_tlv *data,
+                                              const struct osw_tlv *last,
+                                              void *priv);
+
+struct osw_stats_subscriber *
+osw_stats_subscriber_alloc(void);
+
+void
+osw_stats_subscriber_free(struct osw_stats_subscriber *sub);
+
+void
+osw_stats_subscriber_set_report_fn(struct osw_stats_subscriber *sub,
+                                   osw_stats_subscriber_report_fn_t *fn,
+                                   void *priv);
+
+void
+osw_stats_subscriber_set_report_seconds(struct osw_stats_subscriber *sub,
+                                        double seconds);
+
+void
+osw_stats_subscriber_set_poll_seconds(struct osw_stats_subscriber *sub,
+                                      double seconds);
+
+void
+osw_stats_subscriber_set_phy(struct osw_stats_subscriber *sub,
+                             bool enabled);
+
+void
+osw_stats_subscriber_set_vif(struct osw_stats_subscriber *sub,
+                             bool enabled);
+
+void
+osw_stats_subscriber_set_sta(struct osw_stats_subscriber *sub,
+                             bool enabled);
+
+void
+osw_stats_subscriber_set_chan(struct osw_stats_subscriber *sub,
+                              bool enabled);
+
+void
+osw_stats_subscriber_set_bss(struct osw_stats_subscriber *sub,
+                              bool enabled);
+
+#endif /* OSW_STATS_SUBSCRIBER_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_thread.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_thread.h
+++ core/src/lib/osw/inc/osw_thread.h
@@ -1,5 +1,5 @@
-#ifndef OSW_THREAD_H
-#define OSW_THREAD_H
+#ifndef OSW_THREAD_H_INCLUDED
+#define OSW_THREAD_H_INCLUDED
 
 void
 osw_thread_init(void);
@@ -7,4 +7,4 @@ osw_thread_init(void);
 void
 osw_thread_sanity_check(void);
 
-#endif /* OSW_THREAD_H */
+#endif /* OSW_THREAD_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_throttle.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_throttle.h
@@ -0,0 +1,20 @@
+#ifndef OSW_THROTTLE_H
+#define OSW_THROTTLE_H
+
+struct osw_throttle;
+
+struct osw_throttle*
+osw_throttle_new_rate_limit(unsigned int limit,
+                            uint64_t period_nsec);
+
+void
+osw_throttle_free(struct osw_throttle *throttle);
+
+bool
+osw_throttle_tap(struct osw_throttle *throttle,
+                 uint64_t *next_at_nsec);
+
+void
+osw_throttle_reset(struct osw_throttle *throttle);
+
+#endif /* OSW_THROTTLE_H */
Index: core/src/lib/osw/inc/osw_time.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_time.h
@@ -0,0 +1,21 @@
+#ifndef OSW_TIME_H
+#define OSW_TIME_H
+
+uint64_t
+osw_time_mono_clk(void);
+
+uint64_t
+osw_time_wall_clk(void);
+
+void
+osw_time_set_mono_clk(uint64_t nsec);
+
+void
+osw_time_set_wall_clk(uint64_t nsec);
+
+#define OSW_TIME_SEC(sec) ((sec) * 1e9)
+#define OSW_TIME_MSEC(msec) ((msec) * 1e6)
+#define OSW_TIME_TO_DBL(nsec) ((double) ((nsec) * 1e-9))
+#define OSW_TIME_TO_TIME_T(nsec) ((time_t) ((nsec) / 1e6))
+
+#endif /* OSW_TIME_H */
Index: core/src/lib/osw/inc/osw_timer.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_timer.h
@@ -0,0 +1,42 @@
+#ifndef OSW_TIMER_H
+#define OSW_TIMER_H
+
+struct osw_timer_core;
+struct osw_timer;
+
+typedef void
+osw_timer_fn(struct osw_timer *timer);
+
+struct osw_timer {
+    osw_timer_fn *cb;
+    uint64_t at_nsec;
+
+    struct ds_dlist *list;
+    struct ds_dlist_node node;
+};
+
+void
+osw_timer_core_dispatch(uint64_t now_nsec);
+
+bool
+osw_timer_core_get_next_at(uint64_t *next_at_nsec);
+
+void
+osw_timer_init(struct osw_timer *timer,
+               osw_timer_fn *cb);
+
+void
+osw_timer_arm_at_nsec(struct osw_timer *timer,
+                      uint64_t nsec);
+
+void
+osw_timer_disarm(struct osw_timer *timer);
+
+bool
+osw_timer_is_armed(const struct osw_timer *timer);
+
+uint64_t
+osw_timer_get_remaining_nsec(const struct osw_timer *timer,
+                             uint64_t now_nsec);
+
+#endif /* OSW_TIMER_H */
Index: core/src/lib/osw/inc/osw_tlv.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_tlv.h
@@ -0,0 +1,126 @@
+#ifndef OSW_TLV_H_INCLUDED
+#define OSW_TLV_H_INCLUDED
+
+#include <assert.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <osw_types.h>
+
+#define OSW_TLV_TAILROOM 4096
+#define OSW_TLV_MASK (sizeof(uint32_t) - 1)
+#define OSW_TLV_ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
+#define OSW_TLV_ALIGN(x) OSW_TLV_ALIGN_MASK(x, OSW_TLV_MASK)
+#define OSW_TLV_PTR_ALIGNED(x) assert(((intptr_t)(x) & OSW_TLV_MASK) == 0)
+
+struct osw_tlv {
+    void *data;
+    size_t size;
+    size_t used;
+};
+
+enum osw_tlv_type {
+    OSW_TLV_UNSPEC,
+    OSW_TLV_U32,
+    OSW_TLV_FLOAT,
+    OSW_TLV_STRING,
+    OSW_TLV_NESTED,
+    OSW_TLV_HWADDR,
+    // OSW_TLV_U64
+    // OSW_TLV_S8
+    //OSW_TLV_TYPES,
+};
+
+//#define OSW_TLV_F_WHITEOUT (1 << 0)
+#define OSW_TLV_F_DELTA (1 << 0)
+
+struct osw_tlv_hdr {
+    uint32_t id;
+    uint32_t type; /* osw_tlv_type */
+    uint32_t len;
+    uint32_t flags;
+} __attribute__((packed));
+
+struct osw_tlv_policy {
+    enum osw_tlv_type type;
+    uint32_t min_len;
+    uint32_t max_len;
+    const struct osw_tlv_policy *nested;
+    size_t tb_size;
+};
+
+struct osw_tlv *osw_tlv_new(void);
+void osw_tlv_copy(struct osw_tlv *dst, const struct osw_tlv *src);
+void osw_tlv_free(struct osw_tlv *tlv);
+void osw_tlv_fini(struct osw_tlv *tlv);
+void *osw_tlv_reserve(struct osw_tlv *tlv, size_t len);
+void *osw_tlv_put(struct osw_tlv *tlv, uint32_t id, enum osw_tlv_type type, size_t len);
+size_t osw_tlv_parse(const void *data, size_t len,
+                     const struct osw_tlv_policy *policy,
+                     const struct osw_tlv_hdr **tb,
+                     size_t size);
+const struct osw_tlv_hdr *osw_tlv_find(const void *data, size_t len, uint32_t id);
+// non-const find, or macro?
+
+#define osw_tlv_hdr_len() OSW_TLV_ALIGN(sizeof(struct osw_tlv_hdr))
+
+static inline void *
+osw_tlv_get_data(const struct osw_tlv_hdr *hdr)
+{
+    OSW_TLV_PTR_ALIGNED(hdr);
+    return (void *)hdr + OSW_TLV_ALIGN(sizeof(*hdr));
+}
+
+static inline struct osw_tlv_hdr *
+osw_tlv_get_hdr(const void *data)
+{
+    OSW_TLV_PTR_ALIGNED(data);
+    return (void *)data - OSW_TLV_ALIGN(sizeof(struct osw_tlv_hdr));
+}
+
+static inline void *
+osw_tlv_set_flags(void *data, const uint32_t flags)
+{
+    osw_tlv_get_hdr(data)->flags = flags;
+    return data;
+}
+
+static inline void
+osw_tlv_reset(struct osw_tlv *t)
+{
+    t->used = 0;
+    memset(t->data, 0, t->size);
+}
+
+const struct osw_tlv_hdr *osw_tlv_next(const struct osw_tlv_hdr *hdr, size_t *remaining);
+bool osw_tlv_ok(const struct osw_tlv_hdr *hdr, size_t remaining);
+
+#define osw_tlv_get_u32(hdr) (*(const uint32_t *)osw_tlv_get_data(hdr))
+#define osw_tlv_get_float(hdr) (*(const float *)osw_tlv_get_data(hdr))
+#define osw_tlv_get_string(hdr) ((const char *)osw_tlv_get_data(hdr))
+#define osw_tlv_get_hwaddr(addr, hdr) memcpy((addr)->octet, osw_tlv_get_data(hdr), sizeof((addr)->octet))
+
+#define osw_tlv_put_var(tlv, id, type, ctype, x) memcpy(osw_tlv_put(tlv, id, type, sizeof(ctype)), (ctype[]){x}, sizeof(ctype))
+#define osw_tlv_put_u32(tlv, id, x) osw_tlv_put_var(tlv, id, OSW_TLV_U32, uint32_t, x)
+#define osw_tlv_put_u32_delta(tlv, id, x) osw_tlv_set_flags(osw_tlv_put_u32(tlv, id, x), OSW_TLV_F_DELTA)
+#define osw_tlv_put_float(tlv, id, x) osw_tlv_put_var(tlv, id, OSW_TLV_FLOAT, float, x)
+#define osw_tlv_put_float_delta(tlv, id, x) osw_tlv_set_flags(osw_tlv_put_float(tlv, id, x), OSW_TLV_F_DELTA)
+#define osw_tlv_put_data(tlv, id, type, x, s) memcpy(osw_tlv_put(tlv, id, type, (s)), (x), (s))
+#define osw_tlv_put_buf(tlv, id, x, s) osw_tlv_put_data(tlv, id, OSW_TLV_UNSPEC, x, s)
+#define osw_tlv_put_string(tlv, id, x) osw_tlv_put_data(tlv, id, OSW_TLV_STRING, x, strlen(x) + 1)
+#define osw_tlv_put_hwaddr(tlv, id, x) osw_tlv_put_data(tlv, id, OSW_TLV_HWADDR, (x)->octet, sizeof((x)->octet))
+#define osw_tlv_put_nested(tlv, id) osw_tlv_put(tlv, id, OSW_TLV_NESTED, 0)
+#define osw_tlv_end_nested(tlv, start) (osw_tlv_get_hdr(start)->len = (tlv)->data + (tlv)->used - (start))
+#define osw_tlv_put_copy(tlv, hdr) memcpy(osw_tlv_put(tlv, (hdr)->id, (hdr)->type, (hdr)->len), (hdr) + 1, (hdr)->len)
+#define osw_tlv_put_same(tlv, hdr, x, s)  memcpy(osw_tlv_put(tlv, (hdr)->id, (hdr)->type, s), x, s)
+
+#define OSW_TLV_PARSE(tlv, policy, tb, size) osw_tlv_parse((tlv)->data, (tlv)->used, policy, tb, size)
+#define OSW_TLV_FIND(tlv, id) osw_tlv_find((tlv)->data, (tlv)->used, id)
+
+#define osw_tlv_for_each(i, head, rem) \
+    for (i = osw_tlv_ok(head, rem) ? head : NULL; \
+         osw_tlv_ok(i, rem); \
+         i = osw_tlv_next(i, &(rem)))
+
+#endif /* OSW_TLV_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_tlv_merge.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_tlv_merge.h
@@ -0,0 +1,42 @@
+#ifndef OSW_TLV_MERGE_H_INCLUDED
+#define OSW_TLV_MERGE_H_INCLUDED
+
+/**
+ * Provides helpers to aggregate osw tlv payloads. Intended
+ * mostly for statistics.
+ */
+
+#include <osw_tlv.h>
+
+enum osw_tlv_merge_op_type {
+    OSW_TLV_OP_NONE,
+    OSW_TLV_OP_OVERWRITE,
+    // TODO: OSW_TLV_OP_AVERAGE
+    OSW_TLV_OP_ACCUMULATE,
+    OSW_TLV_OP_MERGE,
+};
+
+enum osw_tlv_merge_first_policy {
+    OSW_TLV_INHERIT_FIRST,
+    OSW_TLV_DELTA_AGAINST_ZERO,
+    OSW_TLV_TWO_SAMPLES_MINIMUM,
+};
+
+struct osw_tlv_merge_policy {
+    enum osw_tlv_merge_op_type type;
+    enum osw_tlv_merge_first_policy first;
+    const struct osw_tlv_merge_policy *nested;
+    size_t tb_size;
+};
+
+void
+osw_tlv_merge(struct osw_tlv *dest_tlv,
+              struct osw_tlv *prev_tlv,
+              const void *data,
+              size_t len,
+              bool diff_on_first,
+              const struct osw_tlv_policy *tpolicy,
+              const struct osw_tlv_merge_policy *mpolicy,
+              const size_t tb_size);
+
+#endif /* OSW_TLV_MERGE_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_types.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_types.h
+++ core/src/lib/osw/inc/osw_types.h
@@ -1,5 +1,5 @@
-#ifndef OSW_TYPES_H
-#define OSW_TYPES_H
+#ifndef OSW_TYPES_H_INCLUDED
+#define OSW_TYPES_H_INCLUDED
 
 #include <stdio.h>
 #include <stdbool.h>
@@ -61,6 +61,8 @@ struct osw_channel {
     int center_freq1_mhz;
 };
 
+/* FIXME: need osw_channel_ helper to convert freq->chan */
+
 #define OSW_CHANNEL_FMT "%d (%s/%d)"
 #define OSW_CHANNEL_ARG(c) \
     (c)->control_freq_mhz, \
@@ -73,6 +75,11 @@ struct osw_channel_state {
     int dfs_nol_remaining_seconds;
 };
 
+#define OSW_CHAN_STATE_FMT "%s %ds"
+#define OSW_CHAN_STATE_ARG(x) \
+    osw_channel_dfs_state_to_str((x)->dfs_state), \
+    (x)->dfs_nol_remaining_seconds
+
 #define OSW_HWADDR_LEN 6
 #define OSW_HWADDR_FMT "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx"
 #define OSW_HWADDR_ARG(ptr) \
@@ -89,6 +96,7 @@ struct osw_channel_state {
     &(ptr)->octet[3], \
     &(ptr)->octet[4], \
     &(ptr)->octet[5]
+#define OSW_HWADDR_BROADCAST { .octet = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } }
 
 struct osw_hwaddr {
     unsigned char octet[OSW_HWADDR_LEN];
@@ -105,12 +113,29 @@ osw_hwaddr2str(const struct osw_hwaddr *
     return str->buf;
 }
 
+static inline bool
+osw_hwaddr_from_cstr(const char *src, struct osw_hwaddr *addr)
+{
+    return sscanf(src, OSW_HWADDR_FMT, OSW_HWADDR_SARG(addr)) == 6;
+}
+
+static inline bool
+osw_hwaddr_is_zero(const struct osw_hwaddr *addr)
+{
+    const struct osw_hwaddr zero = {0};
+    return memcmp(addr, &zero, sizeof(*addr)) == 0;
+}
+
 #define OSW_IEEE80211_SSID_LEN 32
 
 struct osw_ifname {
-    char buf[16];
+    char buf[32];
 };
 
+int
+osw_ifname_cmp(const struct osw_ifname *a,
+               const struct osw_ifname *b);
+
 struct osw_ssid {
     char buf[OSW_IEEE80211_SSID_LEN + sizeof('\0')];
     size_t len;
@@ -253,8 +278,14 @@ const char *
 osw_channel_width_to_str(enum osw_channel_width w);
 
 const char *
+osw_channel_dfs_state_to_str(enum osw_channel_state_dfs s);
+
+const char *
 osw_radar_to_str(enum osw_radar_detect r);
 
+const char *
+osw_band_to_str(enum osw_band b);
+
 void
 osw_wpa_to_str(char *out, size_t len, const struct osw_wpa *wpa);
 
@@ -283,4 +314,28 @@ int
 osw_hwaddr_cmp(const struct osw_hwaddr *addr_a,
                const struct osw_hwaddr *addr_b);
 
-#endif /* OSW_TYPES_H */
+static inline int
+osw_channel_nf_20mhz_fixup(const int nf)
+{
+    const int white_noise_dbm = -174; /* 10*log10(1.38*10^-23*290*10^3) */
+    const int noise_20mhz_db = 73; /* 10*log10(20*10^6) */
+    const int mds_dbm = white_noise_dbm + noise_20mhz_db; /* = -101 */
+    const int front_end_att_db = 5; /* rule of thumb, typically 4-10dB */
+    const int def_nf = mds_dbm + front_end_att_db; /* = -96 */
+
+    if (nf < 0 && nf > mds_dbm) return nf;
+    return def_nf;
+}
+
+bool
+osw_channel_from_op_class(int op_class,
+                          int channel_num,
+                          struct osw_channel *channel);
+
+bool
+osw_freq_is_dfs(int freq_mhz);
+
+bool
+osw_channel_overlaps_dfs(const struct osw_channel *c);
+
+#endif /* OSW_TYPES_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_ut.h
===================================================================
--- core.orig/src/lib/osw/inc/osw_ut.h
+++ core/src/lib/osw/inc/osw_ut.h
@@ -1,10 +1,20 @@
-#ifndef OSW_UT_H
-#define OSW_UT_H
+#ifndef OSW_UT_H_INCLUDED
+#define OSW_UT_H_INCLUDED
+
+#include <stdbool.h>
+#include <module.h>
 
 #define OSW_UT_EVAL(cond) assert(cond)
 
 typedef void (*osw_ut_module_run_f) (void *data);
 
+#define OSW_UT(name) \
+    static void osw_ut_func_ ## name(void *arg); \
+    static void osw_ut_init_ ## name(void *arg) { osw_ut_register(#name, osw_ut_func_ ## name, NULL); } \
+    static void osw_ut_fini_ ## name(void *arg) {} \
+    MODULE(osw_ut_ ## name, osw_ut_init_ ## name, osw_ut_fini_ ## name); \
+    static void osw_ut_func_ ## name(void *arg)
+
 #define osw_ut_register(name, fun, data) \
     osw_ut_register_raw(name, __FILE__, #fun, fun, data)
 
@@ -16,10 +26,22 @@ osw_ut_register_raw(const char *name,
                     void *data);
 
 void
-osw_ut_run_by_prefix(const char *prefix, bool verbose);
+osw_ut_run_by_prefix(const char *prefix,
+                     bool dont_fork,
+                     bool verbose);
+
+void
+osw_ut_run_all(bool dont_fork,
+               bool verbose);
+
+void
+osw_ut_print_test_names(void);
+
+void
+osw_ut_time_init(void);
 
 void
-osw_ut_run_all(bool verbose);
+osw_ut_time_advance(uint64_t delta_nsec);
 
 #if 0
 // FIXME: Make kconfig configurable?
@@ -40,4 +62,4 @@ osw_ut_run_all(bool verbose)
 }
 #endif
 
-#endif /* OSW_UT_H */
+#endif /* OSW_UT_H_INCLUDED */
Index: core/src/lib/osw/inc/osw_util.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/inc/osw_util.h
@@ -0,0 +1,180 @@
+#ifndef OSW_UTIL_H_INCLUDED
+#define OSW_UTIL_H_INCLUDED
+
+#include <math.h>
+
+struct element {
+    uint8_t id;
+    uint8_t datalen;
+    uint8_t data[];
+} __attribute__ ((packed));
+
+/* element iteration helpers */
+#define for_each_ie(_elem, _data, _datalen)                                                                             \
+    for (_elem = (const struct element *) (_data);                                                                  \
+        (const uint8_t *) (_data) + (_datalen) - (const uint8_t *) _elem >= (int) sizeof(*_elem) &&                \
+        (const uint8_t *) (_data) + (_datalen) - (const uint8_t *) _elem >= (int) sizeof(*_elem) + _elem->datalen; \
+        _elem = (const struct element *) (_elem->data + _elem->datalen))
+
+static inline double
+osw_periodic_get_next(const double interval_seconds,
+                      const double offset_seconds,
+                      const double now)
+{
+    if (interval_seconds <= 0) return 0;
+    if (fabs(offset_seconds) >= interval_seconds) return 0;
+    return ((floor(now / interval_seconds) + 1) * interval_seconds) + offset_seconds;
+}
+
+static inline bool
+osw_periodic_is_expired(const double at,
+                        const double now)
+{
+    return at && at <= now;
+}
+
+static inline bool
+osw_periodic_eval(double *at,
+                  const double interval_seconds,
+                  const double offset_seconds,
+                  const double now)
+{
+    const bool expired = osw_periodic_is_expired(*at, now);
+    *at = osw_periodic_get_next(interval_seconds, offset_seconds, now);
+    return expired;
+}
+
+/* Updates the current duration if provided number of
+ * seconds is smaller. This is intended to prepare timer
+ * expiry offset. Values <0 are special. Start by having
+ * *duration < 0 (eg. -1) and update iteratively. If
+ * duration is >=0 then at least one iteration was valid and
+ * >= 0.
+ */
+static inline void
+osw_min_duration(double *duration,
+                 double new_duration)
+{
+    if (new_duration < 0) return;
+    if (*duration < 0) *duration = new_duration;
+    if (*duration > new_duration) *duration = new_duration;
+}
+
+struct osw_assoc_req_info {
+    bool wnm_bss_trans;
+    bool rrm_neighbor_report;
+};
+
+bool
+osw_parse_assoc_req_ies(const void *assoc_req_ies,
+                        size_t assoc_req_ies_len,
+                        struct osw_assoc_req_info *info);
+
+struct osw_circ_buf {
+    size_t size;
+    size_t head;
+    size_t tail;
+};
+
+static inline void
+osw_circ_buf_init(struct osw_circ_buf *circ_buf,
+                  size_t size)
+{
+    assert(circ_buf != NULL);
+    assert(size > 1);
+
+    circ_buf->size = size;
+    circ_buf->head = 0;
+    circ_buf->tail = 0;
+}
+
+static inline bool
+osw_circ_buf_is_empty(const struct osw_circ_buf *circ_buf)
+{
+    assert(circ_buf != NULL);
+    return circ_buf->head == circ_buf->tail;
+}
+
+static inline size_t
+osw_circ_buf_next(const struct osw_circ_buf *circ_buf,
+                  size_t entry)
+{
+    assert(circ_buf != NULL);
+
+    const size_t next = entry + 1;
+    return next < circ_buf->size ? next : 0;
+}
+
+static inline bool
+osw_circ_buf_is_full(const struct osw_circ_buf *circ_buf)
+{
+    assert(circ_buf != NULL);
+    return circ_buf->head == osw_circ_buf_next(circ_buf, circ_buf->tail);
+}
+
+static inline size_t
+osw_circ_buf_head(const struct osw_circ_buf *circ_buf)
+{
+    assert(circ_buf != NULL);
+    return circ_buf->head;
+}
+
+static inline size_t
+osw_circ_buf_tail(const struct osw_circ_buf *circ_buf)
+{
+    assert(circ_buf != NULL);
+    return circ_buf->tail;
+}
+
+static inline bool
+osw_circ_buf_pop(struct osw_circ_buf *circ_buf,
+                 size_t *i)
+{
+    assert(circ_buf != NULL);
+    assert(i != NULL);
+    
+    if (osw_circ_buf_is_empty(circ_buf) == true)
+        return false;
+
+    *i = circ_buf->head;
+    circ_buf->head = osw_circ_buf_next(circ_buf, circ_buf->head);
+    
+    return true;
+}
+
+static inline bool
+osw_circ_buf_push(struct osw_circ_buf *circ_buf,
+                  size_t *i)
+{
+    assert(circ_buf != NULL);
+    assert(i != NULL);
+
+    if (osw_circ_buf_is_full(circ_buf) == true)
+        return false;
+
+    *i = circ_buf->tail;
+    circ_buf->tail = osw_circ_buf_next(circ_buf, circ_buf->tail);
+
+    return true;
+}
+
+static inline size_t
+osw_circ_buf_push_rotate(struct osw_circ_buf *circ_buf)
+{
+    assert(circ_buf != NULL);
+
+    size_t entry = circ_buf->tail;
+
+    circ_buf->tail = osw_circ_buf_next(circ_buf, circ_buf->tail);
+    if (circ_buf->head == circ_buf->tail)
+        circ_buf->head = osw_circ_buf_next(circ_buf, circ_buf->head);
+
+    return entry;
+}
+
+#define OSW_CIRC_BUF_FOREACH(circ_buf, i)       \
+    for(i = osw_circ_buf_head(circ_buf);        \
+        i != osw_circ_buf_tail(circ_buf);       \
+        i = osw_circ_buf_next(circ_buf, i))
+
+#endif /* OSW_UTIL_H_INCLUDED */
Index: core/src/lib/osw/src/osw.c
===================================================================
--- core.orig/src/lib/osw/src/osw.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "osw_drv_i.h"
-
-void
-osw_init(void)
-{
-    osw_drv_init();
-}
Index: core/src/lib/osw/src/osw_bss_map.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_bss_map.c
@@ -0,0 +1,473 @@
+#define _GNU_SOURCE
+#include <assert.h>
+#include <ev.h>
+#include <const.h>
+#include <log.h>
+#include <string.h>
+#include <util.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_ut.h>
+#include <osw_bss_map.h>
+#include <osw_module.h>
+
+struct osw_bss {
+    struct osw_hwaddr bssid;
+    struct ds_dlist entry_list;
+    ev_timer work_timer;
+
+    struct ds_tree_node node;
+};
+
+struct osw_bss_entry {
+    struct osw_bss *bss;
+
+    struct osw_ssid *ssid;
+    struct osw_channel *channel;
+
+    struct ds_tree_node bss_node;
+    struct ds_dlist_node provider_node;
+};
+
+struct osw_bss_map {
+    struct ds_tree bss_tree;
+    struct ds_dlist provider_list;
+    ev_timer gc_timer;
+    ev_signal sigusr1;
+};
+
+struct osw_bss_provider {
+    struct ds_dlist entry_list;
+
+    struct ds_dlist_node node;
+};
+
+static struct osw_bss_map g_bss_map;
+static struct ds_dlist g_observer_list = DS_DLIST_INIT(struct osw_bss_map_observer, node);
+
+static bool
+osw_bss_provider_has_entry(struct osw_bss_provider *provider,
+                               struct osw_bss_entry* entry)
+{
+    struct osw_bss_entry* element;
+
+    ds_dlist_foreach(&provider->entry_list, element)
+        if(entry == element)
+            return true;
+
+    return false;
+}
+
+static bool
+osw_bss_has_entry(struct osw_bss *bss,
+                  struct osw_bss_entry* entry)
+{
+    struct osw_bss_entry* element;
+
+    ds_dlist_foreach(&bss->entry_list, element)
+        if(entry == element)
+            return true;
+
+    return false;
+}
+
+static void
+ow_bss_work_timer_cb(EV_P_ ev_timer *arg,
+                     int events)
+{
+    struct osw_bss *bss = container_of(arg, struct osw_bss, work_timer);
+    struct osw_bss_map_observer *obs;
+
+    ds_dlist_foreach(&g_observer_list, obs)
+        if (obs->set_fn != NULL)
+            obs->set_fn(obs, &bss->bssid, ds_dlist_tail(&g_observer_list));
+}
+
+static struct osw_bss*
+osw_bss_alloc(const struct osw_hwaddr *bssid)
+{
+    struct osw_bss *bss = CALLOC(1, sizeof(*bss));
+
+    memcpy(&bss->bssid, bssid, sizeof(bss->bssid));
+    ds_dlist_init(&bss->entry_list, struct osw_bss_entry, bss_node);
+    ev_timer_init(&bss->work_timer, ow_bss_work_timer_cb, 0., 0.);
+
+    return bss;
+}
+
+static void
+osw_bss_free(struct osw_bss *bss)
+{
+    ASSERT(bss != NULL, "");
+
+    ASSERT(ds_dlist_is_empty(&bss->entry_list) == true, "");
+    FREE(bss);
+}
+
+static void
+osw_bss_entry_free(struct osw_bss_entry *entry)
+{
+    ASSERT(entry != NULL, "");
+
+    FREE(entry->ssid);
+    FREE(entry->channel);
+
+    FREE(entry);
+}
+
+static struct osw_bss_provider*
+osw_bss_provider_alloc(void)
+{
+    struct osw_bss_provider *provider = CALLOC(1, sizeof(*provider));
+    ds_dlist_init(&provider->entry_list, struct osw_bss_entry, provider_node);
+    return provider;
+}
+
+static void
+osw_bss_schedule_work(ev_timer *timer)
+{
+    ASSERT(timer != NULL, "");
+
+    ev_timer_stop(EV_DEFAULT_ timer);
+    ev_timer_set(timer, 0., 0.);
+    ev_timer_start(EV_DEFAULT_ timer);
+}
+
+static void
+osw_bss_provider_free(struct osw_bss_provider *provider)
+{
+    ASSERT(provider != NULL, "");
+
+    struct osw_bss_entry* entry;
+    struct osw_bss_entry* tmp_entry;
+
+    ds_dlist_foreach_safe(&provider->entry_list, entry, tmp_entry) {
+        ASSERT(entry->bss != NULL, "");
+        ds_dlist_remove(&entry->bss->entry_list, entry);
+        if (ds_dlist_is_empty(&entry->bss->entry_list) == true)
+            osw_bss_schedule_work(&g_bss_map.gc_timer);
+
+        ds_dlist_remove(&provider->entry_list, entry);
+        osw_bss_entry_free(entry);
+    }
+}
+
+static void
+ow_bss_map_gc_timer_cb(EV_P_ ev_timer *arg,
+                       int events)
+{
+    struct osw_bss *bss;
+    struct osw_bss *tmp_bss;
+
+    ds_tree_foreach_safe(&g_bss_map.bss_tree, bss, tmp_bss) {
+        struct osw_bss_map_observer *obs;
+
+        if (ds_dlist_is_empty(&bss->entry_list) == false)
+            continue;
+
+        ds_tree_remove(&g_bss_map.bss_tree, bss);
+
+        ds_dlist_foreach(&g_observer_list, obs)
+            if (obs->unset_fn != NULL)
+                obs->unset_fn(obs, &bss->bssid);
+
+        osw_bss_free(bss);
+    }
+}
+
+static void
+osw_bss_map_dump(const struct osw_bss_map *bss_map)
+{
+    assert(bss_map != NULL);
+
+    struct osw_bss *bss;
+
+    LOGI("osw: bss_map: ");
+    LOGI("osw: bss_map: bss_tree:");
+
+    ds_tree_foreach(&g_bss_map.bss_tree, bss) {
+        struct osw_bss_entry *entry;
+        LOGI("osw: bss_map:   bss: bssid: "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&bss->bssid));
+        ds_dlist_foreach(&bss->entry_list, entry) {
+            const char *ssid = entry->ssid ? strfmta(OSW_SSID_FMT, OSW_SSID_ARG(entry->ssid)) : "nil";
+            const char *channel = entry->channel ? strfmta(OSW_CHANNEL_FMT, OSW_CHANNEL_ARG(entry->channel)) : "nil";
+            LOGI("osw: bss_map:     ssid: %s: channel: %s", ssid, channel);
+        }
+    }
+}
+
+static void
+osw_bss_map_sigusr1_cb(EV_P_ ev_signal *arg,
+                      int events)
+{
+    struct osw_bss_map *bss_map = container_of(arg, struct osw_bss_map, sigusr1);
+    osw_bss_map_dump(bss_map);
+}
+
+static void
+osw_bss_map_init(void)
+{
+    ds_tree_init(&g_bss_map.bss_tree, (ds_key_cmp_t*) osw_hwaddr_cmp, struct osw_bss, node);
+    ds_dlist_init(&g_bss_map.provider_list, struct osw_bss_provider, node);
+    ev_timer_init(&g_bss_map.gc_timer, ow_bss_map_gc_timer_cb, 0., 0.);
+
+    ev_signal_init(&g_bss_map.sigusr1, osw_bss_map_sigusr1_cb, SIGUSR1);
+    ev_signal_start(EV_DEFAULT_ &g_bss_map.sigusr1);
+    ev_unref(EV_DEFAULT);
+}
+
+struct osw_bss_provider*
+osw_bss_map_register_provider(void)
+{
+    struct osw_bss_provider *provider = osw_bss_provider_alloc();
+    ds_dlist_insert_tail(&g_bss_map.provider_list, provider);
+    return provider;
+}
+
+void
+osw_bss_map_unregister_provider(struct osw_bss_provider *provider)
+{
+    ASSERT(provider != NULL, "");
+    osw_bss_provider_free(provider);
+}
+
+void
+osw_bss_map_register_observer(struct osw_bss_map_observer *observer)
+{
+    ASSERT(observer != NULL, "");
+
+    struct osw_bss *bss;
+
+    ds_dlist_insert_tail(&g_observer_list, observer);
+
+    if (observer->set_fn == NULL)
+        return;
+
+    ds_tree_foreach(&g_bss_map.bss_tree, bss)
+        observer->set_fn(observer, &bss->bssid, ds_dlist_tail(&bss->entry_list));
+}
+
+void
+osw_bss_map_unregister_observer(struct osw_bss_map_observer *observer)
+{
+    ASSERT(observer != NULL, "");
+    ds_dlist_remove(&g_observer_list, observer);
+}
+
+struct osw_bss_entry*
+osw_bss_map_entry_new(struct osw_bss_provider *provider,
+                      const struct osw_hwaddr *bssid)
+{
+    ASSERT(provider != NULL, "");
+    ASSERT(bssid != NULL, "");
+
+    struct osw_bss *bss;
+    struct osw_bss_entry *entry;
+
+    if((bss = ds_tree_find(&g_bss_map.bss_tree, bssid)) == NULL) {
+        bss = osw_bss_alloc(bssid);
+        ds_tree_insert(&g_bss_map.bss_tree, bss, &bss->bssid);
+    }
+
+    entry = CALLOC(1, sizeof(*entry));
+    entry->bss = bss;
+    ds_dlist_insert_tail(&bss->entry_list, entry);
+    ds_dlist_insert_tail(&provider->entry_list, entry);
+
+    osw_bss_schedule_work(&entry->bss->work_timer);
+
+    return entry;
+}
+
+void
+osw_bss_map_entry_free(struct osw_bss_provider *provider,
+                       struct osw_bss_entry* entry)
+{
+    ASSERT(provider != NULL, "");
+    ASSERT(entry != NULL, "");
+
+    ASSERT(entry->bss != NULL, "");
+    ASSERT(osw_bss_provider_has_entry(provider, entry) == true, "");
+    ASSERT(osw_bss_has_entry(entry->bss, entry) == true, "");
+
+    ds_dlist_remove(&entry->bss->entry_list, entry);
+    if (ds_dlist_is_empty(&entry->bss->entry_list) == true)
+        osw_bss_schedule_work(&g_bss_map.gc_timer);
+    else
+        osw_bss_schedule_work(&entry->bss->work_timer);
+
+    ds_dlist_remove(&provider->entry_list, entry);
+    osw_bss_entry_free(entry);
+}
+
+#define OSW_BSS_ENTRY_SET_DEFINITION(attr_type, attr)                       \
+    void                                                                    \
+    osw_bss_entry_set_ ## attr(struct osw_bss_entry* entry,                 \
+                               const attr_type *attr)                       \
+    {                                                                       \
+        ASSERT(entry != NULL, "");                                          \
+        ASSERT(entry->bss != NULL, "");                                     \
+        ASSERT(osw_bss_has_entry(entry->bss, entry) == true, "");           \
+                                                                            \
+        if (entry->attr != NULL && attr != NULL) {                          \
+            if (memcmp(entry->attr, attr, sizeof(*attr)) == 0)              \
+                return;                                                     \
+        }                                                                   \
+                                                                            \
+        ds_dlist_remove(&entry->bss->entry_list, entry);                    \
+        ds_dlist_insert_tail(&entry->bss->entry_list, entry);               \
+                                                                            \
+        FREE(entry->attr);                                                  \
+        entry->attr = NULL;                                                 \
+                                                                            \
+        if (attr != NULL) {                                                 \
+            entry->attr = CALLOC(1, sizeof(*attr));                         \
+            memcpy(entry->attr, attr, sizeof(*attr));                       \
+        }                                                                   \
+                                                                            \
+        osw_bss_schedule_work(&entry->bss->work_timer);                     \
+    }
+
+#define OSW_BSS_GET_DEFINITION(attr_type, attr)                             \
+    const attr_type*                                                        \
+    osw_bss_get_ ## attr(const struct osw_hwaddr* bssid)                    \
+    {                                                                       \
+        ASSERT(bssid != NULL, "");                                          \
+                                                                            \
+        struct osw_bss *bss;                                                \
+        struct osw_bss_entry* entry;                                        \
+                                                                            \
+        bss = ds_tree_find(&g_bss_map.bss_tree, bssid);                     \
+        if(bss == NULL)                                                     \
+            return NULL;                                                    \
+                                                                            \
+        entry = ds_dlist_tail(&bss->entry_list);                            \
+        if(entry == NULL)                                                   \
+            return NULL;                                                    \
+                                                                            \
+        return entry->attr;                                                 \
+    }
+
+OSW_BSS_ENTRY_SET_DEFINITION(struct osw_ssid, ssid);
+OSW_BSS_ENTRY_SET_DEFINITION(struct osw_channel, channel);
+
+OSW_BSS_GET_DEFINITION(struct osw_ssid, ssid);
+OSW_BSS_GET_DEFINITION(struct osw_channel, channel);
+
+struct osw_bss_map_ut_lifecycle_observer {
+    struct osw_bss_map_observer obs;
+    struct osw_hwaddr bssid_a;
+    unsigned int set_cnt_a;
+    unsigned int unset_cnt_a;
+};
+
+static void
+osw_bss_map_ut_lifecycle_set_cb(struct osw_bss_map_observer *observer,
+                                const struct osw_hwaddr *bssid,
+                                const struct osw_bss_entry *bss_entry)
+{
+    struct osw_bss_map_ut_lifecycle_observer *ctx = container_of(observer, struct osw_bss_map_ut_lifecycle_observer, obs);
+
+    if(memcmp(bssid, &ctx->bssid_a, sizeof(*bssid)) == 0)
+        ctx->set_cnt_a++;
+}
+
+static void
+osw_bss_map_ut_lifecycle_unset_cb(struct osw_bss_map_observer *observer,
+                                  const struct osw_hwaddr *bssid)
+{
+    struct osw_bss_map_ut_lifecycle_observer *ctx = container_of(observer, struct osw_bss_map_ut_lifecycle_observer, obs);
+
+    if(memcmp(bssid, &ctx->bssid_a, sizeof(*bssid)) == 0)
+        ctx->unset_cnt_a++;
+}
+
+OSW_UT(osw_bss_map_ut_lifecycle)
+{
+    struct osw_bss_entry *entry_aa;
+    struct osw_bss_entry *entry_ab;
+    struct osw_bss_provider *provider_a;
+    struct osw_bss_provider *provider_b;
+    struct osw_bss_map_ut_lifecycle_observer ctx = {
+        .obs = {
+            .name = "osw_bss_map_ut_lifecycle",
+            .set_fn = osw_bss_map_ut_lifecycle_set_cb,
+            .unset_fn = osw_bss_map_ut_lifecycle_unset_cb,
+        },
+        .bssid_a.octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA },
+        .set_cnt_a = 0,
+        .unset_cnt_a = 0,
+    };
+    struct osw_ssid ssid_aa = {
+        .buf = "Aaaaa",
+        .len = 5,
+    };
+    struct osw_ssid ssid_ab = {
+        .buf = "AaBBBB",
+        .len = 6,
+    };
+    struct osw_channel channel_a = {
+        .width = OSW_CHANNEL_20MHZ,
+        .control_freq_mhz = 2412,
+        .center_freq0_mhz = 2412,
+        .center_freq1_mhz = 0,
+    };
+
+    osw_bss_map_init();
+    osw_bss_map_register_observer(&ctx.obs);
+
+    /* Register two providers */
+    provider_a = osw_bss_map_register_provider();
+    assert(provider_a != NULL);
+    provider_b = osw_bss_map_register_provider();
+    assert(provider_b != NULL);
+
+    /* Simple - add new BSS */
+    entry_aa = osw_bss_map_entry_new(provider_a, &ctx.bssid_a);
+    assert(entry_aa != NULL);
+
+    /* Set two BSS attributes in two ev loop iterations */
+    osw_bss_entry_set_ssid(entry_aa, &ssid_aa);
+    ev_run(EV_DEFAULT_ 0);
+    assert(ctx.set_cnt_a == 1);
+    assert(memcmp(osw_bss_get_ssid(&ctx.bssid_a), &ssid_aa, sizeof(ssid_aa)) == 0);
+
+    osw_bss_entry_set_channel(entry_aa, &channel_a);
+    ev_run(EV_DEFAULT_ 0);
+    assert(ctx.set_cnt_a == 2);
+    assert(memcmp(osw_bss_get_channel(&ctx.bssid_a), &channel_a, sizeof(channel_a)) == 0);
+
+    /* Register the same BSS with different provider */
+    entry_ab = osw_bss_map_entry_new(provider_b, &ctx.bssid_a);
+    assert(entry_ab != NULL);
+
+    /* Override BSS attribute */
+    osw_bss_entry_set_ssid(entry_ab, &ssid_ab);
+    ev_run(EV_DEFAULT_ 0);
+    assert(ctx.set_cnt_a == 3);
+    assert(memcmp(osw_bss_get_ssid(&ctx.bssid_a), &ssid_ab, sizeof(ssid_ab)) == 0);
+    assert(osw_bss_get_channel(&ctx.bssid_a) == NULL);
+
+    /* Remove BSS */
+    osw_bss_map_entry_free(provider_b, entry_ab);
+    ev_run(EV_DEFAULT_ 0);
+    assert(ctx.set_cnt_a == 4);
+    assert(ctx.unset_cnt_a == 0);
+    assert(memcmp(osw_bss_get_ssid(&ctx.bssid_a), &ssid_aa, sizeof(ssid_aa)) == 0);
+    assert(memcmp(osw_bss_get_channel(&ctx.bssid_a), &channel_a, sizeof(channel_a)) == 0);
+
+    osw_bss_map_entry_free(provider_a, entry_aa);
+    ev_run(EV_DEFAULT_ 0);
+    assert(ctx.set_cnt_a == 4);
+    assert(ctx.unset_cnt_a == 1);
+    assert(osw_bss_get_ssid(&ctx.bssid_a) == NULL);
+    assert(osw_bss_get_channel(&ctx.bssid_a) == NULL);
+}
+
+OSW_MODULE(osw_bss_map)
+{
+    osw_bss_map_init();
+    return NULL;
+}
Index: core/src/lib/osw/src/osw_btm.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_btm.c
@@ -0,0 +1,481 @@
+#include <endian.h>
+#include <ev.h>
+#include <log.h>
+#include <const.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_timer.h>
+#include <osw_time.h>
+#include <osw_drv_common.h>
+#include <osw_drv_mediator.h>
+#include <osw_drv.h>
+#include <osw_mux.h>
+#include <osw_throttle.h>
+#include <osw_state.h>
+#include <osw_btm.h>
+#include <osw_state.h>
+
+enum osw_btm_desc_state {
+    OSW_BTM_DESC_STATE_EMPTY = 0,
+    OSW_BTM_DESC_STATE_PENDING,
+    OSW_BTM_DESC_STATE_IN_TRANSIT,
+};
+
+struct osw_btm_desc {
+    struct osw_btm_sta *sta;
+    struct osw_btm_sta_observer *observer;
+    enum osw_btm_desc_state state;
+    uint8_t frame_buf [OSW_DRV_FRAME_TX_DESC_BUF_SIZE];
+    ssize_t frame_len;
+    uint8_t dialog_token;
+
+    struct ds_dlist_node node;
+};
+
+typedef bool
+osw_btm_mux_frame_tx_schedule_fn_t(const char *phy_name,
+                                   const char *vif_name,
+                                   struct osw_drv_frame_tx_desc *desc);
+
+struct osw_btm_sta {
+    struct osw_hwaddr mac_addr;
+    struct osw_throttle *throttle;
+    struct osw_timer throttle_timer;
+    struct osw_timer work_timer;
+    struct osw_drv_frame_tx_desc *frame_tx_desc;
+    struct osw_state_observer state_observer;
+    const struct osw_state_sta_info *sta_info;
+    struct ds_dlist desc_list;
+    uint8_t dialog_token_generator;
+
+    osw_btm_mux_frame_tx_schedule_fn_t *mux_frame_tx_schedule_fn;
+
+    struct ds_tree_node node;
+};
+
+static struct ds_tree g_sta_tree = DS_TREE_INIT((ds_key_cmp_t*) osw_hwaddr_cmp, struct osw_btm_sta, node);
+
+static uint8_t
+osw_btm_desc_generate_dialog_token(struct osw_btm_sta *btm_sta)
+{
+    ASSERT(btm_sta != NULL, "");
+    return btm_sta->dialog_token_generator++;
+}
+
+static void
+osw_btm_desc_reset(struct osw_btm_desc *desc)
+{
+    ASSERT(desc != NULL, "");
+
+    desc->state = OSW_BTM_DESC_STATE_EMPTY;
+    memset(&desc->frame_buf, 0, sizeof(desc->frame_buf));
+    desc->frame_len = 0;
+    desc->dialog_token = 0;
+}
+
+static ssize_t
+osw_btm_build_frame(const struct osw_btm_req_params *req_params,
+                    const struct osw_hwaddr *sta_addr,
+                    const struct osw_hwaddr *bssid,
+                    uint8_t dialog_token,
+                    uint8_t *frame_buf,
+                    size_t frame_buf_size)
+{
+    ASSERT(req_params != NULL, "");
+    ASSERT(bssid != NULL, "");
+    ASSERT(frame_buf != NULL, "");
+    ASSERT(frame_buf_size > 0, "");
+
+    static const uint8_t dot11_pref_list_incl = 0x01;
+    static const uint8_t dot11_abridged = 0x02;
+    static const uint8_t dot11_disassoc_imminent = 0x04;
+    static const uint8_t dot11_bss_term_incl = 0x08;
+    static const uint16_t dot11_frame_control = 0xd0;
+    static const uint8_t dot11_category = 0x0A;
+    static const uint8_t dot11_action_code = 0x07;
+    static const uint8_t dot11_neigh_report_tag = 0x34;
+
+    static const uint16_t duration = 60;
+    static const uint16_t diassoc_timer = 0x0000;
+    static const uint8_t neigh_report_tag_len = 13;
+
+    struct osw_drv_dot11_frame *frame = (struct osw_drv_dot11_frame*) frame_buf;
+    size_t frame_len = 0;
+    uint8_t options = 0;
+    uint8_t *neigh_list = NULL;
+    size_t i = 0;
+
+    /* compute frame length first */
+    frame_len += offsetof(struct osw_drv_dot11_frame, u.action.u.bss_tm_req);
+    frame_len += C_FIELD_SZ(struct osw_drv_dot11_frame, u.action.u.bss_tm_req);
+    frame_len += req_params->neigh_len * sizeof(struct osw_drv_dot11_neighbor_report);
+
+    if (frame_len > frame_buf_size) {
+        LOGW("osw: btm: [sta: "OSW_HWADDR_FMT"] failed to build frame, to small buffer (len: %zu size: %zu)",
+             OSW_HWADDR_ARG(sta_addr), frame_len, frame_buf_size);
+        return -1;
+    }
+
+    /* Build frame */
+    frame->header.frame_control = htole16(dot11_frame_control);
+    frame->header.duration = htole16(duration);
+    memcpy(&frame->header.da, &sta_addr->octet, sizeof(frame->header.da));
+    memcpy(&frame->header.sa, &bssid->octet, sizeof(frame->header.sa));
+    memcpy(&frame->header.bssid, &bssid->octet, sizeof(frame->header.bssid));
+    frame->header.seq_ctrl = 0;
+
+    options |= req_params->neigh_len > 0 ? dot11_pref_list_incl : 0;
+    options |= req_params->abridged == true ? dot11_abridged : 0;
+    options |= req_params->disassoc_imminent == true ? dot11_disassoc_imminent : 0;
+    options |= req_params->bss_term == true ? dot11_bss_term_incl : 0;
+
+    frame->u.action.category = dot11_category;
+    frame->u.action.u.bss_tm_req.action = dot11_action_code;
+    frame->u.action.u.bss_tm_req.dialog_token = dialog_token;
+    frame->u.action.u.bss_tm_req.options = options;
+    frame->u.action.u.bss_tm_req.disassoc_timer = htole16(diassoc_timer);
+    frame->u.action.u.bss_tm_req.validity_interval = req_params->valid_int;
+
+    neigh_list = frame->u.action.u.bss_tm_req.variable;
+    for (i = 0; i < req_params->neigh_len; i ++) {
+        const struct osw_btm_req_neigh *neigh = &req_params->neigh[i];
+        struct osw_drv_dot11_neighbor_report *entry = (struct osw_drv_dot11_neighbor_report*) neigh_list;
+
+        entry->tag = dot11_neigh_report_tag;
+        entry->tag_len = neigh_report_tag_len;
+        memcpy(&entry->bssid, &neigh->bssid, sizeof(entry->bssid));
+        entry->bssid_info = htole32(neigh->bssid_info);
+        entry->op_class = neigh->op_class;
+        entry->channel = neigh->channel;
+        entry->phy_type = neigh->phy_type;
+
+        neigh_list += sizeof(*entry);
+    }
+
+    return frame_len;
+}
+
+static void
+osw_btm_sta_schedule_work(struct osw_btm_sta *btm_sta)
+{
+    ASSERT(btm_sta != NULL, "");
+    osw_timer_arm_at_nsec(&btm_sta->work_timer, osw_time_mono_clk());
+}
+
+static void
+osw_btm_sta_try_req_tx(struct osw_btm_sta *btm_sta)
+{
+    ASSERT(btm_sta != NULL, "");
+
+    const struct osw_state_vif_info *vif_info = btm_sta->sta_info->vif;
+    const struct osw_drv_dot11_frame *frame = NULL;
+    struct osw_btm_desc *desc;
+
+    if (btm_sta->sta_info == NULL) {
+        LOGT("osw: btm: [sta: "OSW_HWADDR_FMT"] cannot tx req to disconnected sta",
+             OSW_HWADDR_ARG(&btm_sta->mac_addr));
+        goto cease_tx_attempt;
+    }
+
+    if (ds_dlist_is_empty(&btm_sta->desc_list) == true) {
+        goto cease_tx_attempt;
+    }
+
+    desc = ds_dlist_head(&btm_sta->desc_list);
+    frame = (const struct osw_drv_dot11_frame*) &desc->frame_buf;
+    switch (desc->state) {
+        case OSW_BTM_DESC_STATE_PENDING:
+            /* just continue */
+            break;
+        case OSW_BTM_DESC_STATE_IN_TRANSIT:
+            LOGT("osw: btm: [sta: "OSW_HWADDR_FMT" dialog_token: %u] req already in transit",
+                 OSW_HWADDR_ARG(&btm_sta->mac_addr), frame->u.action.u.bss_tm_req.dialog_token);
+            goto cease_tx_attempt;
+        case OSW_BTM_DESC_STATE_EMPTY:
+            LOGT("osw: btm: [sta: "OSW_HWADDR_FMT" dialog_token: %u] cannot tx empty req",
+                 OSW_HWADDR_ARG(&btm_sta->mac_addr), frame->u.action.u.bss_tm_req.dialog_token);
+            goto cease_tx_attempt;
+    }
+
+    if (btm_sta->throttle != NULL) {
+        uint64_t next_at_nsec;
+        bool result;
+
+        result = osw_throttle_tap(btm_sta->throttle, &next_at_nsec);
+        if (result == false) {
+            osw_timer_arm_at_nsec(&btm_sta->throttle_timer, next_at_nsec);
+            LOGT("osw: btm: [sta: "OSW_HWADDR_FMT"] cease req tx attempt due to throttle condition",
+                 OSW_HWADDR_ARG(&btm_sta->mac_addr));
+            goto cease_tx_attempt;
+        }
+    }
+
+    desc->state = OSW_BTM_DESC_STATE_IN_TRANSIT;
+
+    osw_drv_frame_tx_desc_set_frame(btm_sta->frame_tx_desc, desc->frame_buf, desc->frame_len);
+    ASSERT(btm_sta->mux_frame_tx_schedule_fn != NULL, "");
+    btm_sta->mux_frame_tx_schedule_fn(vif_info->phy->phy_name, vif_info->vif_name, btm_sta->frame_tx_desc);
+
+    LOGD("osw: btm: [sta: "OSW_HWADDR_FMT" dialog_token: %u] req was passed to drv",
+         OSW_HWADDR_ARG(&btm_sta->mac_addr), frame->u.action.u.bss_tm_req.dialog_token);
+
+    return;
+
+    cease_tx_attempt:
+        LOGD("osw: btm: [sta: "OSW_HWADDR_FMT"] req tx attempt was cease", OSW_HWADDR_ARG(&btm_sta->mac_addr));
+}
+
+static void
+osw_btm_sta_throttle_timer_cb(struct osw_timer *timer)
+{
+    struct osw_btm_sta *sta = (struct osw_btm_sta*) container_of(timer, struct osw_btm_sta, throttle_timer);
+    osw_btm_sta_schedule_work(sta);
+}
+
+static void
+osw_btm_sta_work_timer_cb(struct osw_timer *timer)
+{
+    struct osw_btm_sta *sta = (struct osw_btm_sta*) container_of(timer, struct osw_btm_sta, work_timer);
+    osw_btm_sta_try_req_tx(sta);
+}
+
+static void
+osw_btm_sta_connected_cb(struct osw_state_observer *self,
+                         const struct osw_state_sta_info *sta)
+{
+    struct osw_btm_sta *btm_sta = ds_tree_find(&g_sta_tree, sta->mac_addr);
+
+    if (btm_sta == NULL)
+        return;
+
+    btm_sta->sta_info = sta;
+    osw_btm_sta_schedule_work(btm_sta);
+}
+
+static void
+osw_btm_sta_disconnected_cb(struct osw_state_observer *self,
+                            const struct osw_state_sta_info *sta)
+{
+    struct osw_btm_sta *btm_sta = ds_tree_find(&g_sta_tree, sta->mac_addr);
+
+    if (btm_sta == NULL)
+        return;
+
+    btm_sta->sta_info = NULL;
+    if (btm_sta->throttle != NULL) {
+        osw_throttle_reset(btm_sta->throttle);
+        osw_timer_disarm(&btm_sta->throttle_timer);
+    }
+
+    osw_drv_frame_tx_desc_cancel(btm_sta->frame_tx_desc);
+}
+
+static void
+osw_btm_drv_frame_tx_result_cb(const struct osw_drv_frame_tx_desc *tx_desc,
+                               enum osw_frame_tx_result result,
+                               void *caller_priv)
+{
+    const struct osw_drv_dot11_frame *drv_frame = NULL;
+    const struct osw_drv_dot11_frame *btm_frame = NULL;
+    struct osw_btm_sta *sta = (struct osw_btm_sta *) caller_priv;
+    struct osw_btm_desc *btm_desc = ds_dlist_head(&sta->desc_list);
+
+    if (WARN_ON(btm_desc == NULL)) {
+        goto ignore_tx_report;
+    }
+
+    if (btm_desc->state != OSW_BTM_DESC_STATE_IN_TRANSIT)
+        goto ignore_tx_report;
+
+    drv_frame = (const struct osw_drv_dot11_frame*) osw_drv_frame_tx_desc_get_frame(tx_desc);
+    btm_frame = (const struct osw_drv_dot11_frame*) &btm_desc->frame_buf;
+    if (WARN_ON(drv_frame == NULL || btm_frame == NULL))
+        goto ignore_tx_report;
+
+    if (WARN_ON(drv_frame->u.action.u.bss_tm_req.dialog_token != btm_frame->u.action.u.bss_tm_req.dialog_token))
+        goto ignore_tx_report;
+
+    LOGD("osw: btm: [sta: "OSW_HWADDR_FMT" dialog token: %u] drv reported req tx result: %s",
+         OSW_HWADDR_ARG(&sta->mac_addr), btm_frame->u.action.u.bss_tm_req.dialog_token,
+         osw_frame_tx_result_to_cstr(result));
+
+    switch (result) {
+        case OSW_FRAME_TX_RESULT_SUBMITTED:
+            if (btm_desc->observer->req_tx_complete_fn != NULL)
+                btm_desc->observer->req_tx_complete_fn(btm_desc->observer);
+            break;
+        case OSW_FRAME_TX_RESULT_FAILED:
+        case OSW_FRAME_TX_RESULT_DROPPED:
+            if (btm_desc->observer->req_tx_error_fn != NULL)
+                btm_desc->observer->req_tx_error_fn(btm_desc->observer);
+            break;
+    }
+
+    osw_btm_desc_reset(btm_desc);
+    return;
+
+    ignore_tx_report:
+        LOGD("osw: btm: [sta: "OSW_HWADDR_FMT"] ignored drv req tx report result: %s",
+             OSW_HWADDR_ARG(&sta->mac_addr), osw_frame_tx_result_to_cstr(result));
+}
+
+static struct osw_btm_sta*
+osw_btm_get_sta(const struct osw_hwaddr *sta_addr,
+                osw_btm_mux_frame_tx_schedule_fn_t *mux_frame_tx_schedule_fn)
+{
+    ASSERT(sta_addr != NULL, "");
+
+    struct osw_btm_sta *sta = ds_tree_find(&g_sta_tree, sta_addr);
+
+    if (sta != NULL)
+        return sta;
+
+    sta = CALLOC(1, sizeof(*sta));
+    memcpy(&sta->mac_addr, sta_addr, sizeof(sta->mac_addr));
+    osw_timer_init(&sta->throttle_timer, osw_btm_sta_throttle_timer_cb);
+    osw_timer_init(&sta->work_timer, osw_btm_sta_work_timer_cb);
+    sta->frame_tx_desc = osw_drv_frame_tx_desc_new(osw_btm_drv_frame_tx_result_cb, sta);
+    sta->sta_info = osw_state_sta_lookup_newest(&sta->mac_addr);
+    ds_dlist_init(&sta->desc_list, struct osw_btm_desc, node);
+    sta->mux_frame_tx_schedule_fn = mux_frame_tx_schedule_fn;
+
+    ds_tree_insert(&g_sta_tree, sta, &sta->mac_addr);
+
+    return sta;
+}
+
+static void
+osw_btm_sta_free(struct osw_btm_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    osw_throttle_free(sta->throttle);
+    osw_timer_disarm(&sta->throttle_timer);
+    osw_timer_disarm(&sta->work_timer);
+    osw_drv_frame_tx_desc_free(sta->frame_tx_desc);
+
+    ds_tree_remove(&g_sta_tree, sta);
+    FREE(sta);
+}
+
+struct osw_btm_desc*
+osw_btm_get_desc_internal(const struct osw_hwaddr *sta_addr,
+                          struct osw_btm_sta_observer *observer,
+                          osw_btm_mux_frame_tx_schedule_fn_t *mux_frame_tx_schedule_fn)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(observer != NULL, "");
+    ASSERT(mux_frame_tx_schedule_fn != NULL, "");
+
+    struct osw_btm_sta *sta = osw_btm_get_sta(sta_addr, mux_frame_tx_schedule_fn);
+    struct osw_btm_desc *desc = CALLOC(1, sizeof(*desc));
+
+    desc->sta = sta;
+    desc->observer = observer;
+
+    ds_dlist_insert_tail(&sta->desc_list, desc);
+
+    return desc;
+}
+
+void
+osw_btm_init(void)
+{
+    static struct osw_state_observer observer = {
+        .name = "osw_btm",
+        .sta_connected_fn = osw_btm_sta_connected_cb,
+        .sta_disconnected_fn = osw_btm_sta_disconnected_cb,
+    };
+
+    osw_state_register_observer(&observer);
+}
+
+struct osw_btm_desc*
+osw_btm_get_desc(const struct osw_hwaddr *sta_addr,
+                 struct osw_btm_sta_observer *observer)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(observer != NULL, "");
+    return osw_btm_get_desc_internal(sta_addr, observer, osw_mux_frame_tx_schedule);
+}
+
+void
+osw_btm_desc_free(struct osw_btm_desc *desc)
+{
+    ASSERT(desc != NULL, "");
+
+    struct osw_btm_sta *btm_sta = desc->sta;
+
+    ds_dlist_remove(&btm_sta->desc_list, desc);
+    FREE(desc);
+
+    if (ds_dlist_is_empty(&btm_sta->desc_list) == true)
+        osw_btm_sta_free(btm_sta);
+}
+
+bool
+osw_btm_desc_set_req_params(struct osw_btm_desc *desc,
+                            const struct osw_btm_req_params *params)
+{
+    ASSERT(desc != NULL, "");
+
+    struct osw_btm_sta *btm_sta = desc->sta;
+    const struct osw_state_vif_info *vif_info = NULL;
+
+    if (btm_sta->sta_info == NULL) {
+        osw_btm_desc_reset(desc);
+        return false;
+    }
+
+    vif_info = btm_sta->sta_info->vif;
+
+    ds_dlist_remove(&btm_sta->desc_list, desc);
+    ds_dlist_insert_tail(&btm_sta->desc_list, desc);
+
+    if (params == NULL) {
+        osw_btm_desc_reset(desc);
+        return true;
+    }
+
+    desc->dialog_token = osw_btm_desc_generate_dialog_token(btm_sta);
+    desc->frame_len = osw_btm_build_frame(params,
+                                          &btm_sta->mac_addr,
+                                          &vif_info->drv_state->mac_addr,
+                                          desc->dialog_token,
+                                          desc->frame_buf,
+                                          sizeof(desc->frame_buf));
+    if (desc->frame_len < 0) {
+        osw_btm_desc_reset(desc);
+        return false;
+    }
+
+    desc->state = OSW_BTM_DESC_STATE_PENDING;
+    osw_btm_sta_schedule_work(btm_sta);
+
+    return true;
+}
+
+struct osw_btm_sta*
+osw_btm_desc_get_sta(struct osw_btm_desc *desc)
+{
+    ASSERT(desc != NULL, "");
+    ASSERT(desc->sta != NULL, "");
+    return desc->sta;
+}
+
+void
+osw_btm_sta_set_throttle(struct osw_btm_sta *btm_sta,
+                         struct osw_throttle *throttle)
+{
+    ASSERT(btm_sta != NULL, "");
+
+    osw_throttle_free(btm_sta->throttle);
+    if (throttle !=  NULL)
+        btm_sta->throttle = throttle;
+
+    osw_btm_sta_schedule_work(btm_sta);
+}
+
+#include "osw_btm_ut.c"
Index: core/src/lib/osw/src/osw_btm_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_btm_ut.c
@@ -0,0 +1,228 @@
+#include <osw_ut.h>
+#include <osw_drv_common.h>
+#include "osw_drv_i.h"
+
+struct osw_btm_ut_dummy_drv {
+    unsigned int frame_tx_cnt;
+    uint8_t frame_buf [OSW_DRV_FRAME_TX_DESC_BUF_SIZE];
+    ssize_t frame_len;
+};
+
+struct osw_btm_ut_sta_observer {
+    struct osw_btm_sta_observer observer;
+    unsigned int tx_complete_cnt;
+    unsigned int tx_error_cnt;
+};
+
+static struct osw_btm_ut_dummy_drv g_dummy_drv = {
+    .frame_tx_cnt = 0,
+    .frame_buf = { 0 },
+    .frame_len = 0,
+};
+
+OSW_UT(osw_btm_ut_build_frame)
+{
+    /*
+     * Frame 1 (this hexdump can be imported in WireShark)
+     * 0000   d0 00 3c 00 d4 61 9d 53 75 05 52 b4 f7 f0 1c cd
+     * 0010   52 b4 f7 f0 1c cd 00 00 0a 07 01 07 00 00 ff 34
+     * 0020   0d 52 b4 f7 f0 1a be 13 00 00 00 7d 9d 09 34 0d
+     * 0030   52 b4 f7 f0 1a cd 13 00 00 00 7d 95 09
+     */
+    static const unsigned char ref_frame1[] = {
+        0xd0, 0x00, 0x3c, 0x00, 0xd4, 0x61, 0x9d, 0x53,
+        0x75, 0x05, 0x52, 0xb4, 0xf7, 0xf0, 0x1c, 0xcd,
+        0x52, 0xb4, 0xf7, 0xf0, 0x1c, 0xcd, 0x00, 0x00,
+        0x0a, 0x07, 0x01, 0x07, 0x00, 0x00, 0xff, 0x34,
+        0x0d, 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe, 0x13,
+        0x00, 0x00, 0x00, 0x7d, 0x9d, 0x09, 0x34, 0x0d,
+        0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xcd, 0x13, 0x00,
+        0x00, 0x00, 0x7d, 0x92, 0x09,
+    };
+
+    const struct osw_hwaddr bssid = { .octet = { 0x52, 0xb4, 0xf7, 0xf0, 0x1c, 0xcd, } };
+    const struct osw_hwaddr sta_addr = { .octet = { 0xd4, 0x61, 0x9d, 0x53, 0x75, 0x05, } };
+    const uint8_t dialog_token = 1;
+    const struct osw_btm_req_params req_params = {
+        .neigh = {
+            {
+                .bssid = { .octet = { 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe } },
+                .bssid_info = 0x13,
+                .op_class =125,
+                .channel = 157,
+                .phy_type = 0x9,
+            },
+            {
+                .bssid = { .octet = { 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xcd } },
+                .bssid_info = 0x13,
+                .op_class = 125,
+                .channel = 146,
+                .phy_type = 0x9,
+            },
+        },
+        .neigh_len = 2,
+        .valid_int = 255,
+        .abridged  = true,
+        .disassoc_imminent = true,
+        .bss_term = false,
+    };
+
+    uint8_t frame_buf[OSW_DRV_FRAME_TX_DESC_BUF_SIZE] = { 0 };
+    ssize_t frame_len = 0;
+
+    frame_len = osw_btm_build_frame(&req_params, &sta_addr, &bssid, dialog_token, frame_buf, sizeof(frame_buf));
+    assert(frame_len == sizeof(ref_frame1));
+    assert(memcmp(&frame_buf, &ref_frame1, frame_len) == 0);
+}
+
+static bool
+osw_btm_ut_mux_frame_tx_schedule_success(const char *phy_name,
+                                         const char *vif_name,
+                                         struct osw_drv_frame_tx_desc *desc)
+{
+    g_dummy_drv.frame_tx_cnt++;
+    memcpy(&g_dummy_drv.frame_buf, osw_drv_frame_tx_desc_get_frame(desc), osw_drv_frame_tx_desc_get_frame_len(desc));
+    g_dummy_drv.frame_len = osw_drv_frame_tx_desc_get_frame_len(desc);
+
+    osw_btm_drv_frame_tx_result_cb(desc, OSW_FRAME_TX_RESULT_SUBMITTED, desc->caller_priv);
+
+    return true;
+}
+
+static bool
+osw_btm_ut_mux_frame_tx_schedule_error(const char *phy_name,
+                                       const char *vif_name,
+                                       struct osw_drv_frame_tx_desc *desc)
+{
+    g_dummy_drv.frame_tx_cnt++;
+    memcpy(&g_dummy_drv.frame_buf, osw_drv_frame_tx_desc_get_frame(desc), osw_drv_frame_tx_desc_get_frame_len(desc));
+    g_dummy_drv.frame_len = osw_drv_frame_tx_desc_get_frame_len(desc);
+
+    osw_btm_drv_frame_tx_result_cb(desc, OSW_FRAME_TX_RESULT_FAILED, desc->caller_priv);
+
+    return true;
+}
+
+static void
+osw_btm_req_tx_complete_cb(struct osw_btm_sta_observer *observer)
+{
+    struct osw_btm_ut_sta_observer *sta_observer = (struct osw_btm_ut_sta_observer*) container_of(observer, struct osw_btm_ut_sta_observer, observer);
+    sta_observer->tx_complete_cnt++;
+}
+
+static void
+osw_btm_req_tx_error_cb(struct osw_btm_sta_observer *observer)
+{
+    struct osw_btm_ut_sta_observer *sta_observer = (struct osw_btm_ut_sta_observer*) container_of(observer, struct osw_btm_ut_sta_observer, observer);
+    sta_observer->tx_error_cnt++;
+}
+
+OSW_UT(osw_btm_ut_send_single_btm)
+{
+    const struct osw_drv_dot11_frame *frame = NULL;
+    const struct osw_hwaddr sta_addr = { .octet = { 0xd4, 0x61, 0x9d, 0x53, 0x75, 0x05, } };
+    const struct osw_btm_req_params req_params = {
+        .neigh = {
+            {
+                .bssid = { .octet = { 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe } },
+                .bssid_info = 0x13,
+                .op_class =125,
+                .channel = 157,
+                .phy_type = 0x9,
+            },
+            {
+                .bssid = { .octet = { 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xcd } },
+                .bssid_info = 0x13,
+                .op_class = 125,
+                .channel = 146,
+                .phy_type = 0x9,
+            },
+        },
+        .neigh_len = 2,
+        .valid_int = 255,
+        .abridged  = true,
+        .disassoc_imminent = true,
+        .bss_term = false,
+    };
+
+    struct osw_drv_vif_state drv_vif_state = {
+        .mac_addr = { .octet = { 0xac, 0x4c, 0x56, 0x03, 0xd2, 0x1b }, },
+    };
+    struct osw_state_phy_info phy = {
+        .phy_name = "phy0",
+    };
+    struct osw_state_vif_info vif = {
+        .vif_name = "vif0",
+        .phy = &phy,
+        .drv_state = &drv_vif_state,
+    };
+    struct osw_state_sta_info sta_info = {
+        .mac_addr = &sta_addr,
+        .vif = &vif,
+    };
+
+    struct osw_btm_desc *desc = NULL;
+    struct osw_btm_ut_sta_observer sta_observer = {
+        .observer = {
+            .req_tx_complete_fn = osw_btm_req_tx_complete_cb,
+            .req_tx_error_fn = osw_btm_req_tx_error_cb,
+        },
+        .tx_complete_cnt = 0,
+        .tx_error_cnt = 0,
+    };
+    bool result;
+
+    osw_time_set_mono_clk(0);
+    osw_time_set_wall_clk(0);
+
+    desc = osw_btm_get_desc_internal(&sta_addr, &sta_observer.observer, osw_btm_ut_mux_frame_tx_schedule_success);
+    assert(desc != NULL);
+
+    /* Cannot queue BTM Request for disconnected STA */
+    result = osw_btm_desc_set_req_params(desc, &req_params);
+    osw_ut_time_advance(0);
+
+    assert(result == false);
+    assert(sta_observer.tx_complete_cnt == 0);
+    assert(sta_observer.tx_error_cnt == 0);
+
+    /* Schedule BTM Request for connected STA */
+    osw_btm_sta_connected_cb(NULL, &sta_info);
+    result = osw_btm_desc_set_req_params(desc, &req_params);
+    osw_ut_time_advance(0);
+
+    assert(result == true);
+    assert(sta_observer.tx_complete_cnt == 1);
+    assert(sta_observer.tx_error_cnt == 0);
+    assert(g_dummy_drv.frame_tx_cnt == 1);
+    frame = (const struct osw_drv_dot11_frame*) &g_dummy_drv.frame_buf;
+    assert(frame->u.action.u.bss_tm_req.dialog_token == 0);
+
+    /* Schedule BTM Request again for connected STA */
+    result = osw_btm_desc_set_req_params(desc, &req_params);
+    osw_ut_time_advance(0);
+
+    assert(result == true);
+    assert(sta_observer.tx_complete_cnt == 2);
+    assert(sta_observer.tx_error_cnt == 0);
+    assert(g_dummy_drv.frame_tx_cnt == 2);
+    frame = (const struct osw_drv_dot11_frame*) &g_dummy_drv.frame_buf;
+    assert(frame->u.action.u.bss_tm_req.dialog_token == 1);
+
+    /* Recreate desc, but with failing drv tx */
+    osw_btm_desc_free(desc);
+
+    desc = osw_btm_get_desc_internal(&sta_addr, &sta_observer.observer, osw_btm_ut_mux_frame_tx_schedule_error);
+    osw_btm_sta_connected_cb(NULL, &sta_info);
+
+    /* Schedule BTM Request again for connected STA */
+    result = osw_btm_desc_set_req_params(desc, &req_params);
+    osw_ut_time_advance(0);
+
+    assert(result == true);
+    assert(sta_observer.tx_complete_cnt == 2);
+    assert(sta_observer.tx_error_cnt == 1);
+    assert(g_dummy_drv.frame_tx_cnt == 3);
+    frame = (const struct osw_drv_dot11_frame*) &g_dummy_drv.frame_buf;
+    assert(frame->u.action.u.bss_tm_req.dialog_token == 0);
+}
Index: core/src/lib/osw/src/osw_conf.c
===================================================================
--- core.orig/src/lib/osw/src/osw_conf.c
+++ core/src/lib/osw/src/osw_conf.c
@@ -6,26 +6,37 @@
 #include <module.h>
 #include <const.h>
 #include <osw_state.h>
+#include <osw_module.h>
 #include <osw_ut.h>
 
-static struct ds_dlist g_osw_conf_mutator_list
-    = DS_DLIST_INIT(struct osw_conf_mutator, node);
-static struct ds_dlist g_osw_conf_observer_list
-    = DS_DLIST_INIT(struct osw_conf_observer, node);
+/* FIXME: For this module to actually do the right thing it
+ * needs to provide a changed_fn() observer callback that is
+ * called whenever the resulting configuration tree is
+ * different then last time it was generated. This means
+ * that even osw_state-induced recalcs need to be respected
+ * and considered as possible changed_fn(). However for that
+ * to work the module needs to be able to compare old vs
+ * new. With C that's not trivial, especially with nested
+ * structures with a web of pointers.
+ *
+ * Until that comparison is possible changed_fn() is
+ * impossible to do and would confuse osw_confsync because
+ * it really needs to distinguish between true tree changes
+ * and mere state updates.
+ */
+
+struct osw_conf {
+    struct ds_dlist mutators;
+    struct ds_dlist observers;
+};
 
-
-static int
-osw_conf_vif_acl_cmp(const void *a, const void *b)
-{
-    const struct osw_hwaddr *addr1 = a;
-    const struct osw_hwaddr *addr2 = b;
-    return memcmp(addr1, addr2, sizeof(*addr1));
-}
+static struct osw_conf g_osw_conf;
 
 static void
 osw_conf_build_vif_cb(const struct osw_state_vif_info *info,
                       void *ptr)
 {
+    struct osw_drv_vif_sta_network *snet;
     struct osw_conf_phy *phy = ptr;
     struct osw_conf_vif *vif = CALLOC(1, sizeof(*vif));
     size_t i;
@@ -45,6 +56,7 @@ osw_conf_build_vif_cb(const struct osw_s
     }
 
     vif->phy = phy;
+    vif->mac_addr = info->drv_state->mac_addr;
     vif->vif_name = STRDUP(info->vif_name);
     vif->enabled = info->drv_state->enabled;
     vif->vif_type = info->drv_state->vif_type;
@@ -53,7 +65,7 @@ osw_conf_build_vif_cb(const struct osw_s
             assert(0); /* driver bug, FIXME: dont use assert, be gentler and free memory */
             break;
         case OSW_VIF_AP:
-            ds_tree_init(&vif->u.ap.acl_tree, osw_conf_vif_acl_cmp, struct osw_conf_acl, node);
+            ds_tree_init(&vif->u.ap.acl_tree, (ds_key_cmp_t *)osw_hwaddr_cmp, struct osw_conf_acl, node);
             ds_tree_init(&vif->u.ap.psk_tree, ds_int_cmp, struct osw_conf_psk, node);
             vif->u.ap.acl_policy = info->drv_state->u.ap.acl_policy;
             vif->u.ap.ssid = info->drv_state->u.ap.ssid;
@@ -84,7 +96,15 @@ osw_conf_build_vif_cb(const struct osw_s
             assert(0); /* shouldn't reach here */
             break;
         case OSW_VIF_STA:
-            assert(0); /* TBD */
+            ds_dlist_init(&vif->u.sta.net_list, struct osw_conf_net, node);
+            for (snet = info->drv_state->u.sta.network; snet != NULL; snet = snet->next) {
+                struct osw_conf_net *cnet = CALLOC(1, sizeof(*cnet));
+                memcpy(&cnet->ssid, &snet->ssid, sizeof(snet->ssid));
+                memcpy(&cnet->bssid, &snet->bssid, sizeof(snet->bssid));
+                memcpy(&cnet->psk, &snet->psk, sizeof(snet->psk));
+                memcpy(&cnet->wpa, &snet->wpa, sizeof(snet->wpa));
+                ds_dlist_insert_tail(&vif->u.sta.net_list, cnet);
+            }
             break;
     }
     ds_tree_insert(&phy->vif_tree, vif, vif->vif_name);
@@ -94,42 +114,42 @@ static void
 osw_conf_build_phy_cb(const struct osw_state_phy_info *info,
                       void *ptr)
 {
-    struct osw_conf *conf = ptr;
+    struct ds_tree *phy_tree = ptr;
     struct osw_conf_phy *phy = CALLOC(1, sizeof(*phy));
 
     assert(info != NULL);
     assert(info->phy_name != NULL);
     assert(info->drv_state != NULL);
 
-    phy->conf = conf;
+    phy->phy_tree = phy_tree;
     phy->phy_name = STRDUP(info->phy_name);
     phy->enabled = info->drv_state->enabled;
     phy->tx_chainmask = info->drv_state->tx_chainmask;
     phy->radar = info->drv_state->radar;
     ds_tree_init(&phy->vif_tree, ds_str_cmp, struct osw_conf_vif, phy_node);
     osw_state_vif_get_list(osw_conf_build_vif_cb, phy->phy_name, phy);
-    ds_tree_insert(&conf->phy_tree, phy, phy->phy_name);
+    ds_tree_insert(phy_tree, phy, phy->phy_name);
 }
 
-struct osw_conf *
+struct ds_tree *
 osw_conf_build_from_state(void)
 {
-    struct osw_conf *conf = CALLOC(1, sizeof(*conf));
-    ds_tree_init(&conf->phy_tree, ds_str_cmp, struct osw_conf_phy, conf_node);
-    osw_state_phy_get_list(osw_conf_build_phy_cb, conf);
-    return conf;
+    struct ds_tree *phy_tree = CALLOC(1, sizeof(*phy_tree));
+    ds_tree_init(phy_tree, ds_str_cmp, struct osw_conf_phy, conf_node);
+    osw_state_phy_get_list(osw_conf_build_phy_cb, phy_tree);
+    return phy_tree;
 }
 
-struct osw_conf *
+struct ds_tree *
 osw_conf_build(void)
 {
     struct osw_conf_mutator *i;
-    struct osw_conf *conf = osw_conf_build_from_state();
+    struct ds_tree *phy_tree = osw_conf_build_from_state();
 
-    ds_dlist_foreach(&g_osw_conf_mutator_list, i)
-        i->mutate_fn(i, conf);
+    ds_dlist_foreach(&g_osw_conf.mutators, i)
+        i->mutate_fn(i, phy_tree);
 
-    return conf;
+    return phy_tree;
 }
 
 static void
@@ -153,6 +173,7 @@ osw_conf_free_vif(struct osw_conf_vif *v
 {
     struct osw_conf_acl *acl;
     struct osw_conf_psk *psk;
+    struct osw_conf_net *net;
 
     switch (vif->vif_type) {
         case OSW_VIF_UNDEFINED:
@@ -167,6 +188,8 @@ osw_conf_free_vif(struct osw_conf_vif *v
         case OSW_VIF_AP_VLAN:
             break;
         case OSW_VIF_STA:
+            while ((net = ds_dlist_remove_head(&vif->u.sta.net_list)) != NULL)
+                FREE(net);
             break;
     }
 
@@ -184,24 +207,24 @@ osw_conf_free_phy(struct osw_conf_phy *p
     ds_tree_foreach_safe(&phy->vif_tree, vif, tmp)
         osw_conf_free_vif(vif);
 
-    ds_tree_remove(&phy->conf->phy_tree, phy);
+    ds_tree_remove(phy->phy_tree, phy);
     FREE(phy->phy_name);
     FREE(phy);
 }
 
 void
-osw_conf_free(struct osw_conf *conf)
+osw_conf_free(struct ds_tree *phy_tree)
 {
     struct osw_conf_phy *phy;
     struct osw_conf_phy *tmp;
 
-    if (conf == NULL)
+    if (phy_tree == NULL)
         return;
 
-    ds_tree_foreach_safe(&conf->phy_tree, phy, tmp)
+    ds_tree_foreach_safe(phy_tree, phy, tmp)
         osw_conf_free_phy(phy);
 
-    FREE(conf);
+    FREE(phy_tree);
 }
 
 void
@@ -209,18 +232,24 @@ osw_conf_register_mutator(struct osw_con
 {
     switch (mutator->type) {
     case OSW_CONF_HEAD:
-        ds_dlist_insert_head(&g_osw_conf_mutator_list, mutator);
+        ds_dlist_insert_head(&g_osw_conf.mutators, mutator);
         break;
     case OSW_CONF_TAIL:
-        ds_dlist_insert_tail(&g_osw_conf_mutator_list, mutator);
+        ds_dlist_insert_tail(&g_osw_conf.mutators, mutator);
         break;
     }
 }
 
 void
+osw_conf_unregister_mutator(struct osw_conf_mutator *mutator)
+{
+    ds_dlist_remove(&g_osw_conf.mutators, mutator);
+}
+
+void
 osw_conf_register_observer(struct osw_conf_observer *observer)
 {
-    ds_dlist_insert_tail(&g_osw_conf_observer_list, observer);
+    ds_dlist_insert_tail(&g_osw_conf.observers, observer);
 }
 
 void
@@ -240,38 +269,10 @@ osw_conf_invalidate(struct osw_conf_muta
      *   - osw_req_config()
      *   - osw_conf_free()
     */
-    ds_dlist_foreach(&g_osw_conf_observer_list, i)
+    ds_dlist_foreach(&g_osw_conf.observers, i)
         i->mutated_fn(i);
 }
 
-void
-osw_conf_backup(void)
-{
-    struct osw_conf_mutator *i;
-
-    ds_dlist_foreach(&g_osw_conf_mutator_list, i)
-        if (i->backup_fn != NULL)
-            i->backup_fn(i);
-}
-
-void
-osw_conf_rollback(void)
-{
-    struct osw_conf_mutator *i;
-
-    /* TBD: This could be more complex. Typically one of
-     * many mutators in the sequence could be generating an
-     * issue with the configuration object. This could be
-     * bisected by applying a subset of mutators to find
-     * which one to rollback. That would however require a
-     * more involving implementation on mutators as well.
-     * For now this should be sufficient.
-     */
-    ds_dlist_foreach(&g_osw_conf_mutator_list, i)
-        if (i->rollback_fn != NULL)
-            i->rollback_fn(i);
-}
-
 bool
 osw_conf_ap_psk_tree_changed(struct ds_tree *a, struct ds_tree *b)
 {
@@ -355,7 +356,13 @@ osw_conf_ap_acl_tree_to_str(char *out, s
 }
 
 static void
-osw_conf_ut_psk_changed_cb(void *data)
+osw_conf_init(struct osw_conf *conf)
+{
+    ds_dlist_init(&conf->mutators, struct osw_conf_mutator, node);
+    ds_dlist_init(&conf->observers, struct osw_conf_observer, node);
+}
+
+OSW_UT(osw_conf_ut_psk_changed)
 {
     struct ds_tree a = DS_TREE_INIT(ds_int_cmp, struct osw_conf_psk, node);
     struct ds_tree b = DS_TREE_INIT(ds_int_cmp, struct osw_conf_psk, node);
@@ -401,11 +408,10 @@ osw_conf_ut_psk_changed_cb(void *data)
     ds_tree_remove(&b, &psk3);
 }
 
-static void
-osw_conf_ut_acl_changed_cb(void *data)
+OSW_UT(osw_conf_ut_acl_changed)
 {
-    struct ds_tree a = DS_TREE_INIT(osw_conf_vif_acl_cmp, struct osw_conf_acl, node);
-    struct ds_tree b = DS_TREE_INIT(osw_conf_vif_acl_cmp, struct osw_conf_acl, node);
+    struct ds_tree a = DS_TREE_INIT((ds_key_cmp_t *)osw_hwaddr_cmp, struct osw_conf_acl, node);
+    struct ds_tree b = DS_TREE_INIT((ds_key_cmp_t *)osw_hwaddr_cmp, struct osw_conf_acl, node);
     struct osw_conf_acl acl1 = { .mac_addr = { .octet = { 0, 1, 2, 3, 4, 5 } } };
     struct osw_conf_acl acl2 = { .mac_addr = { .octet = { 0, 1, 2, 3, 4, 6 } } };
     struct osw_conf_acl acl3 = { .mac_addr = { .octet = { 0, 1, 2, 3, 4, 7 } } };
@@ -434,16 +440,9 @@ osw_conf_ut_acl_changed_cb(void *data)
     ds_tree_remove(&b, &acl3);
 }
 
-static void
-osw_conf_ut_module_init(void *data)
+OSW_MODULE(osw_conf)
 {
-    osw_ut_register("osw_conf_ut_psk_changed", osw_conf_ut_psk_changed_cb, NULL);
-    osw_ut_register("osw_conf_ut_acl_changed", osw_conf_ut_acl_changed_cb, NULL);
+    OSW_MODULE_LOAD(osw_state);
+    osw_conf_init(&g_osw_conf);
+    return NULL;
 }
-
-static void
-osw_conf_ut_module_fini(void *data)
-{
-}
-
-MODULE(osw_conf_ut_module, osw_conf_ut_module_init, osw_conf_ut_module_fini);
Index: core/src/lib/osw/src/osw_confsync.c
===================================================================
--- core.orig/src/lib/osw/src/osw_confsync.c
+++ core/src/lib/osw/src/osw_confsync.c
@@ -3,16 +3,56 @@
 #include <memutil.h>
 #include <const.h>
 #include <module.h>
-#include <osw.h>
 #include <osw_ut.h>
+#include <osw_conf.h>
+#include <osw_state.h>
 #include <osw_confsync.h>
 #include <osw_drv_dummy.h>
 #include <osw_mux.h>
+#include <osw_module.h>
+
+#define OSW_CONFSYNC_RETRY_SECONDS_DEFAULT 30.0
+
+/* FIXME: This is temporary solution to avoid changing too
+ * many things at once.  Before OSW_MODULE can be fully
+ * utilized a way to mock-up for UT is necessarry.
+ */
+typedef struct ds_tree *osw_confsync_build_conf_fn_t(void);
+
+struct osw_confsync {
+    struct ds_dlist changed_fns;
+    enum osw_confsync_state state;
+    struct osw_state_observer state_obs;
+    struct osw_conf_observer conf_obs;
+    osw_confsync_build_conf_fn_t *build_conf;
+    ev_timer work;
+    ev_timer retry;
+    bool attached;
+    bool settled;
+};
+
+struct osw_confsync_arg {
+    struct osw_confsync *confsync;
+    struct osw_drv_conf *drv_conf;
+    struct osw_drv_phy_config *dphy;
+    struct osw_conf_phy *cphy;
+    struct osw_conf_vif *cvif;
+    struct ds_tree *phy_tree;
+    bool debug;
+};
+
+struct osw_confsync_changed {
+    struct osw_confsync *cs;
+    struct ds_dlist_node node;
+    char *name;
+    osw_confsync_changed_fn_t *fn;
+    void *fn_priv;
+};
 
 static void
 osw_confsync_build_phy_debug(const struct osw_drv_phy_config *cmd,
                              const struct osw_conf_phy *conf,
-                             const struct osw_conf_phy *state)
+                             const struct osw_drv_phy_state *state)
 {
     const char *phy = cmd->phy_name;
 
@@ -38,11 +78,45 @@ osw_confsync_build_phy_debug(const struc
 }
 
 static void
+osw_confsync_vif_ap_acl_to_str(char *out, size_t len, const struct osw_hwaddr_list *acl)
+{
+    size_t i;
+
+    out[0] = 0;
+    for (i = 0; i < acl->count; i++) {
+        const struct osw_hwaddr *addr = &acl->list[i];
+        csnprintf(&out, &len, OSW_HWADDR_FMT ",",
+                  OSW_HWADDR_ARG(addr));
+    }
+
+    if (acl->count > 0 && out[-1] == ',')
+        out[-1] = 0;
+}
+
+static void
+osw_confsync_vif_ap_psk_list_to_str(char *out, size_t len, const struct osw_ap_psk_list *psk)
+{
+    size_t i;
+
+    out[0] = 0;
+    for (i = 0; i < psk->count; i++) {
+        const struct osw_ap_psk *p = &psk->list[i];
+        const size_t max = ARRAY_SIZE(p->psk.str);
+        csnprintf(&out, &len, "%d:len=%d,",
+                  p->key_id,
+                  strnlen(p->psk.str, max));
+    }
+
+    if (psk->count > 0 && out[-1] == ',')
+        out[-1] = 0;
+}
+
+static void
 osw_confsync_build_vif_ap_debug(const char *phy,
                                 const char *vif,
                                 const struct osw_drv_vif_config_ap *cmd,
                                 const struct osw_conf_vif_ap *conf,
-                                const struct osw_conf_vif_ap *state)
+                                const struct osw_drv_vif_state_ap *state)
 {
     const int max_2g_chan = 11; /* FIXME: Assuming worst case regulatory. Could use phy chan list */
 
@@ -119,7 +193,7 @@ osw_confsync_build_vif_ap_debug(const ch
     if (cmd->acl_changed) {
         char from[1024];
         char to[1024];
-        osw_conf_ap_acl_tree_to_str(from, sizeof(from), &state->acl_tree);
+        osw_confsync_vif_ap_acl_to_str(from, sizeof(from), &state->acl);
         osw_conf_ap_acl_tree_to_str(to, sizeof(to), &conf->acl_tree);
         LOGI("osw: confsync: %s/%s: acl: %s -> %s", phy, vif, from, to);
     }
@@ -127,16 +201,77 @@ osw_confsync_build_vif_ap_debug(const ch
     if (cmd->psk_list_changed) {
         char from[1024];
         char to[1024];
-        osw_conf_ap_psk_tree_to_str(from, sizeof(from), &state->psk_tree);
+        osw_confsync_vif_ap_psk_list_to_str(from, sizeof(from), &state->psk_list);
         osw_conf_ap_psk_tree_to_str(to, sizeof(to), &conf->psk_tree);
         LOGI("osw: confsync: %s/%s: psk: %s -> %s", phy, vif, from, to);
     }
 }
 
+static const char *
+osw_confsync_sta_op_to_str(const enum osw_drv_vif_config_sta_operation op)
+{
+    switch (op) {
+        case OSW_DRV_VIF_CONFIG_STA_NOP: return NULL;
+        case OSW_DRV_VIF_CONFIG_STA_CONNECT: return "connect";
+        case OSW_DRV_VIF_CONFIG_STA_RECONNECT: return "reconnect";
+        case OSW_DRV_VIF_CONFIG_STA_DISCONNECT: return "disconnect";
+    }
+    return NULL;
+}
+
+static void
+osw_confsync_net_to_str(char *buf, size_t len,
+                        const struct osw_drv_vif_sta_network *net)
+{
+    memset(buf, 0, len);
+
+    while (net != NULL) {
+        /* FIXME: could dump more info, but it might be too obscure */
+        csnprintf(&buf, &len, OSW_SSID_FMT, OSW_SSID_ARG(&net->ssid));
+        if (osw_hwaddr_is_zero(&net->bssid) == false) {
+            csnprintf(&buf, &len, " "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&net->bssid));
+        }
+        if (strlen(net->psk.str) > 0) {
+            csnprintf(&buf, &len, " %zu", strlen(net->psk.str));
+        }
+        char wpa_str[64] = {0};
+        osw_wpa_to_str(wpa_str, sizeof(wpa_str), &net->wpa);
+        if (strlen(wpa_str) > 0) {
+            csnprintf(&buf, &len, " %s", wpa_str);
+        }
+        if (net->next != NULL) {
+            csnprintf(&buf, &len, ",");
+        }
+        net = net->next;
+    }
+}
+
+static void
+osw_confsync_build_vif_sta_debug(const char *phy,
+                                 const char *vif,
+                                 const struct osw_drv_vif_config_sta *cmd,
+                                 const struct osw_conf_vif_sta *conf,
+                                 const struct osw_drv_vif_state_sta *state)
+{
+    const char *op_str = osw_confsync_sta_op_to_str(cmd->operation);
+
+    if (cmd->network_changed) {
+        char from[1024];
+        char to[1024];
+        osw_confsync_net_to_str(from, sizeof(from), state->network);
+        osw_confsync_net_to_str(to, sizeof(to), cmd->network);
+        LOGI("osw: confsync: %s/%s: net list: %s -> %s", phy, vif, from, to);
+    }
+
+    if (op_str != NULL) {
+        LOGI("osw: confsync: %s/%s: op: %s", phy, vif, op_str);
+    }
+}
+
 static void
 osw_confsync_build_vif_debug(const struct osw_drv_vif_config *cmd,
                              const struct osw_conf_vif *conf,
-                             const struct osw_conf_vif *state)
+                             const struct osw_drv_vif_state *state)
 {
     const char *phy = conf->phy->phy_name;
     const char *vif = conf->vif_name;
@@ -171,6 +306,10 @@ osw_confsync_build_vif_debug(const struc
             case OSW_VIF_AP_VLAN:
                 break;
             case OSW_VIF_STA:
+                osw_confsync_build_vif_sta_debug(phy, vif,
+                                                 &cmd->u.sta,
+                                                 &conf->u.sta,
+                                                 &state->u.sta);
                 break;
         }
     }
@@ -219,228 +358,444 @@ osw_confsync_vif_ap_channel_changed(cons
         return true;
 }
 
+static bool
+osw_confsync_vif_ap_psk_tree_changed(struct ds_tree *a, const struct osw_ap_psk_list *b)
+{
+    const size_t n = ds_tree_len(a);
+    size_t i;
+
+    if (n != b->count)
+        return true;
+
+    for (i = 0; i < b->count; i++) {
+        const struct osw_ap_psk *p = &b->list[i];
+        const struct osw_conf_psk *q = ds_tree_find(a, &p->key_id);
+        if (q == NULL) return true;
+
+        const char *x = p->psk.str;
+        const char *y = q->ap_psk.psk.str;
+        size_t l = sizeof(p->psk.str);
+        if (strncmp(x, y, l) != 0) return true;
+    }
+
+    return false;
+}
+
+static bool
+osw_confsync_vif_ap_acl_tree_changed(struct ds_tree *a, const struct osw_hwaddr_list *b)
+{
+    const size_t n = ds_tree_len(a);
+    size_t i;
+
+    if (n != b->count)
+        return true;
+
+    for (i = 0; i < b->count; i++) {
+        const struct osw_hwaddr *p = &b->list[i];
+        const struct osw_conf_acl *q = ds_tree_find(a, p);
+        if (q == NULL) return true;
+    }
+
+    return false;
+}
+
 static void
-osw_confsync_vif_ap_mark_changed(struct osw_conf_vif *cvif,
-                                 struct osw_conf_vif *svif,
-                                 struct osw_drv_vif_config *dvif)
-{
-    dvif->u.ap.ssid_changed = osw_confsync_vif_ap_ssid_changed(&cvif->u.ap.ssid, &svif->u.ap.ssid);
-    dvif->u.ap.psk_list_changed = osw_conf_ap_psk_tree_changed(&cvif->u.ap.psk_tree, &svif->u.ap.psk_tree);
-    dvif->u.ap.acl_changed = osw_conf_ap_acl_tree_changed(&cvif->u.ap.acl_tree, &svif->u.ap.acl_tree);
-    dvif->u.ap.channel_changed = osw_confsync_vif_ap_channel_changed(&cvif->u.ap.channel, &svif->u.ap.channel);
-
-    dvif->changed |= (dvif->u.ap.beacon_interval_tu_changed = (svif->u.ap.beacon_interval_tu != cvif->u.ap.beacon_interval_tu));
-    dvif->changed |= (dvif->u.ap.isolated_changed = (svif->u.ap.isolated != cvif->u.ap.isolated));
-    dvif->changed |= (dvif->u.ap.ssid_hidden_changed = (svif->u.ap.ssid_hidden != cvif->u.ap.ssid_hidden));
-    dvif->changed |= (dvif->u.ap.mcast2ucast_changed = (svif->u.ap.mcast2ucast != cvif->u.ap.mcast2ucast));
-    dvif->changed |= (dvif->u.ap.acl_policy_changed = (svif->u.ap.acl_policy != cvif->u.ap.acl_policy));
-    dvif->changed |= (dvif->u.ap.wpa_changed = (memcmp(&svif->u.ap.wpa, &cvif->u.ap.wpa, sizeof(svif->u.ap.wpa)) != 0));
-    dvif->changed |= (dvif->u.ap.mode_changed = (memcmp(&svif->u.ap.mode, &cvif->u.ap.mode, sizeof(svif->u.ap.mode)) != 0));
-    dvif->changed |= (dvif->u.ap.bridge_if_name_changed = (strcmp(svif->u.ap.bridge_if_name.buf, cvif->u.ap.bridge_if_name.buf) != 0));
+osw_confsync_vif_ap_mark_changed(struct osw_drv_vif_config *dvif,
+                                 const struct osw_drv_vif_state *svif,
+                                 struct osw_conf_vif *cvif,
+                                 const bool all)
+{
+    dvif->u.ap.ssid_changed = all || osw_confsync_vif_ap_ssid_changed(&cvif->u.ap.ssid, &svif->u.ap.ssid);
+    dvif->u.ap.psk_list_changed = all || osw_confsync_vif_ap_psk_tree_changed(&cvif->u.ap.psk_tree, &svif->u.ap.psk_list);
+    dvif->u.ap.acl_changed = all || osw_confsync_vif_ap_acl_tree_changed(&cvif->u.ap.acl_tree, &svif->u.ap.acl);
+    dvif->u.ap.channel_changed = all || osw_confsync_vif_ap_channel_changed(&cvif->u.ap.channel, &svif->u.ap.channel);
+
+    dvif->changed |= all || (dvif->u.ap.beacon_interval_tu_changed = (svif->u.ap.beacon_interval_tu != cvif->u.ap.beacon_interval_tu));
+    dvif->changed |= all || (dvif->u.ap.isolated_changed = (svif->u.ap.isolated != cvif->u.ap.isolated));
+    dvif->changed |= all || (dvif->u.ap.ssid_hidden_changed = (svif->u.ap.ssid_hidden != cvif->u.ap.ssid_hidden));
+    dvif->changed |= all || (dvif->u.ap.mcast2ucast_changed = (svif->u.ap.mcast2ucast != cvif->u.ap.mcast2ucast));
+    dvif->changed |= all || (dvif->u.ap.acl_policy_changed = (svif->u.ap.acl_policy != cvif->u.ap.acl_policy));
+    dvif->changed |= all || (dvif->u.ap.wpa_changed = (memcmp(&svif->u.ap.wpa, &cvif->u.ap.wpa, sizeof(svif->u.ap.wpa)) != 0));
+    dvif->changed |= all || (dvif->u.ap.mode_changed = (memcmp(&svif->u.ap.mode, &cvif->u.ap.mode, sizeof(svif->u.ap.mode)) != 0));
+    dvif->changed |= all || (dvif->u.ap.bridge_if_name_changed = (strcmp(svif->u.ap.bridge_if_name.buf, cvif->u.ap.bridge_if_name.buf) != 0));
     dvif->changed |= dvif->u.ap.psk_list_changed;
     dvif->changed |= dvif->u.ap.acl_changed;
     dvif->changed |= dvif->u.ap.ssid_changed;
     dvif->changed |= dvif->u.ap.channel_changed;
 
-    dvif->u.ap.csa_required = (dvif->u.ap.channel_changed && svif->enabled == true);
+    if (all == false) {
+        dvif->u.ap.csa_required = (dvif->u.ap.channel_changed && svif->enabled == true);
+    }
 }
 
-static struct osw_drv_conf *
-osw_confsync_build_drv_conf(struct osw_confsync *cs, const bool debug)
+static void
+osw_confsync_build_drv_conf_vif_ap(struct osw_drv_vif_config *dvif,
+                                   const struct osw_drv_vif_state *svif,
+                                   struct osw_conf_vif *cvif)
 {
-    struct osw_drv_conf *drv_conf = CALLOC(1, sizeof(*drv_conf));
-    struct osw_conf *conf = cs->conf;
-    struct osw_conf *state = cs->state;
-    struct osw_conf_phy *cphy;
-    struct osw_conf_phy *sphy;
-    struct osw_drv_phy_config *dphy;
-    struct osw_conf_vif *cvif;
-    struct osw_conf_vif *svif;
-    struct osw_drv_vif_config *dvif;
     const int max_2g_chan = 11; /* FIXME: Assuming worst case regulatory. Could use phy chan list */
 
-    ds_tree_foreach(&state->phy_tree, sphy) {
-        cphy = ds_tree_find(&conf->phy_tree, sphy->phy_name);
-        assert(cphy != NULL);
-
-        drv_conf->n_phy_list++;
-        drv_conf->phy_list = REALLOC(drv_conf->phy_list, drv_conf->n_phy_list * sizeof(*dphy));
-        dphy = &drv_conf->phy_list[drv_conf->n_phy_list - 1];
-        memset(dphy, 0, sizeof(*dphy));
-
-        dphy->phy_name = STRDUP(cphy->phy_name);
-        dphy->enabled = cphy->enabled;
-        dphy->tx_chainmask = cphy->tx_chainmask;
-        dphy->radar = cphy->radar;
+    dvif->u.ap.bridge_if_name = cvif->u.ap.bridge_if_name;
+    dvif->u.ap.beacon_interval_tu = cvif->u.ap.beacon_interval_tu;
+    dvif->u.ap.channel = cvif->u.ap.channel;
+    dvif->u.ap.isolated = cvif->u.ap.isolated;
+    dvif->u.ap.ssid_hidden = cvif->u.ap.ssid_hidden;
+    dvif->u.ap.mcast2ucast = cvif->u.ap.mcast2ucast;
+    dvif->u.ap.mode = cvif->u.ap.mode;
+    dvif->u.ap.acl_policy = cvif->u.ap.acl_policy;
+    dvif->u.ap.ssid = cvif->u.ap.ssid;
+    dvif->u.ap.wpa = cvif->u.ap.wpa;
+
+    if (dvif->u.ap.channel.center_freq0_mhz == 0)
+        osw_channel_compute_center_freq(&dvif->u.ap.channel, max_2g_chan);
+
+    {
+        struct osw_ap_psk *psks;
+        struct osw_conf_psk *psk;
+        int n = 0;
+        int i = 0;
+
+        ds_tree_foreach(&cvif->u.ap.psk_tree, psk)
+            n++;
+
+        psks = CALLOC(n, sizeof(*psks));
+        ds_tree_foreach(&cvif->u.ap.psk_tree, psk) {
+            psks[i].key_id = psk->ap_psk.key_id;
+            STRSCPY_WARN(psks[i].psk.str, psk->ap_psk.psk.str);
+            i++;
+        }
 
-        if (dphy->enabled == false && sphy->enabled == false)
-            cphy = sphy;
+        dvif->u.ap.psk_list.list = psks;
+        dvif->u.ap.psk_list.count = n;
+    }
+    {
+        struct osw_hwaddr *addrs;
+        struct osw_conf_acl *acl;
+        int n = 0;
+        int i = 0;
+
+        ds_tree_foreach(&cvif->u.ap.acl_tree, acl)
+            n++;
+
+        addrs = CALLOC(n, sizeof(*addrs));
+        ds_tree_foreach(&cvif->u.ap.acl_tree, acl) {
+            addrs[i] = acl->mac_addr;
+            i++;
+        }
 
-        dphy->changed = false;
-        dphy->changed |= (dphy->enabled_changed = cphy->enabled != sphy->enabled);
-        dphy->changed |= (dphy->tx_chainmask_changed = cphy->tx_chainmask != sphy->tx_chainmask);
-        dphy->changed |= (dphy->radar_changed = cphy->radar != sphy->radar);
+        dvif->u.ap.acl.list = addrs;
+        dvif->u.ap.acl.count = n;
+    }
+    // FIXME: radius
+
+    const bool all_changed = (dvif->vif_type_changed == true);
+    osw_confsync_vif_ap_mark_changed(dvif, svif, cvif, all_changed);
+}
+
+static enum osw_drv_vif_config_sta_operation
+osw_confsync_build_drv_conf_vif_sta_op(struct osw_drv_vif_config *dvif,
+                                       const struct osw_drv_vif_state *svif,
+                                       bool network_changed)
+{
+    const struct osw_drv_vif_state_sta *ssta = &svif->u.sta;
+    struct osw_drv_vif_config_sta *dsta = &dvif->u.sta;
+    const bool want_connected = (dsta->network != NULL);
+    const bool is_connecting = (ssta->link.status == OSW_DRV_VIF_STATE_STA_LINK_CONNECTING);
+    const bool is_connected = (ssta->link.status == OSW_DRV_VIF_STATE_STA_LINK_CONNECTED);
+    struct osw_drv_vif_sta_network *dnet;
+
+    if (want_connected == is_connected && is_connected == false)
+        return OSW_DRV_VIF_CONFIG_STA_NOP;
+
+    if (want_connected != is_connected && is_connected == false) {
+        if (is_connecting == true && network_changed == false)
+            return OSW_DRV_VIF_CONFIG_STA_NOP;
 
-        if (debug) osw_confsync_build_phy_debug(dphy, cphy, sphy);
+        return OSW_DRV_VIF_CONFIG_STA_CONNECT;
+    }
+
+    if (want_connected != is_connected && is_connected == true)
+        return OSW_DRV_VIF_CONFIG_STA_DISCONNECT;
+
+    assert(want_connected == is_connected && is_connected == true);
+
+    for (dnet = dsta->network; dnet != NULL; dnet = dnet->next) {
+        const size_t bssid_len = sizeof(dnet->bssid);
+        const size_t ssid_max = sizeof(dnet->ssid.buf);
+        const bool bssid_valid = osw_hwaddr_is_zero(&dnet->bssid) == false;
+        const bool bssid_match = memcmp(&dnet->bssid, &ssta->link.bssid, bssid_len) == 0;
+        const bool ssid_match = strncmp(dnet->ssid.buf, ssta->link.ssid.buf, ssid_max) == 0;
+        const bool match = (bssid_valid == true && bssid_match == true)
+                        || (bssid_valid == false && ssid_match == true);
 
-        /* Recover real cphy back in case it was overridden
-         * due to disablement.
+        if (match == true) {
+            return OSW_DRV_VIF_CONFIG_STA_NOP;
+        }
+
+        /* FIXME: Arguably this could be more involving - it
+         * could verify if WPA is matching as well. Right
+         * now changing WPA settings, eg. for
+         * WPA3-Transition mode parent won't yield WPA2 ->
+         * WPA3 reonnect if orchestrated. That's not a valid
+         * usecase today so this can be simplified for now.
          */
-        cphy = ds_tree_find(&conf->phy_tree, sphy->phy_name);
+    }
 
-        ds_tree_foreach(&sphy->vif_tree, svif) {
-            cvif = ds_tree_find(&cphy->vif_tree, svif->vif_name);
-            assert(cvif != NULL);
-
-            dphy->vif_list.count++;
-            dphy->vif_list.list = REALLOC(dphy->vif_list.list, dphy->vif_list.count * sizeof(*dvif));
-            dvif = &dphy->vif_list.list[dphy->vif_list.count - 1];
-            memset(dvif, 0, sizeof(*dvif));
-
-            cvif->enabled &= cphy->enabled;
-
-            dvif->vif_name = STRDUP(cvif->vif_name);
-            dvif->enabled = cvif->enabled;
-            dvif->vif_type = cvif->vif_type;
-
-            if (dvif->enabled == false && svif->enabled == false)
-                cvif = svif;
-
-            dvif->changed = false;
-            dvif->changed |= (dvif->enabled_changed = (cvif->enabled != svif->enabled));
-            dvif->changed |= (dvif->vif_type_changed = (cvif->vif_type != svif->vif_type));
-
-            switch (cvif->vif_type) {
-                case OSW_VIF_UNDEFINED:
-                    break;
-                case OSW_VIF_AP:
-                    dvif->u.ap.bridge_if_name = cvif->u.ap.bridge_if_name;
-                    dvif->u.ap.beacon_interval_tu = cvif->u.ap.beacon_interval_tu;
-                    dvif->u.ap.channel = cvif->u.ap.channel;
-                    dvif->u.ap.isolated = cvif->u.ap.isolated;
-                    dvif->u.ap.ssid_hidden = cvif->u.ap.ssid_hidden;
-                    dvif->u.ap.mcast2ucast = cvif->u.ap.mcast2ucast;
-                    dvif->u.ap.mode = cvif->u.ap.mode;
-                    dvif->u.ap.acl_policy = cvif->u.ap.acl_policy;
-                    dvif->u.ap.ssid = cvif->u.ap.ssid;
-                    dvif->u.ap.wpa = cvif->u.ap.wpa;
-
-                    if (dvif->u.ap.channel.center_freq0_mhz == 0)
-                        osw_channel_compute_center_freq(&dvif->u.ap.channel, max_2g_chan);
-
-                    {
-                        struct osw_ap_psk *psks;
-                        struct osw_conf_psk *psk;
-                        int n = 0;
-                        int i = 0;
-
-                        ds_tree_foreach(&cvif->u.ap.psk_tree, psk)
-                            n++;
-
-                        psks = CALLOC(n, sizeof(*psks));
-                        ds_tree_foreach(&cvif->u.ap.psk_tree, psk) {
-                            psks[i].key_id = psk->ap_psk.key_id;
-                            STRSCPY_WARN(psks[i].psk.str, psk->ap_psk.psk.str);
-                            i++;
-                        }
-
-                        dvif->u.ap.psk_list.list = psks;
-                        dvif->u.ap.psk_list.count = n;
-                    }
-                    {
-                        struct osw_hwaddr *addrs;
-                        struct osw_conf_acl *acl;
-                        int n = 0;
-                        int i = 0;
-
-                        ds_tree_foreach(&cvif->u.ap.acl_tree, acl)
-                            n++;
-
-                        addrs = CALLOC(n, sizeof(*addrs));
-                        ds_tree_foreach(&cvif->u.ap.acl_tree, acl) {
-                            addrs[i] = acl->mac_addr;
-                            i++;
-                        }
-
-                        dvif->u.ap.acl.list = addrs;
-                        dvif->u.ap.acl.count = n;
-                    }
-                    // FIXME: radius
-
-                    if (dvif->vif_type_changed == false)
-                        osw_confsync_vif_ap_mark_changed(cvif, svif, dvif);
-
-                    /* FIXME: Arguably if vif_type is changing _all_ parameters
-                     * are changing?
-                     */
-                    break;
-                case OSW_VIF_AP_VLAN:
-                    break;
-                case OSW_VIF_STA:
-                    break;
-            }
+    return OSW_DRV_VIF_CONFIG_STA_RECONNECT;
+}
+
+static bool
+osw_confsync_net_is_identical(const struct osw_drv_vif_sta_network *a,
+                              const struct osw_drv_vif_sta_network *b)
+{
+    const bool same_bssid = memcmp(&a->bssid, &b->bssid, sizeof(a->bssid)) == 0;
+    const bool same_ssid = (a->ssid.len == b->ssid.len) &&
+                           memcmp(a->ssid.buf, b->ssid.buf, a->ssid.len) == 0;
+    const bool same_psk = strcmp(a->psk.str, b->psk.str) == 0;
+    struct osw_wpa wpa1 = a->wpa;
+    struct osw_wpa wpa2 = b->wpa;
+    wpa1.group_rekey_seconds = 0;
+    wpa2.group_rekey_seconds = 0;
+    const bool same_wpa = memcmp(&wpa1, &wpa2, sizeof(wpa1)) == 0;
+
+    return same_bssid && same_ssid && same_psk && same_wpa;
+}
+
+static bool
+osw_confsync_vif_sta_state_contains_net(const struct osw_drv_vif_state_sta *ssta,
+                                        const struct osw_drv_vif_sta_network *net)
+{
+    struct osw_drv_vif_sta_network *i;
+    for (i = ssta->network; i != NULL; i = i->next) {
+        if (osw_confsync_net_is_identical(i, net))
+            return true;
+    }
+    return false;
+}
+
+static bool
+osw_confsync_vif_sta_net_list_changed(const struct osw_drv_vif_state_sta *ssta,
+                                      const struct osw_drv_vif_config_sta *dsta)
+{
+    struct osw_drv_vif_sta_network *i;
+    for (i = dsta->network; i != NULL; i = i->next) {
+        if (osw_confsync_vif_sta_state_contains_net(ssta, i) == false)
+            return true;
+    }
+    return false;
+}
 
-            if (debug) osw_confsync_build_vif_debug(dvif, cvif, svif);
+static struct osw_drv_vif_sta_network *
+osw_confsync_build_drv_conf_vif_sta_net_list(struct osw_conf_vif_sta *csta)
+{
+    struct osw_drv_vif_sta_network *first = NULL;
+    struct osw_conf_net *cnet;
+
+    ds_dlist_foreach(&csta->net_list, cnet) {
+        struct osw_drv_vif_sta_network *dnet = CALLOC(1, sizeof(*dnet));
+        dnet->next = first;
+        memcpy(&dnet->ssid, &cnet->ssid, sizeof(cnet->ssid));
+        memcpy(&dnet->bssid, &cnet->bssid, sizeof(cnet->bssid));
+        memcpy(&dnet->wpa, &cnet->wpa, sizeof(cnet->wpa));
+        memcpy(&dnet->psk, &cnet->psk, sizeof(cnet->psk));
+        first = dnet;
+    }
+
+    return first;
+}
+
+static void
+osw_confsync_build_drv_conf_vif_sta(struct osw_drv_vif_config *dvif,
+                                    const struct osw_drv_vif_state *svif,
+                                    struct osw_conf_vif *cvif)
+{
+    const struct osw_drv_vif_state_sta *ssta = &svif->u.sta;
+    struct osw_drv_vif_config_sta *dsta = &dvif->u.sta;
+    struct osw_conf_vif_sta *csta = &cvif->u.sta;
+
+    dsta->network = osw_confsync_build_drv_conf_vif_sta_net_list(csta);
+    dsta->network_changed = osw_confsync_vif_sta_net_list_changed(ssta, dsta);
+    dsta->operation = osw_confsync_build_drv_conf_vif_sta_op(dvif, svif, dsta->network_changed);
+
+    if (dsta->operation == OSW_DRV_VIF_CONFIG_STA_NOP) {
+        /* Don't bother reconfiguring interface if it's
+         * connected to something that is intended to be a
+         * target. This relaxes driver implementations so
+         * they don't really need to report network blocks
+         * back in state for onboarding purposes in most
+         * cases.
+         */
+        if (getenv("OSW_CONFSYNC_STRICT_NETWORK_CHANGES") == NULL) {
+            dsta->network_changed = false;
         }
     }
 
-    return drv_conf;
+    dvif->changed |= dsta->network_changed;
+    dvif->changed |= (dsta->operation != OSW_DRV_VIF_CONFIG_STA_NOP);
 }
 
 static void
-osw_confsync_set_idle(struct osw_confsync *cs, const bool idle)
+osw_confsync_build_drv_conf_vif(struct osw_confsync_arg *arg,
+                                const struct osw_state_vif_info *vif)
 {
-    if (cs->idle == idle) return;
-    if (idle == true && cs->idle_fn != NULL) cs->idle_fn(cs);
-    if (idle == false && cs->busy_fn != NULL) cs->busy_fn(cs);
-    cs->idle = idle;
+    struct osw_conf_phy *cphy = arg->cphy;
+    struct osw_conf_vif *cvif = arg->cvif;
+    const struct osw_drv_vif_state *svif = vif->drv_state;
+    struct osw_drv_phy_config *dphy = arg->dphy;
+
+    struct osw_drv_vif_config *dvif;
+    dphy->vif_list.count++;
+    dphy->vif_list.list = REALLOC(dphy->vif_list.list, dphy->vif_list.count * sizeof(*dvif));
+    dvif = &dphy->vif_list.list[dphy->vif_list.count - 1];
+    memset(dvif, 0, sizeof(*dvif));
+
+    const bool enabled = (cvif->enabled && cphy->enabled);
+
+    dvif->vif_name = STRDUP(cvif->vif_name);
+    dvif->enabled = enabled;
+    dvif->vif_type = cvif->vif_type;
+
+    const bool skip = (dvif->enabled == false && svif->enabled == false);
+
+    dvif->changed = false;
+    if (skip == false) {
+        dvif->changed |= (dvif->enabled_changed = (cvif->enabled != svif->enabled));
+        dvif->changed |= (dvif->vif_type_changed = (cvif->vif_type != svif->vif_type));
+    }
+
+    switch (cvif->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            osw_confsync_build_drv_conf_vif_ap(dvif, svif, cvif);
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            osw_confsync_build_drv_conf_vif_sta(dvif, svif, cvif);
+            break;
+    }
+
+    if (skip) {
+        dvif->changed = false;
+        return;
+    }
+
+    if (arg->debug) osw_confsync_build_vif_debug(dvif, cvif, svif);
 }
 
 static void
-osw_confsync_update_idle(struct osw_confsync *cs)
+osw_confsync_build_drv_conf_phy(struct osw_confsync_arg *arg,
+                                const struct osw_state_phy_info *phy)
 {
-    const bool working = ev_is_active(&cs->work);
-    const bool retrying = ev_is_active(&cs->retry);
-    const bool idle = (working == false) && (retrying == false);
-    osw_confsync_set_idle(cs, idle);
+    struct osw_drv_conf *drv_conf = arg->drv_conf;
+    const struct osw_drv_phy_state *sphy = phy->drv_state;
+    struct osw_conf_phy *cphy = arg->cphy;
+
+    struct osw_drv_phy_config *dphy;
+    drv_conf->n_phy_list++;
+    drv_conf->phy_list = REALLOC(drv_conf->phy_list, drv_conf->n_phy_list * sizeof(*dphy));
+    dphy = &drv_conf->phy_list[drv_conf->n_phy_list - 1];
+    memset(dphy, 0, sizeof(*dphy));
+
+    dphy->phy_name = STRDUP(cphy->phy_name);
+    dphy->enabled = cphy->enabled;
+    dphy->tx_chainmask = cphy->tx_chainmask;
+    dphy->radar = cphy->radar;
+
+    const bool skip = (dphy->enabled == false && sphy->enabled == false);
+
+    dphy->changed = false;
+    if (skip == false) {
+        dphy->changed |= (dphy->enabled_changed = cphy->enabled != sphy->enabled);
+        dphy->changed |= (dphy->tx_chainmask_changed = cphy->tx_chainmask != sphy->tx_chainmask);
+        dphy->changed |= (dphy->radar_changed = cphy->radar != sphy->radar);
+    }
+
+    if (arg->debug) osw_confsync_build_phy_debug(dphy, cphy, sphy);
+    arg->dphy = dphy;
 }
 
 static void
-osw_confsync_set_settled(struct osw_confsync *cs, bool settled)
+osw_confsync_build_drv_conf_vif_cb(const struct osw_state_vif_info *vif,
+                                   void *priv)
 {
-    if (cs->settled == settled) goto out;
+    struct osw_confsync_arg *arg = priv;
+    struct osw_conf_phy *cphy = arg->cphy;
 
-    if (settled == true) {
-        ev_timer_stop(EV_DEFAULT_ &cs->retry);
-        cs->settled = true;
-        if (cs->settled_fn != NULL) cs->settled_fn(cs);
-    }
+    arg->cvif = ds_tree_find(&cphy->vif_tree, vif->vif_name);
+    assert(arg->cvif != NULL);
 
-    if (settled == false) {
-        assert(!ev_is_active(&cs->retry));
-        ev_timer_start(EV_DEFAULT_ &cs->retry);
-        cs->settled = false;
-        if (cs->agitated_fn != NULL) cs->agitated_fn(cs);
-    }
+    osw_confsync_build_drv_conf_vif(arg, vif);
+}
 
-out:
-    osw_confsync_update_idle(cs);
+static void
+osw_confsync_build_drv_conf_phy_cb(const struct osw_state_phy_info *phy,
+                                   void *priv)
+{
+    struct osw_confsync_arg *arg = priv;
+    struct ds_tree *phy_tree = arg->phy_tree;
+
+    arg->cphy = ds_tree_find(phy_tree, phy->phy_name);
+    assert(arg->cphy != NULL);
+
+    osw_confsync_build_drv_conf_phy(arg, phy);
+    osw_state_vif_get_list(osw_confsync_build_drv_conf_vif_cb, phy->phy_name, arg);
 }
 
-static bool
-osw_confsync_can_request(struct osw_confsync *cs, bool force)
+static struct osw_drv_conf *
+osw_confsync_build_drv_conf(struct osw_confsync *cs, const bool debug)
+{
+    struct osw_confsync_arg arg = {
+        .drv_conf = CALLOC(1, sizeof(*arg.drv_conf)),
+        .phy_tree = cs->build_conf(),
+        .debug = debug,
+    };
+    osw_state_phy_get_list(osw_confsync_build_drv_conf_phy_cb, &arg);
+    osw_conf_free(arg.phy_tree);
+    return arg.drv_conf;
+}
+
+static void
+osw_confsync_notify_changed(struct osw_confsync *cs)
+{
+    struct osw_confsync_changed *i;
+    ds_dlist_foreach(&cs->changed_fns, i)
+        i->fn(cs, i->fn_priv);
+}
+
+static void
+osw_confsync_set_state(struct osw_confsync *cs, enum osw_confsync_state s)
 {
-    if (cs->conf == NULL) return false;
-    if (cs->state == NULL) return false;
-    if (force == true) return true;
-    return cs->settled;
+    LOGT("%s: state %d -> %d", __func__, cs->state, s);
+    if (cs->state == s) return;
+    cs->state = s;
+    switch (cs->state) {
+        case OSW_CONFSYNC_IDLE:
+            if (cs->settled == false) LOGN("osw: confsync: settled");
+            cs->settled = true;
+            ev_timer_stop(EV_DEFAULT_ &cs->retry);
+            ev_timer_stop(EV_DEFAULT_ &cs->work);
+            break;
+        case OSW_CONFSYNC_REQUESTING:
+            ev_timer_stop(EV_DEFAULT_ &cs->retry);
+            ev_timer_start(EV_DEFAULT_ &cs->work);
+            break;
+        case OSW_CONFSYNC_WAITING:
+            if (cs->settled == true) LOGN("osw: confsync: unsettled");
+            cs->settled = false;
+            ev_timer_start(EV_DEFAULT_ &cs->retry);
+            break;
+        case OSW_CONFSYNC_VERIFYING:
+            ev_timer_start(EV_DEFAULT_ &cs->work);
+            break;
+    }
+    osw_confsync_notify_changed(cs);
 }
 
 static bool
 osw_confsync_conf_is_synced(struct osw_confsync *cs)
 {
-    if (cs->conf == NULL) return false;
-    if (cs->state == NULL) return false;
     const bool debug = false;
     struct osw_drv_conf *conf = osw_confsync_build_drv_conf(cs, debug);
     bool changed = false;
@@ -459,87 +814,268 @@ osw_confsync_conf_is_synced(struct osw_c
 }
 
 static void
-osw_confsync_work(struct osw_confsync *cs, bool force)
+osw_confsync_work(struct osw_confsync *cs)
 {
-    LOGT("%s", __func__);
+    LOGD("osw: confsync: work");
 
-    if (osw_confsync_can_request(cs, force) == true) {
-        const bool debug = true;
-        struct osw_drv_conf *conf = osw_confsync_build_drv_conf(cs, debug);
-        bool requested = osw_mux_request_config(conf);
-        osw_confsync_set_settled(cs, requested ? false : true);
-    }
-    else if (osw_confsync_conf_is_synced(cs)) {
-        osw_confsync_set_settled(cs, true);
+    switch (cs->state) {
+        case OSW_CONFSYNC_IDLE:
+            break;
+        case OSW_CONFSYNC_REQUESTING:
+            {
+                const bool debug = true;
+                struct osw_drv_conf *conf = osw_confsync_build_drv_conf(cs, debug);
+                const bool requested = osw_mux_request_config(conf);
+                const enum osw_confsync_state s = (requested == true)
+                                                ? OSW_CONFSYNC_WAITING
+                                                : OSW_CONFSYNC_IDLE;
+                osw_confsync_set_state(cs, s);
+            }
+            break;
+        case OSW_CONFSYNC_WAITING:
+            break;
+        case OSW_CONFSYNC_VERIFYING:
+            {
+                const bool done = osw_confsync_conf_is_synced(cs);
+                const enum osw_confsync_state s = (done == true)
+                                              ? OSW_CONFSYNC_IDLE
+                                              : OSW_CONFSYNC_WAITING;
+                osw_confsync_set_state(cs, s);
+            }
+            break;
     }
 }
 
 static void
 osw_confsync_work_cb(EV_P_  ev_timer *arg, int events)
 {
-    struct osw_confsync *cs = container_of(arg, struct osw_confsync, work);
-    bool forced = cs->forced;
-    cs->forced = false;
     LOGT("%s", __func__);
-    osw_confsync_work(cs, forced);
+    struct osw_confsync *cs = container_of(arg, struct osw_confsync, work);
+    osw_confsync_work(cs);
 }
 
 static void
 osw_confsync_retry_cb(EV_P_  ev_timer *arg, int events)
 {
-    struct osw_confsync *cs = container_of(arg, struct osw_confsync, retry);
     LOGT("%s", __func__);
-    osw_confsync_work(cs, true);
+    struct osw_confsync *cs = container_of(arg, struct osw_confsync, retry);
+    osw_confsync_set_state(cs, OSW_CONFSYNC_REQUESTING);
 }
 
-void
+static void
+osw_confsync_state_changed(struct osw_confsync *cs)
+{
+    /* When a configuration command is submitted the system
+     * may go through transient state changes before
+     * reaching a final state. To avoid needlessly
+     * re-issuing configuration commands, and possibly
+     * making configuration inadvertantly longer, move to
+     * CHECKING only when IDLE.
+     */
+    switch (cs->state) {
+        case OSW_CONFSYNC_IDLE:
+            osw_confsync_set_state(cs, OSW_CONFSYNC_REQUESTING);
+            return;
+        case OSW_CONFSYNC_REQUESTING:
+            return;
+        case OSW_CONFSYNC_WAITING:
+            osw_confsync_set_state(cs, OSW_CONFSYNC_VERIFYING);
+            return;
+        case OSW_CONFSYNC_VERIFYING:
+            return;
+    }
+}
+
+static void
+osw_confsync_conf_changed(struct osw_confsync *cs)
+{
+    osw_confsync_set_state(cs, OSW_CONFSYNC_REQUESTING);
+}
+
+static void
+osw_confsync_state_busy_cb(struct osw_state_observer *o)
+{
+    LOGD("osw: confsync: state: busy");
+}
+
+static void
+osw_confsync_state_idle_cb(struct osw_state_observer *o)
+{
+    LOGD("osw: confsync: state: idle");
+}
+
+static void
+osw_confsync_state_phy_added_cb(struct osw_state_observer *o,
+                                const struct osw_state_phy_info *phy)
+{
+    struct osw_confsync *cs = container_of(o, struct osw_confsync, state_obs);
+    LOGD("osw: confsync: state: %s: added", phy->phy_name);
+    /* This, and other cases of conf_changed() called for
+     * state observer is intentional. When entities
+     * appear/disappear they impact fundamentally the way
+     * osw_conf will look like. These happen seldom,
+     * typically on system start, or hard reconfigs anyway,
+     * so it's fine to consider these as conf_changed().
+     */
+    osw_confsync_conf_changed(cs);
+}
+
+static void
+osw_confsync_state_phy_changed_cb(struct osw_state_observer *o,
+                                  const struct osw_state_phy_info *phy)
+{
+    struct osw_confsync *cs = container_of(o, struct osw_confsync, state_obs);
+    LOGD("osw: confsync: state: %s: changed", phy->phy_name);
+    osw_confsync_state_changed(cs);
+}
+
+static void
+osw_confsync_state_phy_removed_cb(struct osw_state_observer *o,
+                                  const struct osw_state_phy_info *phy)
+{
+    struct osw_confsync *cs = container_of(o, struct osw_confsync, state_obs);
+    LOGD("osw: confsync: state: %s: removed", phy->phy_name);
+    osw_confsync_conf_changed(cs);
+}
+
+static void
+osw_confsync_state_vif_added_cb(struct osw_state_observer *o,
+                                const struct osw_state_vif_info *vif)
+{
+    struct osw_confsync *cs = container_of(o, struct osw_confsync, state_obs);
+    LOGD("osw: confsync: state: %s/%s: added", vif->phy->phy_name, vif->vif_name);
+    osw_confsync_conf_changed(cs);
+}
+
+static void
+osw_confsync_state_vif_changed_cb(struct osw_state_observer *o,
+                                  const struct osw_state_vif_info *vif)
+{
+    struct osw_confsync *cs = container_of(o, struct osw_confsync, state_obs);
+    LOGD("osw: confsync: state: %s/%s: changed", vif->phy->phy_name, vif->vif_name);
+    osw_confsync_state_changed(cs);
+}
+
+static void
+osw_confsync_state_vif_removed_cb(struct osw_state_observer *o,
+                                  const struct osw_state_vif_info *vif)
+{
+    struct osw_confsync *cs = container_of(o, struct osw_confsync, state_obs);
+    LOGD("osw: confsync: state: %s/%s: removed", vif->phy->phy_name, vif->vif_name);
+    osw_confsync_conf_changed(cs);
+}
+
+static void
+osw_confsync_conf_mutated_cb(struct osw_conf_observer *o)
+{
+    struct osw_confsync *cs = container_of(o, struct osw_confsync, conf_obs);
+    osw_confsync_conf_changed(cs);
+}
+
+static void
 osw_confsync_init(struct osw_confsync *cs)
 {
-    if (cs->retry_seconds == 0)
-        cs->retry_seconds = OSW_CONFSYNC_RETRY_SECONDS_DEFAULT;
+    if (cs->state_obs.name != NULL) return;
+
+    const struct osw_state_observer state_obs = {
+        .name = __FILE__,
+        .idle_fn = osw_confsync_state_idle_cb,
+        .busy_fn = osw_confsync_state_busy_cb,
+        .phy_added_fn = osw_confsync_state_phy_added_cb,
+        .phy_changed_fn = osw_confsync_state_phy_changed_cb,
+        .phy_removed_fn = osw_confsync_state_phy_removed_cb,
+        .vif_added_fn = osw_confsync_state_vif_added_cb,
+        .vif_changed_fn = osw_confsync_state_vif_changed_cb,
+        .vif_removed_fn = osw_confsync_state_vif_removed_cb,
+    };
+    const struct osw_conf_observer conf_obs = {
+        .name = __FILE__,
+        .mutated_fn = osw_confsync_conf_mutated_cb,
+    };
+    const float retry = OSW_CONFSYNC_RETRY_SECONDS_DEFAULT;
 
+    cs->state_obs = state_obs;
+    cs->conf_obs = conf_obs;
+    cs->build_conf = osw_conf_build;
+    ds_dlist_init(&cs->changed_fns, struct osw_confsync_changed, node);
     ev_timer_init(&cs->work, osw_confsync_work_cb, 0, 0);
-    ev_timer_init(&cs->retry, osw_confsync_retry_cb,
-                  cs->retry_seconds, cs->retry_seconds);
-    osw_confsync_set_settled(cs, true);
+    ev_timer_init(&cs->retry, osw_confsync_retry_cb, retry, retry);
 }
 
-void
-osw_confsync_fini(struct osw_confsync *cs)
+static void
+osw_confsync_attach(struct osw_confsync *cs)
 {
-    ev_timer_stop(EV_DEFAULT_ &cs->work);
-    ev_timer_stop(EV_DEFAULT_ &cs->retry);
+    if (cs->attached == true) return;
+    osw_state_register_observer(&cs->state_obs);
+    osw_conf_register_observer(&cs->conf_obs);
+    cs->attached = true;
 }
 
 static void
-osw_confsync_work_schedule(struct osw_confsync *cs)
+osw_confsync_fini(struct osw_confsync *cs)
 {
-    LOGT("%s", __func__);
-    ev_timer_start(EV_DEFAULT_ &cs->work);
-    osw_confsync_update_idle(cs);
+    osw_confsync_set_state(cs, OSW_CONFSYNC_IDLE);
 }
 
-void
-osw_confsync_set(struct osw_confsync *cs,
-                 struct osw_conf *conf,
-                 struct osw_conf *state,
-                 bool forced)
+static struct osw_confsync g_osw_confsync;
+
+struct osw_confsync *
+osw_confsync_get(void)
 {
-    LOGT("%s", __func__);
-    osw_conf_free(cs->conf);
-    osw_conf_free(cs->state);
-    cs->conf = conf;
-    cs->state = state;
-    cs->forced |= forced;
-    osw_confsync_work_schedule(cs);
+    osw_confsync_init(&g_osw_confsync);
+    osw_confsync_attach(&g_osw_confsync);
+    return &g_osw_confsync;
+}
+
+enum osw_confsync_state
+osw_confsync_get_state(struct osw_confsync *cs)
+{
+    return cs->state;
+}
+
+const char *
+osw_confsync_state_to_str(enum osw_confsync_state s)
+{
+    switch (s) {
+        case OSW_CONFSYNC_IDLE: return "idle";
+        case OSW_CONFSYNC_REQUESTING: return "requesting";
+        case OSW_CONFSYNC_WAITING: return "waiting";
+        case OSW_CONFSYNC_VERIFYING: return "verifying";
+    }
+    return "undefined";
 }
 
-bool
-osw_confsync_is_settled(struct osw_confsync *cs)
-{
-    if (ev_is_active(&cs->work)) return false;
-    if (ev_is_active(&cs->retry)) return false;
-    return true;
+struct osw_confsync_changed *
+osw_confsync_register_changed_fn(struct osw_confsync *cs,
+                                 const char *name,
+                                 osw_confsync_changed_fn_t *fn,
+                                 void *fn_priv)
+{
+    assert(cs != NULL);
+    assert(fn != NULL);
+    assert(name != NULL);
+
+    LOGT("%s: cs=%p name=%s fn=%p priv=%p", __func__, cs, name, fn, fn_priv);
+
+    struct osw_confsync_changed *c = CALLOC(1, sizeof(*c));
+    c->cs = cs;
+    c->name = STRDUP(name);
+    c->fn = fn;
+    c->fn_priv = fn_priv;
+    ds_dlist_insert_tail(&cs->changed_fns, c);
+    fn(cs, fn_priv);
+
+    return c;
+}
+
+void
+osw_confsync_unregister_changed(struct osw_confsync_changed *c)
+{
+    assert(c->cs != NULL);
+    LOGT("%s: cs=%p name=%s fn=%p priv=%p", __func__, c->cs, c->name, c->fn, c->fn_priv);
+    ds_dlist_remove(&c->cs->changed_fns, c);
+    FREE(c->name); c->name = NULL;
+    FREE(c);
 }
 
 static void
@@ -571,15 +1107,10 @@ osw_confsync_ut_two_drivers_conf2_cb(str
 }
 
 static void
-osw_confsync_ut_two_drivers_agitated_cb(struct osw_confsync *cs)
+osw_confsync_ut_two_drivers_changed_cb(struct osw_confsync *cs, void *priv)
 {
-    LOGI("ow: confsync: ut: agitated");
-}
-
-static void
-osw_confsync_ut_two_drivers_settled_cb(struct osw_confsync *cs)
-{
-    LOGI("ow: confsync: ut: settled");
+    const enum osw_confsync_state s = osw_confsync_get_state(cs);
+    LOGI("ow: confsync: ut: changed: %s", osw_confsync_state_to_str(s));
 }
 
 struct osw_confsync_ut_two_drivers {
@@ -592,16 +1123,25 @@ osw_confsync_ut_two_drivers_idle_cb(stru
 {
     struct osw_confsync_ut_two_drivers *ut;
     ut = container_of(obs, struct osw_confsync_ut_two_drivers, obs);
-    LOGI("ow: confsync: ut: idle");
+    LOGI("ow: confsync: ut: state: idle");
     ev_unref(EV_DEFAULT);
 
-    struct osw_conf *conf = osw_conf_build_from_state();
-    struct osw_conf *state = osw_conf_build_from_state();
-    osw_confsync_set(&ut->cs, conf, state, true);
+    ut->cs.build_conf = osw_conf_build_from_state;
+    osw_confsync_set_state(&ut->cs, OSW_CONFSYNC_REQUESTING);
 }
 
-static void
-osw_confsync_ut_two_drivers(void *data)
+static struct ds_tree *
+osw_confsync_ut_two_drivers_build_conf(void)
+{
+    struct ds_tree *phy_tree = osw_conf_build_from_state();
+    struct osw_conf_phy *phy1 = ds_tree_find(phy_tree, "phy1");
+    struct osw_conf_phy *phy2 = ds_tree_find(phy_tree, "phy2");
+    phy1->enabled = true;
+    phy2->enabled = true;
+    return phy_tree;
+}
+
+OSW_UT(osw_confsync_ut_two_drivers)
 {
     struct osw_drv_dummy dummy1 = {
         .name = "dummy1",
@@ -612,53 +1152,115 @@ osw_confsync_ut_two_drivers(void *data)
         .request_config_fn = osw_confsync_ut_two_drivers_conf2_cb,
     };
     struct osw_confsync_ut_two_drivers ut = {
-        .cs = {
-            .agitated_fn = osw_confsync_ut_two_drivers_agitated_cb,
-            .settled_fn = osw_confsync_ut_two_drivers_settled_cb,
-        },
         .obs = {
             .idle_fn = osw_confsync_ut_two_drivers_idle_cb,
             .name = "two_drivers",
         },
     };
+    struct osw_confsync_changed *c;
 
-    osw_init();
+    osw_module_load_name("osw_drv");
     osw_drv_dummy_init(&dummy1);
     osw_drv_dummy_init(&dummy2);
     osw_state_register_observer(&ut.obs);
     osw_confsync_init(&ut.cs);
-    osw_confsync_set(&ut.cs, NULL, NULL, true);
+    assert(osw_confsync_get_state(&ut.cs) == OSW_CONFSYNC_IDLE);
+    c = osw_confsync_register_changed_fn(&ut.cs,
+                                         __func__,
+                                         osw_confsync_ut_two_drivers_changed_cb,
+                                         &ut);
     osw_drv_dummy_set_phy(&dummy1, "phy1", (struct osw_drv_phy_state []) {{ .exists = true }});
     osw_drv_dummy_set_phy(&dummy2, "phy2", (struct osw_drv_phy_state []) {{ .exists = true }});
     ev_ref(EV_DEFAULT); /* idle */
     LOGI("ow: confsync: ut: wait idle");
     ev_run(EV_DEFAULT_ 0);
+    assert(osw_confsync_get_state(&ut.cs) == OSW_CONFSYNC_IDLE);
+    LOGI("ow: confsync: ut: wait done");
 
-    struct osw_conf *conf = osw_conf_build_from_state();
-    struct osw_conf *state = osw_conf_build_from_state();
-    struct osw_conf_phy *phy1 = ds_tree_find(&conf->phy_tree, "phy1");
-    struct osw_conf_phy *phy2 = ds_tree_find(&conf->phy_tree, "phy2");
-    phy1->enabled = true;
-    phy2->enabled = true;
-    osw_confsync_set(&ut.cs, conf, state, true);
+    ut.cs.build_conf = osw_confsync_ut_two_drivers_build_conf;
+    osw_confsync_set_state(&ut.cs, OSW_CONFSYNC_REQUESTING);
     ev_ref(EV_DEFAULT); /* obs */
     ev_ref(EV_DEFAULT); /* conf1 */
     ev_ref(EV_DEFAULT); /* conf2 */
     LOGI("ow: confsync: ut: wait conf");
     ev_run(EV_DEFAULT_ 0);
+
+    osw_confsync_unregister_changed(c);
+    osw_confsync_fini(&ut.cs);
 }
 
 static void
-osw_confsync_ut_module_init(void *data)
+osw_confsync_ut_changed_cb(struct osw_confsync *cs, void *priv)
 {
-    osw_ut_register("osw_confsync_ut_two_drivers", osw_confsync_ut_two_drivers, NULL);
+    int *i = priv;
+    (*i)++;
 }
 
-static void
-osw_confsync_ut_module_fini(void *data)
+OSW_UT(osw_confsync_changed_fn)
 {
+    int a = 0;
+    int b = 0;
+    int c = 0;
+
+    struct osw_confsync cs = {0};
+    osw_confsync_init(&cs);
+
+    struct osw_confsync_changed *c1;
+    struct osw_confsync_changed *c2;
+    struct osw_confsync_changed *c3;
+
+    assert(a == 0);
+    assert(b == 0);
+    assert(c == 0);
+    LOGT("%p %p %p", &a, &b, &c);
+
+    c1 = osw_confsync_register_changed_fn(&cs, "c1", osw_confsync_ut_changed_cb, &a);
+    c2 = osw_confsync_register_changed_fn(&cs, "c2", osw_confsync_ut_changed_cb, &b);
+    assert(a == 1);
+    assert(b == 1);
+    assert(c == 0);
+
+    osw_confsync_notify_changed(&cs);
+    assert(a == 2);
+    assert(b == 2);
+    assert(c == 0);
+
+    c3 = osw_confsync_register_changed_fn(&cs, "c3", osw_confsync_ut_changed_cb, &c);
+    assert(a == 2);
+    assert(b == 2);
+    assert(c == 1);
+
+    osw_confsync_notify_changed(&cs);
+    assert(a == 3);
+    assert(b == 3);
+    assert(c == 2);
+
+    osw_confsync_unregister_changed(c2);
+    osw_confsync_notify_changed(&cs);
+    assert(a == 4);
+    assert(b == 3);
+    assert(c == 3);
+
+    osw_confsync_unregister_changed(c1);
+    osw_confsync_notify_changed(&cs);
+    assert(a == 4);
+    assert(b == 3);
+    assert(c == 4);
+
+    osw_confsync_unregister_changed(c3);
+    assert(a == 4);
+    assert(b == 3);
+    assert(c == 4);
+
+    assert(ds_dlist_is_empty(&cs.changed_fns) == true);
+}
+
+OSW_MODULE(osw_confsync)
+{
+    OSW_MODULE_LOAD(osw_conf);
+    OSW_MODULE_LOAD(osw_state);
+    OSW_MODULE_LOAD(osw_mux);
+    osw_confsync_init(&g_osw_confsync);
+    osw_confsync_attach(&g_osw_confsync);
+    return NULL;
 }
-
-MODULE(osw_confsync_ut_module,
-       osw_confsync_ut_module_init,
-       osw_confsync_ut_module_fini);
Index: core/src/lib/osw/src/osw_cqm.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_cqm.c
@@ -0,0 +1,535 @@
+#include <memutil.h>
+#include <log.h>
+#include <const.h>
+
+#include <osw_timer.h>
+#include <osw_time.h>
+#include <osw_state.h>
+#include <osw_ut.h>
+#include <osw_cqm.h>
+
+/*
+ * Connection Quality Monitor
+ *
+ * Purpose:
+ *
+ * Provide an easy way to observe OSW_VIF_STA link changes
+ * from the point of interest of losting a link for too
+ * long.
+ *
+ * Notes:
+ *
+ * Arguably the module name is slightly too generic for the
+ * purpose, but at the same time it's not. If this proves to
+ * collide with another similar purpose then it should be
+ * renamed to match more closely its task.
+ */
+
+#define LOG_PREFIX "osw: cqm: "
+
+enum osw_cqm_link_op {
+    OSW_CQM_LINK_NOP,
+    OSW_CQM_LINK_DEADLINE_ARM,
+    OSW_CQM_LINK_DEADLINE_DISARM,
+    OSW_CQM_LINK_SET_CHANNEL,
+    OSW_CQM_LINK_CLEAR_TIMEOUT,
+};
+
+struct osw_cqm_link_sm {
+    enum osw_cqm_link_state state;
+    struct osw_channel channel;
+    bool connected;
+    bool configured;
+    bool timed_out;
+};
+
+struct osw_cqm_link {
+    struct ds_tree_node node;
+    struct osw_cqm *cqm;
+    char *vif_name;
+    const struct osw_state_vif_info *vif;
+    struct osw_channel channel;
+    struct osw_timer work;
+    struct osw_timer deadline;
+    struct osw_cqm_link_sm sm;
+};
+
+struct osw_cqm_notify {
+    struct ds_dlist_node node;
+    struct osw_cqm *cqm;
+    char *name;
+    osw_cqm_notify_fn_t *fn;
+    void *fn_priv;
+};
+
+struct osw_cqm {
+    struct ds_dlist_node node;
+    struct osw_cqm_mod *m;
+    struct ds_tree links;
+    struct ds_dlist notify_fns;
+    struct osw_state_observer state_obs;
+    uint64_t timeout_nsec;
+};
+
+#define OPS_TO_MOD(ops) container_of(ops, struct osw_cqm_mod, ops)
+
+struct osw_cqm_mod {
+    struct osw_cqm_ops ops;
+    struct ds_dlist cqms;
+};
+
+static const char *
+link_state_to_str(enum osw_cqm_link_state s)
+{
+    switch (s) {
+        case OSW_CQM_LINK_DECONFIGURED: return "deconfigured";
+        case OSW_CQM_LINK_DISCONNECTED: return "disconnected";
+        case OSW_CQM_LINK_CONNECTED: return "connected";
+        case OSW_CQM_LINK_TIMING_OUT: return "timing_out";
+        case OSW_CQM_LINK_RECOVERING: return "recovering";
+        case OSW_CQM_LINK_TIMED_OUT: return "timed_out";
+    }
+    return "";
+}
+
+static const char *
+link_op_to_str(enum osw_cqm_link_op op)
+{
+    switch (op) {
+        case OSW_CQM_LINK_NOP: return "nop";
+        case OSW_CQM_LINK_DEADLINE_ARM: return "deadline_arm";
+        case OSW_CQM_LINK_DEADLINE_DISARM: return "deadline_disarm";
+        case OSW_CQM_LINK_SET_CHANNEL: return "set_channel";
+        case OSW_CQM_LINK_CLEAR_TIMEOUT: return "clear_timeout";
+    }
+    return "";
+}
+
+static void
+link_notify_one(const struct osw_cqm_link *link,
+                const struct osw_cqm_link_sm *sm,
+                const struct osw_cqm_notify *n)
+{
+    const char *to = link_state_to_str(sm->state);
+    LOGD(LOG_PREFIX"notify: %s: %s @ %s", n->name, link->vif_name, to);
+    n->fn(link->vif_name, sm->state, &link->sm.channel, n->fn_priv);
+}
+
+static void
+link_notify(struct osw_cqm_link *link)
+{
+    struct osw_cqm_notify *n;
+
+    ds_dlist_foreach(&link->cqm->notify_fns, n) {
+        link_notify_one(link, &link->sm, n);
+    }
+}
+
+static enum osw_cqm_link_state
+link_sm_next(struct osw_cqm_link_sm *sm)
+{
+    switch (sm->state) {
+        case OSW_CQM_LINK_DECONFIGURED:
+            if (sm->configured == true) return OSW_CQM_LINK_DISCONNECTED;
+            break;
+        case OSW_CQM_LINK_DISCONNECTED:
+            if (sm->configured == false) return OSW_CQM_LINK_DECONFIGURED;
+            if (sm->connected == true) return OSW_CQM_LINK_CONNECTED;
+            if (sm->timed_out == true) return OSW_CQM_LINK_CONNECTED;
+            break;
+        case OSW_CQM_LINK_CONNECTED:
+            if (sm->configured == false) return OSW_CQM_LINK_DECONFIGURED;
+            if (sm->connected == false) return OSW_CQM_LINK_TIMING_OUT;
+            break;
+        case OSW_CQM_LINK_RECOVERING:
+            return OSW_CQM_LINK_CONNECTED;
+        case OSW_CQM_LINK_TIMING_OUT:
+            if (sm->configured == false) return OSW_CQM_LINK_DECONFIGURED;
+            if (sm->connected == true) return OSW_CQM_LINK_RECOVERING;
+            if (sm->timed_out == true) return OSW_CQM_LINK_TIMED_OUT;
+            break;
+        case OSW_CQM_LINK_TIMED_OUT:
+            if (sm->configured == false) return OSW_CQM_LINK_DECONFIGURED;
+            if (sm->connected == true) return OSW_CQM_LINK_CONNECTED;
+            break;
+    }
+    return sm->state;
+}
+
+static enum osw_cqm_link_state
+link_sm_walk(const struct osw_cqm_link *link,
+             const struct osw_cqm_link_sm *base,
+             struct osw_cqm_notify *n,
+             enum osw_cqm_link_state from)
+{
+    struct osw_cqm_link_sm sm = {0};
+    if (base != NULL) sm = *base;
+    sm.state = from;
+
+    for (;;) {
+        const enum osw_cqm_link_state next_state = link_sm_next(&sm);
+        if (sm.state == next_state) break;
+        sm.state = next_state;
+        link_notify_one(link, &sm, n);
+    }
+
+    return sm.state;
+}
+
+static void
+link_sm_op(struct osw_cqm_link *link,
+           enum osw_cqm_link_op op)
+{
+    const uint64_t now = osw_time_mono_clk();
+    const uint64_t at = now + link->cqm->timeout_nsec;
+    LOGD(LOG_PREFIX"link: %s: op: %s", link->vif_name, link_op_to_str(op));
+    switch (op) {
+        case OSW_CQM_LINK_NOP:
+            break;
+        case OSW_CQM_LINK_DEADLINE_ARM:
+            link->sm.timed_out = false;
+            osw_timer_arm_at_nsec(&link->deadline, at);
+            break;
+        case OSW_CQM_LINK_DEADLINE_DISARM:
+            osw_timer_disarm(&link->deadline);
+            break;
+        case OSW_CQM_LINK_SET_CHANNEL:
+            link->sm.channel = link->channel;
+            break;
+        case OSW_CQM_LINK_CLEAR_TIMEOUT:
+            link->sm.timed_out = false;
+            break;
+    }
+}
+
+static enum osw_cqm_link_op
+link_sm_leave(struct osw_cqm_link *link,
+              enum osw_cqm_link_state state)
+{
+    switch (state) {
+        case OSW_CQM_LINK_DECONFIGURED: return OSW_CQM_LINK_NOP;
+        case OSW_CQM_LINK_DISCONNECTED: return OSW_CQM_LINK_NOP;
+        case OSW_CQM_LINK_CONNECTED: return OSW_CQM_LINK_NOP;
+        case OSW_CQM_LINK_TIMING_OUT: return OSW_CQM_LINK_DEADLINE_DISARM;
+        case OSW_CQM_LINK_RECOVERING: return OSW_CQM_LINK_NOP;
+        case OSW_CQM_LINK_TIMED_OUT: return OSW_CQM_LINK_CLEAR_TIMEOUT;
+    }
+    return OSW_CQM_LINK_NOP;
+}
+
+static enum osw_cqm_link_op
+link_sm_enter(struct osw_cqm_link *link,
+              enum osw_cqm_link_state state)
+{
+    switch (state) {
+        case OSW_CQM_LINK_DECONFIGURED: return OSW_CQM_LINK_NOP;
+        case OSW_CQM_LINK_DISCONNECTED: return OSW_CQM_LINK_NOP;
+        case OSW_CQM_LINK_CONNECTED: return OSW_CQM_LINK_SET_CHANNEL;
+        case OSW_CQM_LINK_TIMING_OUT: return OSW_CQM_LINK_DEADLINE_ARM;
+        case OSW_CQM_LINK_RECOVERING: return OSW_CQM_LINK_NOP;
+        case OSW_CQM_LINK_TIMED_OUT: return OSW_CQM_LINK_NOP;
+    }
+    return OSW_CQM_LINK_NOP;
+}
+
+static void
+link_free(struct osw_cqm_link *link)
+{
+    assert(link->cqm != NULL);
+    assert(osw_timer_is_armed(&link->deadline) == false);
+    osw_timer_disarm(&link->work);
+    ds_tree_remove(&link->cqm->links, link);
+    FREE(link->vif_name);
+    FREE(link);
+}
+
+static void
+link_work(struct osw_cqm_link *link)
+{
+    for (;;) {
+        const enum osw_cqm_link_state prev_state = link->sm.state;
+        const enum osw_cqm_link_state next_state = link_sm_next(&link->sm);
+        if (prev_state == next_state) break;
+        const char *from = link_state_to_str(prev_state);
+        const char *to = link_state_to_str(next_state);
+        LOGD(LOG_PREFIX"link: %s: state: %s -> %s", link->vif_name, from, to);
+        link->sm.state = next_state;
+        link_sm_op(link, link_sm_leave(link, prev_state));
+        link_sm_op(link, link_sm_enter(link, next_state));
+        link_notify(link);
+    }
+
+    if (link->sm.state == OSW_CQM_LINK_DECONFIGURED) {
+        link_free(link);
+    }
+}
+
+static void
+link_arm(struct osw_cqm_link *link)
+{
+    osw_timer_arm_at_nsec(&link->work, 0);
+}
+
+static void
+link_work_cb(struct osw_timer *t)
+{
+    struct osw_cqm_link *link = container_of(t, struct osw_cqm_link, work);
+    link_work(link);
+}
+
+static void
+link_deadline_cb(struct osw_timer *t)
+{
+    struct osw_cqm_link *link = container_of(t, struct osw_cqm_link, deadline);
+    link->sm.timed_out = true;
+    link_arm(link);
+}
+
+static struct osw_cqm_link *
+link_get(struct osw_cqm *cqm, const char *vif_name)
+{
+    struct osw_cqm_link *link = ds_tree_find(&cqm->links, vif_name);
+    if (link == NULL) {
+        link = CALLOC(1, sizeof(*link));
+        link->cqm = cqm;
+        link->vif_name = STRDUP(vif_name);
+        link->deadline.cb = link_deadline_cb;
+        link->work.cb = link_work_cb;
+        ds_tree_insert(&cqm->links, link, link->vif_name);
+    }
+    return link;
+}
+
+static bool
+vif_is_connected(const struct osw_state_vif_info *vif)
+{
+    if (vif == NULL) return false;
+    if (vif->drv_state->vif_type != OSW_VIF_STA) return false;
+    if (vif->drv_state->u.sta.link.status != OSW_DRV_VIF_STATE_STA_LINK_CONNECTED) return false;
+
+    return true;
+}
+
+static bool
+vif_is_configured(const struct osw_state_vif_info *vif)
+{
+    if (vif == NULL) return false;
+    if (vif->drv_state->vif_type != OSW_VIF_STA) return false;
+    if (vif->drv_state->enabled == false) return false;
+
+    /* FIXME: This should look at u.sta.network but some
+     * drivers currently can't guarantee to fill that in
+     * properly in time.
+     */
+    //if (vif->drv_state->u.sta.network == NULL) return false;
+
+    return true;
+}
+
+static void
+//vif_update_cb(struct osw_state_observer *obs,
+              //const struct osw_state_vif_info *vif)
+sta_update_cb(struct osw_state_observer *obs,
+              const struct osw_state_sta_info *sta)
+{
+    const struct osw_state_vif_info *vif = sta->vif;
+    const char *vif_name = vif->vif_name;
+    struct osw_cqm *cqm = container_of(obs, struct osw_cqm, state_obs);
+    struct osw_cqm_link *link = link_get(cqm, vif_name);
+    link->vif = vif->drv_state->exists == true ? vif : NULL;
+    const bool configured =vif_is_configured(link->vif);
+    const bool connected = vif_is_connected(link->vif);
+    if (connected == true) {
+        link->channel = vif->drv_state->u.sta.link.channel;
+    }
+    LOGD(LOG_PREFIX"link: %s: updating: configured=%d -> %d connected=%d -> %d channel="OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+         link->vif_name,
+         link->sm.configured,
+         configured,
+         link->sm.connected,
+         connected,
+         OSW_CHANNEL_ARG(&link->sm.channel),
+         OSW_CHANNEL_ARG(&link->channel));
+    link->sm.configured = configured;
+    link->sm.connected = connected;
+    link_arm(link);
+}
+
+static void
+osw_cqm_init(struct osw_cqm *cqm)
+{
+    const struct osw_state_observer state_obs = {
+        .name = __FILE__,
+        //.vif_added_fn = vif_update_cb,
+        //.vif_removed_fn = vif_update_cb,
+        //.vif_changed_fn = vif_update_cb,
+        .sta_connected_fn = sta_update_cb,
+        .sta_disconnected_fn = sta_update_cb,
+    };
+
+    ds_tree_init(&cqm->links, ds_str_cmp, struct osw_cqm_link, node);
+    ds_dlist_init(&cqm->notify_fns, struct osw_cqm_notify, node);
+    cqm->state_obs = state_obs;
+}
+
+static struct osw_cqm *
+op_alloc(struct osw_cqm_ops *ops)
+{
+    struct osw_cqm_mod *m = OPS_TO_MOD(ops);
+    struct osw_cqm *cqm = CALLOC(1, sizeof(*cqm));
+    osw_cqm_init(cqm);
+    cqm->m = m;
+    ds_dlist_insert_tail(&m->cqms, cqm);
+    osw_state_register_observer(&cqm->state_obs);
+    return cqm;
+}
+
+static void
+op_set_timeout_sec(struct osw_cqm *cqm, float seconds)
+{
+    cqm->timeout_nsec = OSW_TIME_SEC(seconds);
+}
+
+static struct osw_cqm_notify *
+op_add_notify(struct osw_cqm *cqm,
+              const char *name,
+              osw_cqm_notify_fn_t *fn,
+              void *fn_priv)
+{
+    assert(cqm != NULL);
+    assert(name != NULL);
+
+    LOGD(LOG_PREFIX"notify: %s: allocating", name);
+    struct osw_cqm_notify *n = CALLOC(1, sizeof(*n));
+    n->cqm = cqm;
+    n->fn = fn;
+    n->fn_priv = fn_priv;
+    n->name = STRDUP(name);
+    ds_dlist_insert_tail(&cqm->notify_fns, n);
+
+    struct osw_cqm_link *link;
+    ds_tree_foreach(&cqm->links, link) {
+        link_sm_walk(link, &link->sm, n, OSW_CQM_LINK_DECONFIGURED);
+    }
+
+    return n;
+}
+
+static void
+op_del_notify(struct osw_cqm_notify *n)
+{
+    if (n == NULL) return;
+
+    LOGD(LOG_PREFIX"notify: %s: freeing", n->name);
+    struct osw_cqm_link *link;
+    ds_tree_foreach(&n->cqm->links, link) {
+        const enum osw_cqm_link_state last_state = link_sm_walk(link, NULL, n, link->sm.state);
+        assert(last_state == OSW_CQM_LINK_DECONFIGURED);
+    }
+    ds_dlist_remove(&n->cqm->notify_fns, n);
+    FREE(n->name);
+    FREE(n);
+}
+
+static void
+op_free(struct osw_cqm *cqm)
+{
+    ds_dlist_remove(&cqm->m->cqms, cqm);
+    osw_state_unregister_observer(&cqm->state_obs);
+    WARN_ON(ds_dlist_is_empty(&cqm->notify_fns) == true); /* memleak */
+    WARN_ON(ds_tree_is_empty(&cqm->links) == true); /* memleak */
+    FREE(cqm);
+}
+
+static void
+mod_init(struct osw_cqm_mod *m)
+{
+    const struct osw_cqm_ops ops = {
+        .alloc_fn = op_alloc,
+        .free_fn = op_free,
+        .set_timeout_sec_fn = op_set_timeout_sec,
+        .add_notify_fn = op_add_notify,
+        .del_notify_fn = op_del_notify,
+    };
+    m->ops = ops;
+    ds_dlist_init(&m->cqms, struct osw_cqm, node);
+}
+
+OSW_MODULE(osw_cqm)
+{
+    OSW_MODULE_LOAD(osw_state);
+    static struct osw_cqm_mod m;
+    mod_init(&m);
+    return &m.ops;
+}
+
+OSW_UT(osw_cqm_)
+{
+    struct osw_cqm cqm;
+    osw_cqm_init(&cqm);
+    struct osw_cqm_link *link = link_get(&cqm, "vif1");
+    enum osw_cqm_link_state *s = &link->sm.state;
+    assert(link != NULL);
+    link->sm.configured = true;
+    assert(*s == OSW_CQM_LINK_DECONFIGURED);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_DISCONNECTED);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_DISCONNECTED);
+    link->sm.configured = false;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_DECONFIGURED);
+    link->sm.configured = true;
+    link->sm.connected = true;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_DISCONNECTED);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_CONNECTED);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_CONNECTED);
+    link->sm.connected = false;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMING_OUT);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMING_OUT);
+    link->sm.timed_out = true;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMED_OUT);
+    link->sm.connected = true;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_CONNECTED);
+    link->sm.connected = false;
+    link->sm.timed_out = false;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMING_OUT);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMING_OUT);
+    link->sm.connected = true;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_RECOVERING);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_CONNECTED);
+
+    /* check walking */
+    struct osw_cqm_link_sm sm = link->sm;
+    s = &sm.state;
+    *s = OSW_CQM_LINK_DECONFIGURED;
+
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_DISCONNECTED);
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_CONNECTED);
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_CONNECTED);
+
+    link->sm.connected = false;
+    s = &link->sm.state;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMING_OUT);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMING_OUT);
+    link->sm.timed_out = true;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMED_OUT);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_TIMED_OUT);
+
+    sm = link->sm;
+    s = &sm.state;
+    *s = OSW_CQM_LINK_DECONFIGURED;
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_DISCONNECTED);
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_CONNECTED);
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_TIMING_OUT);
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_TIMED_OUT);
+
+    link->sm.connected = true;
+    s = &link->sm.state;
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_CONNECTED);
+    assert((*s = link_sm_next(&link->sm)) == OSW_CQM_LINK_CONNECTED);
+
+    sm = link->sm;
+    s = &sm.state;
+    *s = OSW_CQM_LINK_DECONFIGURED;
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_DISCONNECTED);
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_CONNECTED);
+    assert((*s = link_sm_next(&sm)) == OSW_CQM_LINK_CONNECTED);
+}
Index: core/src/lib/osw/src/osw_drv.c
===================================================================
--- core.orig/src/lib/osw/src/osw_drv.c
+++ core/src/lib/osw/src/osw_drv.c
@@ -2,11 +2,15 @@
 #include <module.h>
 #include <os.h>
 #include <os_time.h>
+#include <osw_time.h>
 #include <ev.h>
 #include <const.h>
+#include <osw_timer.h>
+#include <osw_drv_common.h>
 #include <osw_drv.h>
 #include "osw_drv_i.h"
 #include "osw_state_i.h"
+#include "osw_stats_i.h"
 
 /* TODO
  * - use macros to automate value/string/list comparisons for "is changed", along with dumping to logs/traces
@@ -54,6 +58,73 @@ static bool g_osw_drv_settled;
     } while (0)
 
 static void
+osw_drv_buf_free(struct osw_drv_buf *buf)
+{
+    FREE(buf->data);
+    buf->data = NULL;
+    buf->len = 0;
+}
+
+static void
+osw_drv_buf_set(struct osw_drv_buf *buf, const void *data, size_t len)
+{
+    osw_drv_buf_free(buf);
+    if (data == NULL) return;
+    if (len == 0) return;
+    buf->data = MEMNDUP(data, len);
+    buf->len = len;
+}
+
+static void
+osw_drv_buf_copy(struct osw_drv_buf *dst, const struct osw_drv_buf *src)
+{
+    osw_drv_buf_set(dst, src->data, src->len);
+}
+
+static bool
+osw_drv_buf_is_same(const struct osw_drv_buf *a,
+                    const struct osw_drv_buf *b)
+{
+    const void *o = a->data;
+    const void *n = b->data;
+
+    if (o == NULL && n == NULL) return true;
+    if (o == NULL && n != NULL) return false;
+    if (o != NULL && n == NULL) return false;
+    assert(o != NULL && n != NULL);
+    if (a->len != b->len) return false;
+    return memcmp(o, n, a->len) == 0 ? true : false;
+}
+
+static const char *
+osw_drv_vif_link_status_to_str(const enum osw_drv_vif_state_sta_link_status s)
+{
+    switch (s) {
+        case OSW_DRV_VIF_STATE_STA_LINK_UNKNOWN: return "unknown";
+        case OSW_DRV_VIF_STATE_STA_LINK_CONNECTED: return "connected";
+        case OSW_DRV_VIF_STATE_STA_LINK_CONNECTING: return "connecting";
+        case OSW_DRV_VIF_STATE_STA_LINK_DISCONNECTED: return "disconnected";
+    }
+    return "unknown";
+}
+
+static void
+osw_drv_frame_tx_desc_reset(struct osw_drv_frame_tx_desc *desc)
+{
+    assert(desc != NULL);
+
+    memset(&desc->phy_name, 0, sizeof(desc->phy_name));
+    memset(&desc->vif_name, 0, sizeof(desc->vif_name));
+    if (desc->frame_len > 0) FREE(desc->frame);
+    desc->frame_len = 0;
+    desc->state = OSW_DRV_FRAME_TX_STATE_UNUSED;
+    if (desc->list != NULL) {
+        ds_dlist_remove(desc->list, desc);
+        desc->list = NULL;
+    }
+}
+
+static void
 osw_drv_set_phy_list_valid(struct osw_drv *drv, bool valid)
 {
     if (drv->phy_list_valid == valid) return;
@@ -120,6 +191,8 @@ static void
 osw_drv_sta_free(struct osw_drv_sta *sta)
 {
     g_osw_drv_work_done = true;
+    osw_drv_buf_free(&sta->cur_ies);
+    osw_drv_buf_free(&sta->new_ies);
     ds_tree_remove(&sta->vif->sta_tree, sta);
     FREE(sta);
 }
@@ -150,6 +223,30 @@ osw_drv_sta_set_state(struct osw_drv_sta
     osw_drv_sta_assign_state(&sta->new_state, state);
 }
 
+static bool
+osw_drv_sta_request_state_vsta_override(struct osw_drv_sta *sta)
+{
+    struct osw_drv_vif *vif = sta->vif;
+    if (vif->vsta_root_ap == NULL) return false;
+
+    struct osw_drv_phy *phy = vif->phy;
+    struct osw_drv *drv = phy->drv;
+    const bool match = (osw_hwaddr_cmp(vif->vsta_root_ap, &sta->mac_addr) == 0);
+    const struct osw_drv_sta_state state = {
+        .connected = match,
+    };
+
+    LOGT("osw: drv: %s/%s/%s/"OSW_HWADDR_FMT": match=%d",
+         sta->vif->phy->drv->ops->name ?: "",
+         sta->vif->phy->phy_name,
+         sta->vif->vif_name,
+         OSW_HWADDR_ARG(&sta->mac_addr),
+         match);
+
+    osw_drv_report_sta_state(drv, phy->phy_name, vif->vif_name, &sta->mac_addr, &state);
+    return true;
+}
+
 static void
 osw_drv_sta_request_state(struct osw_drv_sta *sta)
 {
@@ -167,6 +264,7 @@ osw_drv_sta_request_state(struct osw_drv
     assert(drv->ops->request_sta_state_fn != NULL);
 
     osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_REQUESTED);
+    if (osw_drv_sta_request_state_vsta_override(sta) == true) return;
     drv->ops->request_sta_state_fn(drv, phy->phy_name, vif->vif_name, &sta->mac_addr);
 }
 
@@ -174,11 +272,13 @@ static bool
 osw_drv_sta_state_is_changed(const struct osw_drv_sta *sta)
 {
     bool changed = false;
-    bool changed_connected = sta->cur_state.connected != sta->new_state.connected;
-    bool changed_key_id = sta->cur_state.key_id != sta->new_state.key_id;
+    const bool changed_connected = sta->cur_state.connected != sta->new_state.connected;
+    const bool changed_key_id = sta->cur_state.key_id != sta->new_state.key_id;
+    const bool changed_ies = (osw_drv_buf_is_same(&sta->cur_ies, &sta->new_ies) == false);
 
     changed |= changed_connected;
     changed |= changed_key_id;
+    changed |= changed_ies;
 
     return changed;
 }
@@ -193,6 +293,7 @@ osw_drv_sta_process_state(struct osw_drv
     bool changed = sta->cur_state.connected == true
                 && sta->new_state.connected == true
                 && osw_drv_sta_state_is_changed(sta) == true;
+    const bool changed_ies = (osw_drv_buf_is_same(&sta->cur_ies, &sta->new_ies) == false);
 
     if (sta->cur_state.connected == true &&
         sta->new_state.connected == true &&
@@ -210,12 +311,15 @@ osw_drv_sta_process_state(struct osw_drv
         }
     }
 
+    osw_drv_buf_copy(&sta->cur_ies, &sta->new_ies);
     osw_drv_sta_assign_state(&sta->cur_state, &sta->new_state);
     osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_PROCESSED);
 
     sta->pub.mac_addr = &sta->mac_addr;
     sta->pub.vif = &sta->vif->pub;
     sta->pub.drv_state = &sta->cur_state;
+    sta->pub.assoc_req_ies = sta->cur_ies.data;
+    sta->pub.assoc_req_ies_len = sta->cur_ies.len;
 
     if (sta->cur_state.connected_duration_seconds != 0 || sta->pub.connected_at == 0) {
         sta->pub.connected_at = time_monotonic();
@@ -225,6 +329,30 @@ osw_drv_sta_process_state(struct osw_drv
     if (removed == true) OSW_STATE_NOTIFY(sta_disconnected_fn, &sta->pub);
     if (added == true) OSW_STATE_NOTIFY(sta_connected_fn, &sta->pub);
     if (changed == true) OSW_STATE_NOTIFY(sta_changed_fn, &sta->pub);
+
+    if (removed == true) {
+        LOGN("osw: drv: %s/%s/"OSW_HWADDR_FMT": disconnected",
+             sta->vif->phy->phy_name,
+             sta->vif->vif_name,
+             OSW_HWADDR_ARG(&sta->mac_addr));
+    }
+
+    if (added == true) {
+        LOGN("osw: drv: %s/%s/"OSW_HWADDR_FMT": connected",
+             sta->vif->phy->phy_name,
+             sta->vif->vif_name,
+             OSW_HWADDR_ARG(&sta->mac_addr));
+    }
+
+    if (added == true || changed == true) {
+        if (changed_ies == true) {
+            LOGI("osw: drv: %s/%s/"OSW_HWADDR_FMT": assoc ies available, len = %zu",
+                 sta->vif->phy->phy_name,
+                 sta->vif->vif_name,
+                 OSW_HWADDR_ARG(&sta->mac_addr),
+                 sta->pub.assoc_req_ies_len);
+        }
+    }
 }
 
 static void
@@ -264,6 +392,7 @@ osw_drv_sta_enumerate(struct osw_drv_vif
     struct osw_drv_phy *phy = vif->phy;
     struct osw_drv *drv = phy->drv;
     struct osw_drv_sta *sta;
+    const char *drv_name = drv->ops->name ?: "";
     const char *phy_name = phy->phy_name;
     const char *vif_name = vif->vif_name;
 
@@ -274,6 +403,14 @@ osw_drv_sta_enumerate(struct osw_drv_vif
 
     if (drv->unregistered == false) {
         drv->ops->get_sta_list_fn(drv, phy_name, vif_name, osw_drv_sta_enumerate_cb, vif);
+        if (vif->vsta_root_ap != NULL) {
+            LOGT("osw: drv %s/%s/%s: adding extra sta "OSW_HWADDR_FMT,
+                 drv_name,
+                 phy_name,
+                 vif_name,
+                 OSW_HWADDR_ARG(vif->vsta_root_ap));
+            osw_drv_sta_enumerate_cb(vif->vsta_root_ap, vif);
+        }
     }
 
     ds_tree_foreach(&vif->sta_tree, sta) {
@@ -398,7 +535,9 @@ osw_drv_vif_assign_state(struct osw_drv_
 {
     const struct osw_drv_vif_state zero = {0};
     const struct osw_drv_vif_state_ap *ap_src = &src->u.ap;
+    const struct osw_drv_vif_state_sta *sta_src = &src->u.sta;
     struct osw_drv_vif_state_ap *ap_dst = &dst->u.ap;
+    struct osw_drv_vif_state_sta *sta_dst = &dst->u.sta;
 
     if (src == NULL)
        src = &zero;
@@ -414,6 +553,11 @@ osw_drv_vif_assign_state(struct osw_drv_
         case OSW_VIF_AP_VLAN:
             break;
         case OSW_VIF_STA:
+            while (sta_dst->network != NULL) {
+                struct osw_drv_vif_sta_network *n = sta_dst->network->next;
+                FREE(sta_dst->network);
+                sta_dst->network = n;
+            }
             break;
     }
 
@@ -430,6 +574,16 @@ osw_drv_vif_assign_state(struct osw_drv_
         case OSW_VIF_AP_VLAN:
             break;
         case OSW_VIF_STA:
+            {
+                struct osw_drv_vif_sta_network **p = &sta_dst->network;
+                struct osw_drv_vif_sta_network *i;
+                for (i = sta_src->network; i != NULL; i = i->next) {
+                    *p = CALLOC(1, sizeof(**p));
+                    memcpy(*p, i, sizeof(*i));
+                    p = &(*p)->next;
+                    *p = NULL;
+                }
+            }
             break;
     }
 
@@ -469,16 +623,16 @@ osw_drv_vif_state_is_changed_ap(const st
     const struct osw_drv_vif_state_ap *n = &vif->new_state.u.ap;
 
     bool changed = false;
-    bool changed_bridge = strcmp(o->bridge_if_name.buf, n->bridge_if_name.buf) != 0;
-    bool changed_isolated = o->isolated != n->isolated;
-    bool changed_ssid_hidden = o->ssid_hidden != n->ssid_hidden;
-    bool changed_mcast2ucast = o->mcast2ucast != n->mcast2ucast;
-    bool changed_beacon_interval_tu = o->beacon_interval_tu != n->beacon_interval_tu;
-    bool changed_channel = memcmp(&o->channel, &n->channel, sizeof(o->channel));
-    bool changed_mode = memcmp(&o->mode, &n->mode, sizeof(o->mode));
-    bool changed_wpa = memcmp(&o->wpa, &n->wpa, sizeof(o->wpa));
-    bool changed_ssid = memcmp(&o->ssid, &n->ssid, sizeof(o->ssid));
-    bool changed_acl_policy = o->acl_policy != n->acl_policy;
+    const bool changed_bridge = strcmp(o->bridge_if_name.buf, n->bridge_if_name.buf) != 0;
+    const bool changed_isolated = o->isolated != n->isolated;
+    const bool changed_ssid_hidden = o->ssid_hidden != n->ssid_hidden;
+    const bool changed_mcast2ucast = o->mcast2ucast != n->mcast2ucast;
+    const bool changed_beacon_interval_tu = o->beacon_interval_tu != n->beacon_interval_tu;
+    const bool changed_channel = memcmp(&o->channel, &n->channel, sizeof(o->channel));
+    const bool changed_mode = memcmp(&o->mode, &n->mode, sizeof(o->mode));
+    const bool changed_wpa = memcmp(&o->wpa, &n->wpa, sizeof(o->wpa));
+    const bool changed_ssid = memcmp(&o->ssid, &n->ssid, sizeof(o->ssid));
+    const bool changed_acl_policy = o->acl_policy != n->acl_policy;
     bool changed_acl = false;
     bool changed_psk = false;
 
@@ -585,11 +739,139 @@ osw_drv_vif_state_is_changed_ap_vlan(con
     return changed;
 }
 
+static int
+osw_drv_vif_sta_network_cmp(const struct osw_drv_vif_sta_network *a,
+                            const struct osw_drv_vif_sta_network *b)
+{
+    int r;
+
+    r = osw_hwaddr_cmp(&a->bssid, &b->bssid);
+    if (r != 0) return r;
+
+    r = a->ssid.len - b->ssid.len;
+    if (r != 0) return r;
+
+    r = memcmp(a->ssid.buf, b->ssid.buf, a->ssid.len);
+    if (r != 0) return r;
+
+    r = strncmp(a->psk.str, b->psk.str, sizeof(a->psk.str));
+    if (r != 0) return r;
+
+    r = memcmp(&a->wpa, &b->wpa, sizeof(a->wpa));
+    if (r != 0) return r;
+
+    return 0;
+
+}
 static bool
-osw_drv_vif_state_is_changed_sta(const struct osw_drv_vif *vif)
+osw_drv_vif_state_is_changed_sta_networks(const struct osw_drv_vif *vif)
 {
+    struct osw_drv_vif_sta_network *o = vif->cur_state.u.sta.network;
+    struct osw_drv_vif_sta_network *n = vif->new_state.u.sta.network;
+    struct osw_drv_vif_sta_network *i;
     bool changed = false;
-    /* TODO */
+
+    for (i = o; i != NULL; i = i->next) {
+        struct osw_drv_vif_sta_network *j;
+
+        for (j = n; j != NULL; j = j->next) {
+            if (osw_drv_vif_sta_network_cmp(i, j) == 0)
+                break;
+        }
+
+        const bool found = (j != NULL);
+        if (found == false) {
+            const size_t psk_len = strnlen(i->psk.str, sizeof(i->psk.str));
+            char wpa_str[64];
+            osw_wpa_to_str(wpa_str, sizeof(wpa_str), &i->wpa);
+            LOGI("osw: drv: %s/%s: network: removed: "OSW_SSID_FMT"/"OSW_HWADDR_FMT"/len=%zu/%s",
+                 vif->phy->phy_name,
+                 vif->vif_name,
+                 OSW_SSID_ARG(&i->ssid),
+                 OSW_HWADDR_ARG(&i->bssid),
+                 psk_len,
+                 wpa_str);
+            changed = true;
+        }
+    }
+
+    for (i = n; i != NULL; i = i->next) {
+        struct osw_drv_vif_sta_network *j;
+
+        for (j = o; j != NULL; j = j->next) {
+            if (osw_drv_vif_sta_network_cmp(i, j) == 0)
+                break;
+        }
+
+        const bool found = (j != NULL);
+        if (found == false) {
+            const size_t psk_len = strnlen(i->psk.str, sizeof(i->psk.str));
+            char wpa_str[64];
+            osw_wpa_to_str(wpa_str, sizeof(wpa_str), &i->wpa);
+            LOGI("osw: drv: %s/%s: network: added: "OSW_SSID_FMT"/"OSW_HWADDR_FMT"/len=%zu/%s",
+                 vif->phy->phy_name,
+                 vif->vif_name,
+                 OSW_SSID_ARG(&i->ssid),
+                 OSW_HWADDR_ARG(&i->bssid),
+                 psk_len,
+                 wpa_str);
+            changed = true;
+        }
+    }
+
+    return changed;
+}
+
+static bool
+osw_drv_vif_state_is_changed_sta(const struct osw_drv_vif *vif)
+{
+    const char *vif_name = vif->vif_name;
+    const char *phy_name = vif->phy->phy_name;
+
+    const struct osw_drv_vif_state_sta *o = &vif->cur_state.u.sta;
+    const struct osw_drv_vif_state_sta *n = &vif->new_state.u.sta;
+
+    const bool changed_status = o->link.status != n->link.status;
+    const bool changed_ssid = osw_ssid_cmp(&o->link.ssid, &n->link.ssid);
+    const bool changed_bssid = osw_hwaddr_cmp(&o->link.bssid, &n->link.bssid);
+    const bool changed_psk = strcmp(o->link.psk.str, n->link.psk.str) != 0;
+    const bool changed_wpa = memcmp(&o->link.wpa, &n->link.wpa, sizeof(n->link.wpa));
+    const bool changed_networks = osw_drv_vif_state_is_changed_sta_networks(vif);
+
+    if (changed_status == true) {
+        const char *from = osw_drv_vif_link_status_to_str(o->link.status);
+        const char *to = osw_drv_vif_link_status_to_str(n->link.status);
+        LOGN("osw: drv: %s/%s: link %s -> %s", phy_name, vif_name, from, to);
+    }
+
+    if (changed_ssid == true) {
+        const struct osw_ssid *from = &o->link.ssid;
+        const struct osw_ssid *to = &n->link.ssid;
+        LOGI("osw: drv: %s/%s: ssid "OSW_SSID_FMT" -> "OSW_SSID_FMT,
+             phy_name, vif_name,
+             OSW_SSID_ARG(from), OSW_SSID_ARG(to));
+    }
+
+    if (changed_bssid == true) {
+        const struct osw_hwaddr *from = &o->link.bssid;
+        const struct osw_hwaddr *to = &n->link.bssid;
+        LOGI("osw: drv: %s/%s: bssid "OSW_HWADDR_FMT" -> "OSW_HWADDR_FMT,
+             phy_name, vif_name,
+             OSW_HWADDR_ARG(from), OSW_HWADDR_ARG(to));
+    }
+
+    //FIXME: add channel
+
+    /* FIXME: print out other attribute changes: wpa, psk */
+
+    const bool changed = false
+                       | changed_networks
+                       | changed_status
+                       | changed_ssid
+                       | changed_bssid
+                       | changed_psk
+                       | changed_wpa;
+
     return changed;
 }
 
@@ -597,11 +879,11 @@ static bool
 osw_drv_vif_state_is_changed(const struct osw_drv_vif *vif)
 {
     bool changed = false;
-    bool changed_enabled = vif->cur_state.enabled != vif->new_state.enabled;
-    bool changed_vif_type = vif->cur_state.vif_type != vif->new_state.vif_type;
-    bool changed_mac_addr = memcmp(&vif->cur_state.mac_addr,
-                                   &vif->new_state.mac_addr,
-                                   sizeof(vif->new_state.mac_addr));
+    const bool changed_enabled = vif->cur_state.enabled != vif->new_state.enabled;
+    const bool changed_vif_type = vif->cur_state.vif_type != vif->new_state.vif_type;
+    const bool changed_mac_addr = memcmp(&vif->cur_state.mac_addr,
+                                         &vif->new_state.mac_addr,
+                                         sizeof(vif->new_state.mac_addr));
 
     changed |= changed_enabled;
     changed |= changed_vif_type;
@@ -627,15 +909,54 @@ osw_drv_vif_state_is_changed(const struc
 }
 
 static void
+osw_drv_vif_process_state_vsta(struct osw_drv_vif *vif)
+{
+    const bool was_vsta = (vif->cur_state.exists == false ||
+                           vif->cur_state.vif_type == OSW_VIF_STA);
+    const bool is_vsta = (vif->new_state.vif_type == OSW_VIF_STA);
+    const struct osw_drv_vif_state_sta *o = was_vsta ? &vif->cur_state.u.sta : NULL;
+    const struct osw_drv_vif_state_sta *n = is_vsta ? &vif->new_state.u.sta : NULL;
+    const bool was_connected = o != NULL && o->link.status == OSW_DRV_VIF_STATE_STA_LINK_CONNECTED;
+    const bool is_connected = n != NULL && n->link.status == OSW_DRV_VIF_STATE_STA_LINK_CONNECTED;
+    const struct osw_hwaddr *vsta_root_ap = is_connected == true
+                                          ? &vif->new_state.u.sta.link.bssid
+                                          : NULL;
+    struct osw_drv_phy *phy = vif->phy;
+    struct osw_drv *drv = phy->drv;
+    const char *drv_name = drv->ops->name ?: "";
+    const char *phy_name = phy->phy_name;
+    const char *vif_name = vif->vif_name;
+    const struct osw_hwaddr zero = {0};
+
+    if (was_connected == is_connected) return;
+    if (vif->vsta_root_ap == vsta_root_ap) return;
+
+    LOGD("osw: drv: %s/%s/%s: setting vsta_root_ap from "OSW_HWADDR_FMT" to "OSW_HWADDR_FMT,
+         drv_name,
+         phy_name,
+         vif_name,
+         OSW_HWADDR_ARG(vif->vsta_root_ap ?: &zero),
+         OSW_HWADDR_ARG(vsta_root_ap ?: &zero));
+
+    vif->vsta_root_ap = vsta_root_ap;
+    osw_drv_vif_set_sta_list_valid(vif, false);
+    if (vsta_root_ap != NULL) {
+        osw_drv_report_sta_changed(drv, phy_name, vif_name, vsta_root_ap);
+    }
+}
+
+static void
 osw_drv_vif_process_state(struct osw_drv_vif *vif)
 {
-    bool added = vif->cur_state.exists == false
-              && vif->new_state.exists == true;
-    bool removed = vif->cur_state.exists == true
-                && vif->new_state.exists == false;
-    bool changed = vif->cur_state.exists == true
-                && vif->new_state.exists == true
-                && osw_drv_vif_state_is_changed(vif) == true;
+    const bool added = vif->cur_state.exists == false
+                    && vif->new_state.exists == true;
+    const bool removed = vif->cur_state.exists == true
+                      && vif->new_state.exists == false;
+    const bool changed = vif->cur_state.exists == true
+                      && vif->new_state.exists == true
+                      && osw_drv_vif_state_is_changed(vif) == true;
+
+    osw_drv_vif_process_state_vsta(vif);
 
     if (removed == true) {
         if (osw_drv_vif_stas_are_settled(vif) == false) {
@@ -732,6 +1053,52 @@ osw_drv_vif_enumerate(struct osw_drv_phy
     }
 }
 
+static const struct osw_channel *
+osw_drv_vif_get_channel(const struct osw_drv_vif *vif)
+{
+    const struct osw_drv_vif_state_ap *vap = &vif->cur_state.u.ap;
+    const struct osw_drv_vif_state_sta *vsta = &vif->cur_state.u.sta;
+    const enum osw_drv_vif_state_sta_link_status status = vsta->link.status;
+
+    if (vif->cur_state.enabled == false) return NULL;
+
+    switch (vif->cur_state.vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP_VLAN:
+            /* This makes no sense, really. Even if,
+             * this would need to look at the AP vif
+             * associated with it.
+             */
+            WARN_ON(1);
+            break;
+        case OSW_VIF_AP:
+            return &vap->channel;
+        case OSW_VIF_STA:
+            if (status != OSW_DRV_VIF_STATE_STA_LINK_CONNECTED) break;
+            return &vsta->link.channel;
+    }
+
+    return NULL;
+}
+
+static struct osw_drv_vif *
+osw_drv_vif_lookup_by_name(const char *phy_name, const char *vif_name)
+{
+    struct osw_drv *drv;
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+        if (phy == NULL) continue;
+
+        struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
+        if (vif == NULL) continue;
+
+        return vif;
+    }
+
+    return NULL;
+}
+
 static void
 osw_drv_phy_assert_unique(const char *phy_name)
 {
@@ -837,16 +1204,79 @@ osw_drv_phy_request_state(struct osw_drv
 }
 
 static bool
+osw_drv_phy_state_is_channels_changed(const struct osw_drv_phy *phy)
+{
+    const struct osw_drv_phy_state *o = &phy->cur_state;
+    const struct osw_drv_phy_state *n = &phy->new_state;
+    bool changed = false;
+    const size_t size = sizeof(struct osw_channel);
+
+    size_t i;
+    for (i = 0; i < o->n_channel_states; i++) {
+        const struct osw_channel_state *os = &o->channel_states[i];
+        const struct osw_channel_state *ns = NULL;
+        size_t j;
+        for (j = 0; j < n->n_channel_states; j++) {
+            ns = &n->channel_states[j];
+            if (memcmp(os, ns, size) == 0) break;
+        }
+        const bool found = ns != NULL && (j < n->n_channel_states);
+        if (found == true) {
+            const bool dfs_changed = (os->dfs_state != ns->dfs_state);
+            const bool nol_changed = (os->dfs_nol_remaining_seconds != ns->dfs_nol_remaining_seconds);
+            const bool cs_changed = dfs_changed || nol_changed;
+            changed |= cs_changed;
+            if (cs_changed == true) {
+                LOGI("osw: drv: %s: channel "OSW_CHANNEL_FMT": "OSW_CHAN_STATE_FMT" -> "OSW_CHAN_STATE_FMT,
+                     phy->phy_name,
+                     OSW_CHANNEL_ARG(&ns->channel),
+                     OSW_CHAN_STATE_ARG(os),
+                     OSW_CHAN_STATE_ARG(ns));
+            }
+        }
+        else {
+            LOGI("osw: drv: %s: channel "OSW_CHANNEL_FMT": "OSW_CHAN_STATE_FMT" -> ()",
+                 phy->phy_name,
+                 OSW_CHANNEL_ARG(&ns->channel),
+                 OSW_CHAN_STATE_ARG(os));
+            changed = true;
+        }
+    }
+
+    for (i = 0; i < n->n_channel_states; i++) {
+        const struct osw_channel_state *ns = &n->channel_states[i];
+        const struct osw_channel_state *os = NULL;
+        size_t j;
+        for (j = 0; j < o->n_channel_states; j++) {
+            os = &o->channel_states[j];
+            if (memcmp(os, ns, size) == 0) break;
+        }
+        const bool found = os != NULL && (j < o->n_channel_states);
+        if (found == false) {
+            LOGI("osw: drv: %s: channel "OSW_CHANNEL_FMT": "OSW_CHAN_STATE_FMT" -> ()",
+                 phy->phy_name,
+                 OSW_CHANNEL_ARG(&ns->channel),
+                 OSW_CHAN_STATE_ARG(os));
+            changed = true;
+        }
+    }
+
+    return changed;
+}
+
+static bool
 osw_drv_phy_state_is_changed(const struct osw_drv_phy *phy)
 {
     bool changed = false;
-    bool changed_enabled = phy->cur_state.enabled != phy->new_state.enabled;
-    bool changed_tx_chainmask = phy->cur_state.tx_chainmask != phy->new_state.tx_chainmask;
-    bool changed_radar = phy->cur_state.radar != phy->new_state.radar;
+    const bool changed_enabled = phy->cur_state.enabled != phy->new_state.enabled;
+    const bool changed_tx_chainmask = phy->cur_state.tx_chainmask != phy->new_state.tx_chainmask;
+    const bool changed_radar = phy->cur_state.radar != phy->new_state.radar;
+    const bool changed_channels = osw_drv_phy_state_is_channels_changed(phy);
 
     changed |= changed_enabled;
     changed |= changed_tx_chainmask;
     changed |= changed_radar;
+    changed |= changed_channels;
 
     // FIXME: Add missing field checks
 
@@ -856,13 +1286,13 @@ osw_drv_phy_state_is_changed(const struc
 static void
 osw_drv_phy_process_state(struct osw_drv_phy *phy)
 {
-    bool added = phy->cur_state.exists == false
-              && phy->new_state.exists == true;
-    bool removed = phy->cur_state.exists == true
-                && phy->new_state.exists == false;
-    bool changed = phy->cur_state.exists == true
-                && phy->new_state.exists == true
-                && osw_drv_phy_state_is_changed(phy) == true;
+    const bool added = phy->cur_state.exists == false
+                    && phy->new_state.exists == true;
+    const bool removed = phy->cur_state.exists == true
+                      && phy->new_state.exists == false;
+    const bool changed = phy->cur_state.exists == true
+                      && phy->new_state.exists == true
+                      && osw_drv_phy_state_is_changed(phy) == true;
 
     if (removed == true) {
         if (osw_drv_phy_vifs_are_settled(phy) == false) {
@@ -922,6 +1352,103 @@ osw_drv_phy_work(struct osw_drv_phy *phy
 }
 
 static void
+osw_drv_frame_tx_drop_orphaned_frames(struct osw_drv *drv)
+{
+    assert(drv != NULL);
+
+    struct osw_drv_frame_tx_desc *desc;
+    struct osw_drv_frame_tx_desc *tmp;
+
+    ds_dlist_foreach_safe(&drv->frame_tx_list, desc, tmp) {
+        struct osw_drv_phy *phy = NULL;
+        struct osw_drv_vif *vif = NULL;
+        const char *vif_name = NULL;
+
+        if (desc->state != OSW_DRV_FRAME_TX_STATE_PENDING)
+            continue;
+
+        phy = ds_tree_find(&drv->phy_tree, desc->phy_name.buf);
+        if (phy == NULL || phy->cur_state.exists == false) {
+            if (desc->result_fn != NULL)
+                desc->result_fn(desc, OSW_FRAME_TX_RESULT_DROPPED, desc->caller_priv);
+
+            osw_drv_frame_tx_desc_reset(desc);
+            continue;
+        }
+
+        vif_name = strlen(desc->vif_name.buf) > 0 ? desc->vif_name.buf : NULL;
+        if (vif_name == NULL)
+            continue;
+
+        vif = ds_tree_find(&phy->vif_tree, vif_name);
+        if (vif == NULL || vif->cur_state.exists == false) {
+            if (desc->result_fn != NULL)
+                desc->result_fn(desc, OSW_FRAME_TX_RESULT_DROPPED, desc->caller_priv);
+
+            osw_drv_frame_tx_desc_reset(desc);
+            continue;
+        }
+    }
+}
+
+static void
+osw_drv_frame_tx_process_frames(struct osw_drv *drv)
+{
+    assert(drv != NULL);
+
+    while (ds_dlist_is_empty(&drv->frame_tx_list) == false) {
+        struct osw_drv_frame_tx_desc *desc = ds_dlist_head(&drv->frame_tx_list);
+        const char *vif_name = NULL;
+
+        switch (desc->state) {
+            case OSW_DRV_FRAME_TX_STATE_UNUSED:
+                LOGD("osw: drv: unused frame tx on pedning list, resetting frame");
+                goto reset_desc;
+            case OSW_DRV_FRAME_TX_STATE_PENDING:
+                vif_name = strlen(desc->vif_name.buf) > 0 ? desc->vif_name.buf : NULL;
+                assert(drv->ops->push_frame_tx_fn != NULL);
+                drv->ops->push_frame_tx_fn(drv, desc->phy_name.buf, vif_name, desc);
+                break;
+            case OSW_DRV_FRAME_TX_STATE_SUBMITTED:
+            case OSW_DRV_FRAME_TX_STATE_FAILED:
+                LOGD("osw: drv: submitted/failed frame tx at the beginning of pedning list, resetting frame");
+                goto reset_desc;
+        }
+
+        switch (desc->state) {
+            case OSW_DRV_FRAME_TX_STATE_UNUSED:
+                LOGD("osw: drv: frame tx set to 'unused' state after push, resetting frame");
+                break;
+            case OSW_DRV_FRAME_TX_STATE_PENDING:
+                LOGD("osw: drv: frame tx remain in 'pending' state after push, dropping frame");
+                if (desc->result_fn != NULL)
+                    desc->result_fn(desc, OSW_FRAME_TX_RESULT_DROPPED, desc->caller_priv);
+                break;
+            case OSW_DRV_FRAME_TX_STATE_SUBMITTED:
+                if (desc->result_fn != NULL)
+                    desc->result_fn(desc, OSW_FRAME_TX_RESULT_SUBMITTED, desc->caller_priv);
+                break;
+            case OSW_DRV_FRAME_TX_STATE_FAILED:
+                if (desc->result_fn != NULL)
+                    desc->result_fn(desc, OSW_FRAME_TX_RESULT_FAILED, desc->caller_priv);
+                break;
+        }
+
+        reset_desc:
+            osw_drv_frame_tx_desc_reset(desc);
+    }
+}
+
+static void
+osw_drv_frame_tx_work(struct osw_drv *drv)
+{
+    assert(drv != NULL);
+
+    osw_drv_frame_tx_drop_orphaned_frames(drv);
+    osw_drv_frame_tx_process_frames(drv);
+}
+
+static void
 osw_drv_phy_enumerate_cb(const char *phy_name, void *data)
 {
     struct osw_drv_phy *phy = osw_drv_phy_get(data, phy_name);
@@ -952,6 +1479,16 @@ osw_drv_phy_enumerate(struct osw_drv *dr
 static void
 osw_drv_free(struct osw_drv *drv)
 {
+    struct osw_drv_frame_tx_desc *desc;
+    struct osw_drv_frame_tx_desc *tmp;
+
+    ds_dlist_foreach_safe(&drv->frame_tx_list, desc, tmp) {
+        if (desc->result_fn != NULL)
+            desc->result_fn(desc, OSW_FRAME_TX_RESULT_DROPPED, desc->caller_priv);
+
+        ds_dlist_remove(&drv->frame_tx_list, desc);
+    }
+
     g_osw_drv_work_done = true;
     ds_tree_remove(&g_osw_drv_tree, drv);
     FREE(drv);
@@ -1055,6 +1592,9 @@ osw_drv_work_all(void)
             ev_timer_again(EV_DEFAULT_ &g_osw_drv_work_watchdog);
     } else {
         ev_timer_stop(EV_DEFAULT_ &g_osw_drv_work_watchdog);
+
+        ds_tree_foreach(&g_osw_drv_tree, drv)
+            osw_drv_frame_tx_work(drv);
     }
 
     if (was_settled == false && is_settled == true) OSW_STATE_NOTIFY(idle_fn);
@@ -1142,22 +1682,95 @@ osw_drv_work_all_watchdog_cb(EV_P_ ev_ti
     osw_drv_work_all_schedule();
 }
 
-void
-osw_drv_report_phy_state(struct osw_drv *drv,
-                         const char *phy_name,
-                         const struct osw_drv_phy_state *state)
+static struct osw_drv_phy *
+osw_drv_phy_from_report(struct osw_drv *drv,
+                       const char *phy_name)
 {
-    if (drv == NULL) return;
-    if (drv->unregistered == true) return;
+    if (WARN_ON(drv == NULL)) return NULL;
+    if (drv->unregistered == true) return NULL;
+    if (WARN_ON(phy_name == NULL)) return NULL;
 
     struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
     if (phy == NULL) {
         osw_drv_set_phy_list_valid(drv, false);
+        phy = osw_drv_phy_get(drv, phy_name);
+    }
+
+    return phy;
+}
+
+static struct osw_drv_vif *
+osw_drv_vif_from_report(struct osw_drv *drv,
+                        const char *phy_name,
+                        const char *vif_name)
+{
+    if (WARN_ON(drv == NULL)) return NULL;
+    if (WARN_ON(vif_name == NULL)) return NULL;
+
+    struct osw_drv_phy *phy = osw_drv_phy_from_report(drv, phy_name);
+    if (WARN_ON(phy == NULL)) return NULL;
+
+    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
+    if (vif == NULL) {
+        osw_drv_phy_set_vif_list_valid(phy, false);
+        vif = osw_drv_vif_get(phy, vif_name);
+    }
+
+    return vif;
+}
+
+static struct osw_drv_sta *
+osw_drv_sta_from_report(struct osw_drv *drv,
+                        const char *phy_name,
+                        const char *vif_name,
+                        const struct osw_hwaddr *sta_addr)
+{
+    if (WARN_ON(drv == NULL)) return NULL;
+    if (WARN_ON(sta_addr == NULL)) return NULL;
+
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (WARN_ON(vif == NULL)) return NULL;
+
+    struct osw_drv_sta *sta = ds_tree_find(&vif->sta_tree, sta_addr);
+    if (sta == NULL) {
+        osw_drv_vif_set_sta_list_valid(vif, false);
+        sta = osw_drv_sta_get(vif, sta_addr);
+    }
+
+    return sta;
+}
+
+static void
+osw_drv_report_frame_tx_state(struct osw_drv *drv,
+                              enum osw_drv_frame_tx_desc_state state)
+{
+    assert(drv != NULL);
+    assert(state == OSW_DRV_FRAME_TX_STATE_SUBMITTED || state == OSW_DRV_FRAME_TX_STATE_FAILED);
+
+    struct osw_drv_frame_tx_desc *desc = NULL;
+
+    desc = ds_dlist_head(&drv->frame_tx_list);
+    if (desc == NULL) {
+        LOGD("osw: drv: drv reported state for nonexistent frame tx");
         return;
     }
 
-    if (phy->obj.state != OSW_DRV_OBJ_REQUESTED)
+    if (desc->state != OSW_DRV_FRAME_TX_STATE_PENDING) {
+        LOGD("osw: drv: drv reported state for non-'pending' frame tx");
         return;
+    }
+
+    desc->state = state;
+}
+
+void
+osw_drv_report_phy_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const struct osw_drv_phy_state *state)
+{
+    struct osw_drv_phy *phy = osw_drv_phy_from_report(drv, phy_name);
+    if (WARN_ON(phy == NULL)) return;
+    if (phy->obj.state != OSW_DRV_OBJ_REQUESTED) return;
 
     osw_drv_phy_set_state(phy, state->exists ? state : NULL);
     osw_drv_work_all_schedule();
@@ -1167,14 +1780,8 @@ void
 osw_drv_report_phy_changed(struct osw_drv *drv,
                            const char *phy_name)
 {
-    if (drv == NULL) return;
-    if (drv->unregistered == true) return;
-
-    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
-    if (phy == NULL) {
-        osw_drv_set_phy_list_valid(drv, false);
-        return;
-    }
+    struct osw_drv_phy *phy = osw_drv_phy_from_report(drv, phy_name);
+    if (WARN_ON(phy == NULL)) return;
 
     osw_drv_obj_set_state(&phy->obj, OSW_DRV_OBJ_INVALID);
     osw_drv_work_all_schedule();
@@ -1186,23 +1793,11 @@ osw_drv_report_vif_state(struct osw_drv
                          const char *vif_name,
                          const struct osw_drv_vif_state *state)
 {
-    if (drv == NULL) return;
-    if (drv->unregistered == true) return;
+    if (WARN_ON(state == NULL)) return;
 
-    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
-    if (phy == NULL) {
-        osw_drv_set_phy_list_valid(drv, false);
-        return;
-    }
-
-    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
-    if (vif == NULL) {
-        osw_drv_phy_set_vif_list_valid(phy, false);
-        return;
-    }
-
-    if (vif->obj.state != OSW_DRV_OBJ_REQUESTED)
-        return;
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (WARN_ON(vif == NULL)) return;
+    if (vif->obj.state != OSW_DRV_OBJ_REQUESTED) return;
 
     osw_drv_vif_set_state(vif, state->exists ? state : NULL);
     osw_drv_work_all_schedule();
@@ -1213,20 +1808,47 @@ osw_drv_report_vif_changed(struct osw_dr
                            const char *phy_name,
                            const char *vif_name)
 {
-    if (drv == NULL) return;
-    if (drv->unregistered == true) return;
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (WARN_ON(vif == NULL)) return;
 
-    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
-    if (phy == NULL) {
-        osw_drv_set_phy_list_valid(drv, false);
-        return;
-    }
+    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
+    osw_drv_work_all_schedule();
+}
 
-    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
-    if (vif == NULL) {
-        osw_drv_phy_set_vif_list_valid(phy, false);
-        return;
-    }
+void
+osw_drv_report_vif_connected(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_ssid *ssid,
+                             const struct osw_hwaddr *bssid)
+{
+    if (WARN_ON(ssid == NULL)) return;
+    if (WARN_ON(bssid == NULL)) return;
+
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (WARN_ON(vif == NULL)) return;
+
+    memset(&vif->ssid, 0, sizeof(vif->ssid));
+    memset(&vif->bssid, 0, sizeof(vif->bssid));
+    if (ssid != NULL) memcpy(&vif->ssid, ssid, sizeof(*ssid));
+    if (bssid != NULL) memcpy(&vif->bssid, bssid, sizeof(*bssid));
+    vif->connected = true;
+
+    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_vif_disconnected(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name)
+{
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (WARN_ON(vif == NULL)) return;
+
+    memset(&vif->ssid, 0, sizeof(vif->ssid));
+    memset(&vif->bssid, 0, sizeof(vif->bssid));
+    vif->connected = false;
 
     osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
     osw_drv_work_all_schedule();
@@ -1238,20 +1860,10 @@ osw_drv_report_vif_channel_change_starte
                                           const char *vif_name,
                                           const struct osw_channel *target_channel)
 {
-    if (drv == NULL) return;
-    if (drv->unregistered == true) return;
+    if (WARN_ON(target_channel == NULL)) return;
 
-    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
-    if (phy == NULL) {
-        osw_drv_set_phy_list_valid(drv, false);
-        phy = osw_drv_phy_get(drv, phy_name);
-    }
-
-    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
-    if (vif == NULL) {
-        osw_drv_phy_set_vif_list_valid(phy, false);
-        vif = osw_drv_vif_get(phy, vif_name);
-    }
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (WARN_ON(vif == NULL)) return;
 
     osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
 
@@ -1259,118 +1871,182 @@ osw_drv_report_vif_channel_change_starte
         vif->csa_channel = *target_channel;
 }
 
-void
-osw_drv_report_sta_state(struct osw_drv *drv,
-                         const char *phy_name,
-                         const char *vif_name,
-                         const struct osw_hwaddr *mac_addr,
-                         const struct osw_drv_sta_state *state)
+static bool
+osw_drv_phy_supports_channel(const struct osw_drv_phy *phy,
+                             const struct osw_channel *c)
 {
-    if (drv == NULL) return;
-    if (drv->unregistered == true) return;
-
-    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
-    if (phy == NULL) {
-        osw_drv_set_phy_list_valid(drv, false);
-        return;
+    const struct osw_channel_state *arr = phy->cur_state.channel_states;
+    const size_t n = phy->cur_state.n_channel_states;
+    size_t i;
+    for (i = 0; i < n; i++) {
+        const struct osw_channel *c2 = &arr[i].channel;
+        /* FIXME: This should verify if the width is also
+         * doable by checking adjacent channels. *
+         */
+        if (c2->control_freq_mhz == c->control_freq_mhz)
+            return true;
     }
+    return false;
+}
 
-    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
-    if (vif == NULL) {
-        osw_drv_phy_set_vif_list_valid(phy, false);
-        return;
+static struct osw_drv_phy *
+osw_drv_phy_lookup_for_channel(struct ds_tree *drvs,
+                               const struct osw_channel *c)
+{
+    struct osw_drv *drv;
+    ds_tree_foreach(drvs, drv) {
+        struct osw_drv_phy *phy;
+        ds_tree_foreach(&drv->phy_tree, phy) {
+            if (osw_drv_phy_supports_channel(phy, c) == true) {
+                return phy;
+            }
+        }
     }
+    return NULL;
+}
 
-    struct osw_drv_sta *sta = ds_tree_find(&vif->sta_tree, mac_addr);
-    if (sta == NULL) {
-        osw_drv_vif_set_sta_list_valid(vif, false);
-        return;
-    }
+static void
+osw_drv_report_vif_channel_change_advertised_xphy__(struct ds_tree *drvs,
+                                                    struct osw_drv *drv,
+                                                    const char *phy_name,
+                                                    const char *vif_name,
+                                                    const struct osw_channel *channel,
+                                                    struct osw_drv_phy **phy,
+                                                    struct osw_drv_vif **vif)
+{
+    *phy = NULL;
+    *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (*vif == NULL) return;
 
-    if (sta->obj.state != OSW_DRV_OBJ_REQUESTED)
-        return;
+    osw_drv_obj_set_state(&vif[0]->obj, OSW_DRV_OBJ_INVALID);
 
-    osw_drv_sta_set_state(sta, state->connected ? state : NULL);
-    osw_drv_work_all_schedule();
+    if (vif[0]->cur_state.vif_type != OSW_VIF_STA) return;
+    if (channel == NULL) return;
+
+    *phy = osw_drv_phy_lookup_for_channel(drvs, channel);
 }
 
 void
-osw_drv_report_sta_changed(struct osw_drv *drv,
-                           const char *phy_name,
-                           const char *vif_name,
-                           const struct osw_hwaddr *mac_addr)
+osw_drv_report_vif_channel_change_advertised_xphy(struct osw_drv *drv,
+                                                  const char *phy_name,
+                                                  const char *vif_name,
+                                                  const struct osw_channel *channel)
 {
-    if (drv == NULL) return;
-    if (drv->unregistered == true) return;
+    struct ds_tree *drvs = &g_osw_drv_tree;
+    struct osw_drv_phy *phy_reported = osw_drv_phy_from_report(drv, phy_name);
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
 
-    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (WARN_ON(channel == NULL)) return;
+
+    osw_drv_report_vif_channel_change_advertised_xphy__(drvs, drv, phy_name, vif_name, channel, &phy, &vif);
     if (phy == NULL) {
-        osw_drv_set_phy_list_valid(drv, false);
+        LOGI("osw: drv: %s/%s/%s: csa: "OSW_CHANNEL_FMT": cannot switch; no phy is capable",
+                drv->ops->name,
+                phy_name,
+                vif_name,
+                OSW_CHANNEL_ARG(channel));
         return;
     }
-
-    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
-    if (vif == NULL) {
-        osw_drv_phy_set_vif_list_valid(phy, false);
+    if (phy_reported == phy) {
+        LOGD("osw: drv: %s/%s/%s: csa: "OSW_CHANNEL_FMT": not a cross-phy switch",
+             drv->ops->name,
+             phy_name,
+             vif_name,
+             OSW_CHANNEL_ARG(channel));
         return;
     }
 
-    struct osw_drv_sta *sta = ds_tree_find(&vif->sta_tree, mac_addr);
-    if (sta == NULL) {
-        osw_drv_vif_set_sta_list_valid(vif, false);
-        return;
-    }
+    if (vif->cur_state.exists == false) return;
+    if (phy->cur_state.exists == false) return;
+    if (vif->cur_state.vif_type != OSW_VIF_STA) return;
 
-    osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_INVALID);
-    osw_drv_work_all_schedule();
+    OSW_STATE_NOTIFY(vif_csa_to_phy_fn, &vif->pub, &phy->pub, channel);
+}
+
+static void
+osw_drv_report_vif_channel_change_advertised_onphy(struct osw_drv *drv,
+                                                   const char *phy_name,
+                                                   const char *vif_name,
+                                                   const struct osw_channel *channel)
+{
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (vif->cur_state.exists == false) return;
+    if (vif->cur_state.vif_type != OSW_VIF_STA) return;
+    OSW_STATE_NOTIFY(vif_csa_rx_fn, &vif->pub, channel);
 }
 
 void
-osw_drv_report_sta_connected(struct osw_drv *drv,
-                             const char *phy_name,
-                             const char *vif_name,
-                             const struct osw_hwaddr *mac_addr)
+osw_drv_report_vif_channel_change_advertised(struct osw_drv *drv,
+                                             const char *phy_name,
+                                             const char *vif_name,
+                                             const struct osw_channel *channel)
 {
-    /* TODO */
+    osw_drv_report_vif_channel_change_advertised_onphy(drv, phy_name, vif_name, channel);
+    osw_drv_report_vif_channel_change_advertised_xphy(drv, phy_name, vif_name, channel);
 }
 
 void
-osw_drv_report_sta_disconnected(struct osw_drv *drv,
-                                const char *phy_name,
-                                const char *vif_name,
-                                const struct osw_hwaddr *mac_addr)
+osw_drv_report_sta_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const char *vif_name,
+                         const struct osw_hwaddr *mac_addr,
+                         const struct osw_drv_sta_state *state)
 {
-    /* TODO */
+    struct osw_drv_sta *sta = osw_drv_sta_from_report(drv, phy_name, vif_name, mac_addr);
+    if (WARN_ON(sta == NULL)) return;
+    if (sta->obj.state != OSW_DRV_OBJ_REQUESTED) return;
+
+    osw_drv_sta_set_state(sta, state->connected ? state : NULL);
+    osw_drv_work_all_schedule();
 }
 
 void
-osw_drv_report_sta_probe_req(struct osw_drv *drv,
-                             const char *phy_name,
-                             const char *vif_name,
-                             const struct osw_hwaddr *mac_addr,
-                             const struct osw_drv_report_sta_probe_req_arg *arg)
+osw_drv_report_sta_changed(struct osw_drv *drv,
+                           const char *phy_name,
+                           const char *vif_name,
+                           const struct osw_hwaddr *mac_addr)
 {
-    /* TODO */
+    struct osw_drv_sta *sta = osw_drv_sta_from_report(drv, phy_name, vif_name, mac_addr);
+    if (WARN_ON(sta == NULL)) return;
+
+    osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_INVALID);
+    osw_drv_work_all_schedule();
 }
 
 void
-osw_drv_report_sta_auth_fail(struct osw_drv *drv,
+osw_drv_report_vif_probe_req(struct osw_drv *drv,
                              const char *phy_name,
                              const char *vif_name,
-                             const struct osw_hwaddr *mac_addr,
-                             const struct osw_drv_report_sta_auth_fail_arg *arg)
+                             const struct osw_drv_report_vif_probe_req *probe_req)
 {
-    /* TODO */
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (WARN_ON(vif == NULL)) return;
+    if (vif->cur_state.exists == false) return;
+
+    OSW_STATE_NOTIFY(vif_probe_req_fn, &vif->pub, probe_req);
 }
 
 void
-osw_drv_report_sta_action_frame(struct osw_drv *drv,
-                                const char *phy_name,
-                                const char *vif_name,
-                                const struct osw_hwaddr *mac_addr,
-                                const struct osw_drv_report_sta_action_frame_arg *arg)
+osw_drv_report_vif_rrm_report(struct osw_drv *drv,
+                              const char *phy_name,
+                              const char *vif_name,
+                              const uint8_t *data,
+                              size_t len)
 {
-    /* TODO */
+    struct osw_drv_vif *vif = osw_drv_vif_from_report(drv, phy_name, vif_name);
+    if (vif == NULL || vif->cur_state.exists == false) {
+        return;
+    }
+
+    OSW_STATE_NOTIFY(vif_rrm_rep_fn, &vif->pub, data, len);
+}
+
+void
+osw_drv_report_stats(struct osw_drv *drv,
+                     const struct osw_tlv *tlv)
+{
+    osw_stats_put(tlv);
 }
 
 void
@@ -1393,6 +2069,7 @@ osw_drv_register_ops(const struct osw_dr
     drv = CALLOC(1, sizeof(*drv));
     drv->ops = ops;
     ds_tree_init(&drv->phy_tree, ds_str_cmp, struct osw_drv_phy, node);
+    ds_dlist_init(&drv->frame_tx_list, struct osw_drv_frame_tx_desc, node);
     ds_tree_insert(&g_osw_drv_tree, drv, ops);
     osw_drv_work_all_schedule();
 }
@@ -1449,6 +2126,15 @@ osw_drv_conf_changed(const struct osw_dr
     return false;
 }
 
+static void
+osw_drv_conf_free_vif_sta(struct osw_drv_vif_config_sta *sta)
+{
+    while (sta->network != NULL) {
+        struct osw_drv_vif_sta_network *next = sta->network->next;
+        FREE(sta->network);
+        sta->network = next;
+    }
+}
 void
 osw_drv_conf_free(struct osw_drv_conf *conf)
 {
@@ -1476,6 +2162,7 @@ osw_drv_conf_free(struct osw_drv_conf *c
                 case OSW_VIF_AP_VLAN:
                     break;
                 case OSW_VIF_STA:
+                    osw_drv_conf_free_vif_sta(&vif->u.sta);
                     break;
             }
         }
@@ -1489,7 +2176,7 @@ osw_drv_conf_free(struct osw_drv_conf *c
     g_osw_drv_work_done = true;
 }
 
-void
+static void
 osw_drv_init(void)
 {
     static bool initialized;
@@ -1518,4 +2205,192 @@ osw_drv_unregister_all(void)
         osw_drv_unregister_ops(drv->ops);
 }
 
+void
+osw_drv_report_frame_tx_state_submitted(struct osw_drv *drv)
+{
+    assert(drv != NULL);
+    osw_drv_report_frame_tx_state(drv, OSW_DRV_FRAME_TX_STATE_SUBMITTED);
+}
+
+void
+osw_drv_report_frame_tx_state_failed(struct osw_drv *drv)
+{
+    assert(drv != NULL);
+    osw_drv_report_frame_tx_state(drv, OSW_DRV_FRAME_TX_STATE_FAILED);
+}
+
+const char*
+osw_frame_tx_result_to_cstr(enum osw_frame_tx_result result)
+{
+    switch (result) {
+        case OSW_FRAME_TX_RESULT_SUBMITTED:
+            return "submitted";
+        case OSW_FRAME_TX_RESULT_FAILED:
+            return "failed";
+        case OSW_FRAME_TX_RESULT_DROPPED:
+            return "dropped";
+    }
+
+    return NULL;
+}
+
+const uint8_t*
+osw_drv_frame_tx_desc_get_frame(const struct osw_drv_frame_tx_desc *desc)
+{
+    assert(desc != NULL);
+    return desc->frame;
+}
+
+size_t
+osw_drv_frame_tx_desc_get_frame_len(const struct osw_drv_frame_tx_desc *desc)
+{
+    assert(desc != NULL);
+    return desc->frame_len;
+}
+
+const struct osw_channel *
+osw_drv_frame_tx_desc_get_channel(const struct osw_drv_frame_tx_desc *desc)
+{
+    assert(desc != NULL);
+    if (desc->channel.control_freq_mhz != 0)
+        return &desc->channel;
+
+    const char *phy_name = desc->phy_name.buf;
+    const char *vif_name = desc->vif_name.buf;
+    const struct osw_drv_vif *vif = osw_drv_vif_lookup_by_name(phy_name, vif_name);
+    if (vif == NULL) return NULL;
+
+    return osw_drv_vif_get_channel(vif);
+}
+
+struct osw_drv_frame_tx_desc*
+osw_drv_frame_tx_desc_new(osw_drv_frame_tx_result_fn_t *result_fn,
+                          void *caller_priv)
+{
+    struct osw_drv_frame_tx_desc *desc = CALLOC(1, sizeof(*desc));
+
+    desc->result_fn = result_fn;
+    desc->caller_priv = caller_priv;
+
+    return desc;
+}
+
+void
+osw_drv_frame_tx_desc_free(struct osw_drv_frame_tx_desc *desc)
+{
+    if (desc == NULL)
+        return;
+
+    osw_drv_frame_tx_desc_reset(desc);
+    FREE(desc);
+}
+
+void
+osw_drv_frame_tx_desc_cancel(struct osw_drv_frame_tx_desc *desc)
+{
+    assert(desc != NULL);
+    osw_drv_frame_tx_desc_reset(desc);
+}
+
+bool
+osw_drv_frame_tx_desc_is_scheduled(const struct osw_drv_frame_tx_desc *desc)
+{
+    assert(desc != NULL);
+    return desc->list != NULL;
+}
+
+void
+osw_drv_frame_tx_desc_set_frame(struct osw_drv_frame_tx_desc *desc,
+                                const uint8_t *data,
+                                size_t data_len)
+{
+    assert(desc != NULL);
+    assert(data != NULL);
+    assert(data_len > 0);
+
+    FREE(desc->frame);
+    desc->frame = MEMNDUP(data, data_len);
+    desc->frame_len = data_len;
+}
+
+void
+osw_drv_report_sta_assoc_ies(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *sta_addr,
+                             const void *ies,
+                             const size_t ies_len)
+{
+    struct osw_drv_sta *sta = osw_drv_sta_from_report(drv, phy_name, vif_name, sta_addr);
+    const struct osw_hwaddr zero = {0};
+
+    LOGT("osw: drv: %s/%s/%s/"OSW_HWADDR_FMT": report assoc ies: %p (len=%zu)",
+         drv->ops->name,
+         phy_name ?: "",
+         vif_name ?: "",
+         OSW_HWADDR_ARG(sta_addr ?: &zero),
+         ies,
+         ies_len);
+
+    if (ies == NULL) return;
+    if (ies_len == 0) return;
+
+    osw_drv_buf_set(&sta->new_ies, ies, ies_len);
+    if (osw_drv_buf_is_same(&sta->cur_ies, &sta->new_ies) == true) return;
+
+    switch (sta->obj.state) {
+        case OSW_DRV_OBJ_INVALID:
+            break;
+        case OSW_DRV_OBJ_REQUESTED:
+            break;
+        case OSW_DRV_OBJ_VALID:
+            break;
+        case OSW_DRV_OBJ_PROCESSED:
+            /* There's no need to invalidate the entire sta
+             * state if it's already in a processed state.
+             * This only needs to go through the process
+             * logic to figure out if IEs changed and report
+             * that back up.
+             */
+            osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_VALID);
+            osw_drv_work_all_schedule();
+            break;
+    }
+}
+
+void
+osw_drv_invalidate(struct osw_drv *drv)
+{
+    if (WARN_ON(drv == NULL)) return;
+    if (drv->initialized == false) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy;
+
+    osw_drv_set_phy_list_valid(drv, false);
+
+    ds_tree_foreach(&drv->phy_tree, phy) {
+        const char *phy_name = phy->phy_name;
+        struct osw_drv_vif *vif;
+
+        osw_drv_report_phy_changed(drv, phy_name);
+        ds_tree_foreach(&phy->vif_tree, vif) {
+            const char *vif_name = vif->vif_name;
+            osw_drv_report_vif_changed(drv, phy_name, vif_name);
+
+            struct osw_drv_sta *sta;
+            ds_tree_foreach(&vif->sta_tree, sta) {
+                const struct osw_hwaddr *sta_addr = &sta->mac_addr;
+                osw_drv_report_sta_changed(drv, phy_name, vif_name, sta_addr);
+            }
+        }
+    }
+}
+
+OSW_MODULE(osw_drv)
+{
+    osw_drv_init();
+    return NULL;
+}
+
 #include "osw_drv_ut.c"
Index: core/src/lib/osw/src/osw_drv_dummy.c
===================================================================
--- core.orig/src/lib/osw/src/osw_drv_dummy.c
+++ core/src/lib/osw/src/osw_drv_dummy.c
@@ -3,32 +3,10 @@
 #include <log.h>
 #include <osw_drv_dummy.h>
 #include <osw_ut.h>
-#include <module.h>
 #include <memutil.h>
 
 /* FIXME: rename _ops_ to _op_ in function names for osw_drv_ops */
 
-struct osw_drv_dummy_phy {
-    struct ds_tree_node node;
-    struct osw_ifname phy_name;
-    struct osw_drv_phy_state state;
-};
-
-struct osw_drv_dummy_vif {
-    struct ds_tree_node node;
-    struct osw_ifname phy_name;
-    struct osw_ifname vif_name;
-    struct osw_drv_vif_state state;
-};
-
-struct osw_drv_dummy_sta {
-    struct ds_dlist_node node;
-    struct osw_ifname phy_name;
-    struct osw_ifname vif_name;
-    struct osw_hwaddr sta_addr;
-    struct osw_drv_sta_state state;
-};
-
 static struct osw_drv_dummy_phy *
 osw_drv_dummy_phy_lookup(struct osw_drv_dummy *dummy,
                          const char *phy_name)
@@ -173,6 +151,10 @@ osw_drv_dummy_ops_get_sta_state_cb(struc
         state = sta->state;
 
     osw_drv_report_sta_state(drv, phy_name, vif_name, sta_addr, &state);
+
+    if (sta != NULL) {
+        osw_drv_report_sta_assoc_ies(drv, phy_name, vif_name, sta_addr, sta->ies, sta->ies_len);
+    }
 }
 
 static void
@@ -188,6 +170,9 @@ osw_drv_dummy_init_struct(struct osw_drv
         .request_vif_state_fn = osw_drv_dummy_ops_get_vif_state_cb,
         .request_sta_state_fn = osw_drv_dummy_ops_get_sta_state_cb,
         .request_config_fn = dummy->request_config_fn,
+        .request_stats_fn = dummy->request_stats_fn,
+        .request_sta_deauth_fn = dummy->request_sta_deauth_fn,
+        .push_frame_tx_fn = dummy->push_frame_tx_fn,
     };
 
     ds_tree_init(&dummy->phy_tree, ds_str_cmp, struct osw_drv_dummy_phy, node);
@@ -251,6 +236,26 @@ osw_drv_dummy_set_phy(struct osw_drv_dum
     }
 }
 
+static void
+osw_drv_dummy_update_sta(struct osw_drv_dummy *dummy)
+{
+    struct osw_drv_dummy_sta *sta;
+
+    /* FIXME: This isn't optimal to run every time vif is
+     * updated. This should have a dedicated pending list
+     * for stations without phy name mapped to them.
+     */
+    ds_dlist_foreach(&dummy->sta_list, sta) {
+        if (strlen(sta->phy_name.buf) > 0) continue;
+        const char *phy_name = osw_drv_dummy_vif_to_phy(dummy, sta->vif_name.buf);
+        LOGD("osw: drv: dummy: %s/"OSW_HWADDR_FMT": updating phy name to %s",
+             sta->vif_name.buf,
+             OSW_HWADDR_ARG(&sta->sta_addr),
+             phy_name);
+        osw_drv_dummy_set_sta(dummy, phy_name, sta->vif_name.buf, &sta->sta_addr, &sta->state);
+    }
+}
+
 void
 osw_drv_dummy_set_vif(struct osw_drv_dummy *dummy,
                       const char *phy_name,
@@ -264,6 +269,7 @@ osw_drv_dummy_set_vif(struct osw_drv_dum
         STRSCPY_WARN(vif->phy_name.buf, phy_name);
         STRSCPY_WARN(vif->vif_name.buf, vif_name);
         ds_tree_insert(&dummy->vif_tree, vif, vif->vif_name.buf);
+        osw_drv_dummy_update_sta(dummy);
     } else {
         if (dummy->fini_vif_fn != NULL) {
             dummy->fini_vif_fn(dummy, &vif->state);
@@ -291,7 +297,6 @@ osw_drv_dummy_set_sta(struct osw_drv_dum
         osw_drv_report_sta_changed(dummy->drv, phy_name, vif_name, sta_addr);
     if (sta == NULL) {
         sta = CALLOC(1, sizeof(*sta));
-        if (phy_name != NULL) STRSCPY_WARN(sta->phy_name.buf, phy_name);
         STRSCPY_WARN(sta->vif_name.buf, vif_name);
         sta->sta_addr = *sta_addr;
         ds_dlist_insert_tail(&dummy->sta_list, sta);
@@ -300,6 +305,9 @@ osw_drv_dummy_set_sta(struct osw_drv_dum
             dummy->fini_sta_fn(dummy, &sta->state);
         }
     }
+    if (phy_name != NULL && strlen(sta->phy_name.buf) == 0) {
+        STRSCPY_WARN(sta->phy_name.buf, phy_name);
+    }
     if (state != NULL)
         sta->state = *state;
     if (state == NULL) {
@@ -309,6 +317,46 @@ osw_drv_dummy_set_sta(struct osw_drv_dum
 }
 
 void
+osw_drv_dummy_set_sta_ies(struct osw_drv_dummy *dummy,
+                          const char *phy_name,
+                          const char *vif_name,
+                          const struct osw_hwaddr *sta_addr,
+                          const void *ies,
+                          size_t ies_len)
+{
+    struct osw_drv_dummy_sta *sta = osw_drv_dummy_sta_lookup(dummy, phy_name, vif_name, sta_addr);
+
+    /* FIXME: This currently requires that
+     * osw_drv_dummy_set_sta() is called _before_
+     * osw_drv_dummy_set_sta_ies(). This is unfortunate but
+     * acceptable for now. Mark it down with WARN_ON() so
+     * that if it happens to be called out of order by
+     * mistake it is visible.
+     */
+    if (WARN_ON(sta == NULL)) return;
+
+    if (phy_name == NULL) {
+        phy_name = sta->phy_name.buf;
+    }
+
+    sta->ies = MEMNDUP(ies, ies_len);
+    sta->ies_len = ies_len;
+
+    if (strlen(phy_name) > 0) {
+        /* osw_drv_report_sta_assoc_ies() is called when sta
+         * state is requested. THat's the safest and easiest
+         * way to propagate IEs with the dummy driver given
+         * it has little control over when states become
+         * valid.
+         *
+         * If phy_name isn't known yet then sta_changed()
+         * and sta request will get called eventually.
+         */
+        osw_drv_report_sta_changed(dummy->drv, phy_name, vif_name, sta_addr);
+    }
+}
+
+void
 osw_drv_dummy_iter_sta(struct osw_drv_dummy *dummy,
                        osw_drv_dummy_iter_sta_fn_t *fn,
                        void *fn_data)
@@ -351,8 +399,7 @@ osw_drv_dummy_ut_1_fini_sta_cb(struct os
     ut->n_sta_fini++;
 }
 
-static void
-osw_drv_dummy_ut_1_cb(void *data)
+OSW_UT(osw_drv_dummy_ut_1)
 {
     struct osw_drv_dummy_ut_1 ut = {
         .dummy = {
@@ -440,17 +487,7 @@ osw_drv_dummy_ut_1_cb(void *data)
     assert(ut.n_sta_fini == 3);
 }
 
-static void
-osw_drv_dummy_ut_module_init(void *data)
-{
-    osw_ut_register("osw_drv_dummy_ut_1", osw_drv_dummy_ut_1_cb, NULL);
-}
-
-static void
-osw_drv_dummy_ut_module_fini(void *data)
+OSW_MODULE(osw_drv_dummy)
 {
+    return NULL;
 }
-
-MODULE(osw_drv_dummy_ut_module,
-       osw_drv_dummy_ut_module_init,
-       osw_drv_dummy_ut_module_fini);
Index: core/src/lib/osw/src/osw_drv_i.h
===================================================================
--- core.orig/src/lib/osw/src/osw_drv_i.h
+++ core/src/lib/osw/src/osw_drv_i.h
@@ -1,9 +1,10 @@
-#ifndef OSW_DRV_I_H
-#define OSW_DRV_I_H
+#ifndef OSW_DRV_I_H_INCLUDED
+#define OSW_DRV_I_H_INCLUDED
 
 #include <ds_dlist.h>
 #include <ds_tree.h>
 #include <ev.h>
+#include <osw_timer.h>
 #include <osw_drv.h>
 #include "osw_state_i.h"
 
@@ -14,12 +15,24 @@ enum osw_drv_obj_state {
     OSW_DRV_OBJ_PROCESSED,
 };
 
+enum osw_drv_frame_tx_desc_state {
+    OSW_DRV_FRAME_TX_STATE_UNUSED = 0,
+    OSW_DRV_FRAME_TX_STATE_PENDING,
+    OSW_DRV_FRAME_TX_STATE_SUBMITTED,
+    OSW_DRV_FRAME_TX_STATE_FAILED,
+};
+
 struct osw_drv_obj {
     enum osw_drv_obj_state state;
     bool existed;
     bool exists;
 };
 
+struct osw_drv_buf {
+    void *data;
+    size_t len;
+};
+
 struct osw_drv {
     const struct osw_drv_ops *ops;
     void *priv;
@@ -29,6 +42,7 @@ struct osw_drv {
 
     struct ds_tree_node node;
     struct ds_tree phy_tree;
+    struct ds_dlist frame_tx_list;
     ev_async work_async;
     bool phy_list_valid; // FIXME
 };
@@ -55,6 +69,10 @@ struct osw_drv_vif {
     struct osw_drv_vif_state cur_state;
     struct osw_drv_vif_state new_state;
     struct osw_channel csa_channel;
+    struct osw_ssid ssid;
+    struct osw_hwaddr bssid;
+    const struct osw_hwaddr *vsta_root_ap;
+    bool connected;
     bool sta_list_valid;
     ev_timer chan_sync; /* used for CSA state invalidation */
 };
@@ -67,6 +85,22 @@ struct osw_drv_sta {
     struct osw_drv_obj obj;
     struct osw_drv_sta_state cur_state;
     struct osw_drv_sta_state new_state;
+    struct osw_drv_buf cur_ies;
+    struct osw_drv_buf new_ies;
+};
+
+struct osw_drv_frame_tx_desc {
+    struct osw_ifname phy_name;
+    struct osw_ifname vif_name;
+    osw_drv_frame_tx_result_fn_t *result_fn;
+    uint8_t *frame;
+    size_t frame_len;
+    enum osw_drv_frame_tx_desc_state state;
+    void *caller_priv;
+    struct ds_dlist *list;
+    struct osw_channel channel;
+
+    struct ds_dlist_node node;
 };
 
 extern struct ds_tree g_osw_drv_tree;
@@ -78,10 +112,10 @@ bool
 osw_drv_work_is_settled(void);
 
 void
-osw_drv_init(void);
+osw_drv_unregister_all(void);
 
 void
-osw_drv_unregister_all(void);
+osw_drv_invalidate(struct osw_drv *drv);
 
 void
 osw_drv_set_chan_sync(struct osw_drv *drv, const struct osw_drv_conf *conf);
@@ -89,4 +123,7 @@ osw_drv_set_chan_sync(struct osw_drv *dr
 bool
 osw_drv_conf_changed(const struct osw_drv_conf *drv_conf);
 
-#endif
+void
+osw_drv_frame_tx_desc_free(struct osw_drv_frame_tx_desc *desc);
+
+#endif /* OSW_DRV_I_H_INCLUDED */
Index: core/src/lib/osw/src/osw_drv_target.c
===================================================================
--- core.orig/src/lib/osw/src/osw_drv_target.c
+++ core/src/lib/osw/src/osw_drv_target.c
@@ -1,10 +1,11 @@
 #include <libgen.h>
-#include <osw_drv.h>
+#include <ev.h>
 #include <osw_drv_dummy.h>
 #include <osw_state.h>
+#include <osw_module.h>
 #include <osw_ut.h>
 #include <target.h>
-#include <module.h>
+#include <target_bsal.h>
 #include <memutil.h>
 #include <ovsdb_table.h>
 #include <ovsdb_cache.h>
@@ -12,6 +13,8 @@
 static ovsdb_table_t table_Wifi_Radio_Config;
 static ovsdb_table_t table_Wifi_Radio_State;
 static ovsdb_table_t table_Wifi_VIF_Config;
+static ovsdb_table_t table_Band_Steering_Config;
+static ovsdb_table_t table_Band_Steering_Clients;
 
 struct osw_drv_target;
 
@@ -20,8 +23,17 @@ struct osw_drv_target_phy {
     struct schema_Wifi_Radio_State rstate;
 };
 
+struct osw_drv_target_net {
+    struct ds_dlist_node node;
+    struct osw_hwaddr bssid;
+    struct osw_ssid ssid;
+    struct osw_psk psk;
+    struct osw_wpa wpa;
+};
+
 struct osw_drv_target_vif {
     struct ds_tree_node node;
+    struct ds_dlist nets;
     struct osw_drv_target *target;
     struct schema_Wifi_VIF_Config config;
     struct schema_Wifi_VIF_State state;
@@ -31,6 +43,37 @@ struct osw_drv_target_vif {
     ev_timer work;
 };
 
+struct osw_drv_target_survey_entry {
+    struct ds_tree node;
+    int channel;
+    target_survey_record_t *record;
+};
+
+struct osw_drv_target_survey {
+    struct ds_tree_node node;
+    struct osw_drv_target *target;
+    char *phy_name;
+    radio_entry_t cfg;
+    radio_scan_type_t type;
+    struct ds_tree entries; /* osw_drv_target_survey_entry */
+    struct ds_dlist list;
+    bool requested;
+};
+
+struct osw_drv_target_scan_id {
+};
+
+struct osw_drv_target_scan {
+    struct ds_dlist_node node;
+    struct osw_drv_target *target;
+    radio_entry_t cfg;
+    radio_scan_type_t type;
+    uint32_t dwell;
+    uint32_t *chans;
+    uint32_t n_chans;
+    bool busy;
+};
+
 struct osw_drv_target {
     struct osw_drv_dummy dummy;
     struct osw_drv *drv;
@@ -42,6 +85,22 @@ struct osw_drv_target {
     bool conf_phy_done;
     ev_timer conf_timer;
     ev_timer ovsdb_retry;
+    struct ds_tree bsal_vap_tree;
+    struct ds_tree bsal_ue_tree;
+    struct ds_dlist scans;
+    struct ds_tree surveys;
+    struct osw_tlv *stats;
+};
+
+struct osw_drv_target_bsal_vap {
+    struct ds_tree_node node;
+    bsal_ifconfig_t cfg;
+};
+
+struct osw_drv_target_bsal_ue {
+    struct ds_tree_node node;
+    struct osw_hwaddr mac_addr;
+    bsal_client_config_t cfg;
 };
 
 static void
@@ -72,14 +131,620 @@ static void
 osw_drv_target_fini_vif_cb(struct osw_drv_dummy *dummy,
                            struct osw_drv_vif_state *vif)
 {
-    FREE(vif->u.ap.acl.list);
-    FREE(vif->u.ap.psk_list.list);
-    vif->u.ap.acl.list = NULL;
-    vif->u.ap.acl.count = 0;
-    vif->u.ap.psk_list.list = NULL;
-    vif->u.ap.psk_list.count = 0;
+    switch (vif->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            FREE(vif->u.ap.acl.list);
+            FREE(vif->u.ap.psk_list.list);
+            vif->u.ap.acl.list = NULL;
+            vif->u.ap.acl.count = 0;
+            vif->u.ap.psk_list.list = NULL;
+            vif->u.ap.psk_list.count = 0;
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            while (vif->u.sta.network != NULL) {
+                struct osw_drv_vif_sta_network *next = vif->u.sta.network->next;
+                FREE(vif->u.sta.network);
+                vif->u.sta.network = next;
+            }
+            break;
+    }
+}
+
+static void
+osw_drv_target_push_frame_tx_cb(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name,
+                                struct osw_drv_frame_tx_desc *desc)
+{
+    const size_t dot11_header_size = sizeof(struct osw_drv_dot11_frame_header);
+    const uint8_t *payload = osw_drv_frame_tx_desc_get_frame(desc);
+    const struct osw_drv_dot11_frame *frame = (const struct osw_drv_dot11_frame*) payload;
+    size_t payload_len = osw_drv_frame_tx_desc_get_frame_len(desc);
+    int result;
+
+    if (vif_name == NULL) {
+        LOGD("osw: drv: target: vif_name is required, failing");
+        osw_drv_report_frame_tx_state_failed(drv);
+        return;
+    }
+
+    if (dot11_header_size >= payload_len) {
+        LOGD("osw: drv: target: frame tx too small, failing");
+        osw_drv_report_frame_tx_state_failed(drv);
+        return;
+    }
+
+    payload += dot11_header_size;
+    payload_len -= dot11_header_size;
+
+    result = target_bsal_send_action(vif_name, frame->header.da, payload, payload_len);
+    if (result == true)
+        osw_drv_report_frame_tx_state_submitted(drv);
+    else
+        osw_drv_report_frame_tx_state_failed(drv);
+}
+
+static void
+osw_drv_target_fill_sta_stats_one(const char *phy_name,
+                                  const char *vif_name,
+                                  const struct osw_hwaddr *addr,
+                                  struct osw_tlv *t)
+{
+    bsal_client_info_t info = {0};
+    int err = target_bsal_client_info(vif_name, addr->octet, &info);
+    if (err != 0) return;
+    if (info.connected == false) return;
+
+    const uint32_t tx_bytes = info.tx_bytes;
+    const uint32_t rx_bytes = info.rx_bytes;
+    const uint32_t snr = info.snr;
+
+    void *s = osw_tlv_put_nested(t, OSW_STATS_STA);
+    osw_tlv_put_string(t, OSW_STATS_STA_PHY_NAME, phy_name);
+    osw_tlv_put_string(t, OSW_STATS_STA_VIF_NAME, vif_name);
+    osw_tlv_put_hwaddr(t, OSW_STATS_STA_MAC_ADDRESS, addr);
+
+    osw_tlv_put_u32(t, OSW_STATS_STA_SNR_DB, snr);
+    osw_tlv_put_u32(t, OSW_STATS_STA_TX_BYTES, tx_bytes);
+    osw_tlv_put_u32(t, OSW_STATS_STA_RX_BYTES, rx_bytes);
+
+    osw_tlv_end_nested(t, s);
+}
+
+static void
+osw_drv_target_fill_sta_stats(struct osw_drv_dummy *dummy,
+                              struct osw_tlv *t)
+{
+    struct osw_drv_dummy_sta *sta;
+    struct osw_drv_dummy_vif *vif;
+    ds_dlist_foreach(&dummy->sta_list, sta) {
+        const char *phy_name = sta->phy_name.buf;
+        const char *vif_name = sta->vif_name.buf;
+        const struct osw_hwaddr *addr = &sta->sta_addr;
+        osw_drv_target_fill_sta_stats_one(phy_name, vif_name, addr, t);
+    }
+    ds_tree_foreach(&dummy->vif_tree, vif) {
+        if (vif->state.vif_type != OSW_VIF_STA) continue;
+        if (vif->state.u.sta.link.status != OSW_DRV_VIF_STATE_STA_LINK_CONNECTED) continue;
+        const char *phy_name = vif->phy_name.buf;
+        const char *vif_name = vif->vif_name.buf;
+        const struct osw_hwaddr *addr = &vif->state.u.sta.link.bssid;
+        osw_drv_target_fill_sta_stats_one(phy_name, vif_name, addr, t);
+    }
+}
+
+static radio_type_t
+phy_to_type(const struct osw_drv_phy_state *phy)
+{
+    const int b2ch1 = 2412;
+    const int b2ch13 = 2472;
+    const int b2ch14 = 2484;
+    const int b5ch36 = 5180;
+    const int b5ch100 = 5500;
+    const int b5ch177 = 5885;
+    const int b6ch1 = 5955;
+    const int b6ch2 = 5935;
+    const int b6ch233 = 7115;
+    bool is_2g = false;
+    bool is_5g = false;
+    bool is_5gl = false;
+    bool is_5gu = false;
+    bool is_6g = false;
+
+    size_t i ;
+    const size_t n = phy->n_channel_states;
+    for (i = 0; i < n; i++) {
+        const struct osw_channel_state *cs = &phy->channel_states[i];
+        const struct osw_channel *c = &cs->channel;
+        const int freq = c->control_freq_mhz;
+
+        if (freq >= b2ch1 && freq <= b2ch13) is_2g = true;
+        if (freq == b2ch14) is_2g = true;
+        if (freq >= b5ch36 && freq < b5ch100) is_5gl = true;
+        if (freq >= b5ch100 && freq <= b5ch177) is_5gu = true;
+        if (freq >= b6ch1 && freq <= b6ch233) is_6g = true;
+        if (freq == b6ch2) is_6g = true;
+    }
+
+    is_5g = is_5gl && is_5gu;
+    if (is_5g) {
+        is_5gl = false;
+        is_5gu = false;
+    }
+
+    const int bands = is_2g + is_5g + is_5gl + is_5gu + is_6g;
+    if (WARN_ON(bands != 1)) return RADIO_TYPE_NONE;
+
+    if (is_2g == true) return RADIO_TYPE_2G;
+    if (is_5g == true) return RADIO_TYPE_5G;
+    if (is_5gl == true) return RADIO_TYPE_5GL;
+    if (is_5gu == true) return RADIO_TYPE_5GU;
+    if (is_6g == true) return RADIO_TYPE_6G;
+
+    return RADIO_TYPE_NONE;
+}
+
+static uint32_t
+freq_to_chan(const int freq)
+{
+    const int b2ch1 = 2412;
+    const int b2ch13 = 2472;
+    const int b2ch14 = 2484;
+    const int b5ch36 = 5180;
+    const int b5ch177 = 5885;
+    const int b6ch1 = 5955;
+    const int b6ch2 = 5935;
+    const int b6ch233 = 7115;
+    const int b2base = 2407;
+    const int b5base = 5000;
+    const int b6base = 5950;
+
+    if (freq >= b2ch1 && freq <= b2ch13) return (freq - b2base) / 5;
+    if (freq == b2ch14) return 14;
+    if (freq >= b5ch36 && freq <= b5ch177) return (freq - b5base) / 5;
+    if (freq >= b6ch1 && freq <= b6ch233) return (freq - b6base) / 5;
+    if (freq == b6ch2) return 2;
+    return 0;
+}
+
+#if 0
+static uint32_t *
+phy_to_chans(const struct osw_drv_phy_state *phy, uint32_t *n_chans)
+{
+    size_t i ;
+    const size_t n = phy->n_channel_states;
+    uint32_t *chans = MALLOC(sizeof(chans[0]) * n);
+    for (i = 0; i < n; i++) {
+        const struct osw_channel_state *cs = &phy->channel_states[i];
+        const struct osw_channel *c = &cs->channel;
+        const int freq = c->control_freq_mhz;
+        const int ch = freq_to_chan(freq);
+        chans[i] = ch;
+    }
+    *n_chans = n;
+    return chans;
+}
+#endif
+
+static uint32_t *
+phy_to_chan(struct osw_drv_dummy *dummy,
+            const char *phy_name)
+{
+    struct osw_drv_dummy_phy *phy = ds_tree_find(&dummy->phy_tree, phy_name);
+    if (phy == NULL) return NULL;
+
+    struct osw_drv_dummy_vif *vif;
+    ds_tree_foreach(&dummy->vif_tree, vif) {
+        const bool phy_match = (strcmp(vif->phy_name.buf, phy_name) == 0);
+        if (phy_match == false) continue;
+        if (vif->state.enabled == false) continue;
+        if (vif->state.vif_type != OSW_VIF_AP) continue;
+        const struct osw_drv_vif_state_ap *vap = &vif->state.u.ap;
+        const struct osw_channel *c = &vap->channel;
+        const int freq = c->control_freq_mhz;
+        const int ch = freq_to_chan(freq);
+
+        return MEMNDUP(&ch, sizeof(ch));
+    }
+
+    return NULL;
+}
+
+static uint32_t
+width_to_mhz(radio_chanwidth_t w)
+{
+    switch (w) {
+        case RADIO_CHAN_WIDTH_NONE: return 0;
+        case RADIO_CHAN_WIDTH_20MHZ: return 20;
+        case RADIO_CHAN_WIDTH_40MHZ: return 40;
+        case RADIO_CHAN_WIDTH_40MHZ_ABOVE: return 40;
+        case RADIO_CHAN_WIDTH_40MHZ_BELOW: return 40;
+        case RADIO_CHAN_WIDTH_80MHZ: return 80;
+        case RADIO_CHAN_WIDTH_160MHZ: return 160;
+        case RADIO_CHAN_WIDTH_80_PLUS_80MHZ: return 160;
+        case RADIO_CHAN_WIDTH_QTY: return 0;
+    }
+    return 0;
+}
+
+static uint32_t
+chan_to_freq(radio_type_t t, int c)
+{
+    switch (t) {
+        case RADIO_TYPE_NONE: return 0;
+        case RADIO_TYPE_2G:
+            if (c == 14) return 2484;
+            return 2407 + (5*c);
+        case RADIO_TYPE_5G: return 5000 + (5*c);
+        case RADIO_TYPE_5GL: return 5000 + (5*c);
+        case RADIO_TYPE_5GU: return 5000 + (5*c);
+        case RADIO_TYPE_6G:
+            if (c == 2) return 5935;
+            return 5950 + (5*c);
+    }
+    return 0;
+}
+
+static void
+osw_drv_target_bss_fill(struct osw_tlv *t,
+                        const char *phy_name,
+                        const radio_type_t type,
+                        const const dpp_neighbor_record_t *n)
+{
+    LOGT("%s: %s: type=%d bssid=%s chan=%d sig=%d ssid=%s width=%d",
+         __func__,
+         phy_name,
+         n->type,
+         n->bssid,
+         n->chan,
+         n->sig,
+         n->ssid,
+         n->chanwidth);
+
+    struct osw_hwaddr bssid;
+    const uint32_t freq_mhz = chan_to_freq(type, n->chan);
+    const uint32_t width_mhz = width_to_mhz(n->chanwidth);
+    const uint32_t snr_db = n->sig;
+    const char *ssid = n->ssid;
+    const size_t ssid_len = strlen(ssid);
+
+    osw_hwaddr_from_cstr(n->bssid, &bssid);
+
+    void *s = osw_tlv_put_nested(t, OSW_STATS_BSS_SCAN);
+    osw_tlv_put_string(t, OSW_STATS_BSS_SCAN_PHY_NAME, phy_name);
+    osw_tlv_put_hwaddr(t, OSW_STATS_BSS_SCAN_MAC_ADDRESS, &bssid);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_FREQ_MHZ, freq_mhz);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_WIDTH_MHZ, width_mhz);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_SNR_DB, snr_db);
+    osw_tlv_put_buf(t, OSW_STATS_BSS_SCAN_SSID, ssid, ssid_len);
+    // TODO: OSW_STATS_BSS_SCAN_IES
+    osw_tlv_end_nested(t, s);
+}
+
+static void
+osw_drv_target_scan_run(struct osw_drv_target *target);
+
+static void
+osw_drv_target_scan_free(struct osw_drv_target_scan *scan)
+{
+    ds_dlist_remove(&scan->target->scans, scan);
+    FREE(scan->chans);
+    FREE(scan);
+}
+
+static bool
+osw_drv_target_scan_done_cb(void *priv, int status)
+{
+    struct osw_drv_target_scan *scan = priv;
+    struct osw_drv_target *target = scan->target;
+    struct osw_drv *drv = target->drv;
+    const char *phy_name = scan->cfg.phy_name;
+    struct osw_tlv buf = {0};
+    struct osw_tlv *t = scan->target->stats ?: &buf;
+    dpp_neighbor_report_data_t report = {
+        .list = DS_DLIST_INIT(dpp_neighbor_record_list_t, node),
+    };
+
+    LOGT("osw: drv: target: %s: scan: done status=%d", phy_name, status);
+
+    target_stats_scan_get(&scan->cfg, scan->chans, scan->n_chans, scan->type, &report);
+
+    dpp_neighbor_record_list_t *i;
+    while ((i = ds_dlist_remove_head(&report.list)) != NULL) {
+        const dpp_neighbor_record_t *n = &i->entry;
+        osw_drv_target_bss_fill(t, phy_name, scan->cfg.type, n);
+        dpp_neighbor_record_free(i);
+    }
+
+    if (t == &buf && buf.used > 0) {
+        LOGT("%s: %s: reporting %zu bytes", __func__, scan->cfg.phy_name, buf.used);
+        osw_drv_report_stats(drv, &buf);
+        osw_tlv_fini(&buf);
+    }
+
+    osw_drv_target_scan_free(scan);
+    osw_drv_target_scan_run(target);
+
+    return true;
+}
+
+static void
+osw_drv_target_scan_run(struct osw_drv_target *target)
+{
+    while (ds_dlist_is_empty(&target->scans) == false) {
+        struct osw_drv_target_scan *scan = ds_dlist_head(&target->scans);
+        LOGT("osw: drv: target: %s: scan: starting type=%d n_chans=%d",
+             scan->cfg.phy_name,
+             scan->type,
+             scan->n_chans);
+        const bool ok = target_stats_scan_start(&scan->cfg,
+                                                scan->chans,
+                                                scan->n_chans,
+                                                scan->type,
+                                                scan->dwell,
+                                                osw_drv_target_scan_done_cb,
+                                                scan);
+        if (ok == true) return;
+        LOGI("osw: drv: target: %s: scan: failed", scan->cfg.phy_name);
+
+        /* In case target called the callback and
+         * we cleaned it up, be careful.
+         */
+        if (ds_dlist_head(&target->scans) == scan) {
+            osw_drv_target_scan_free(scan);
+        }
+    }
+}
+
+
+static const char *
+phy_to_scan_vif(struct osw_drv_dummy *dummy, const char *phy_name)
+{
+    struct osw_drv_dummy_vif *vif;
+    ds_tree_foreach(&dummy->vif_tree, vif) {
+        if (strcmp(vif->phy_name.buf, phy_name) != 0) continue;
+        if (vif->state.enabled == false) continue;
+        if (vif->state.vif_type != OSW_VIF_AP) continue;
+        return vif->vif_name.buf;
+    }
+    return NULL;
+}
+
+static bool
+osw_drv_target_prep_rcfg(radio_entry_t *cfg,
+                         struct osw_drv_dummy *dummy,
+                         const struct osw_drv_dummy_phy *phy)
+{
+    const char *phy_name = phy->phy_name.buf;
+    const char *vif_name = phy_to_scan_vif(dummy, phy_name);
+    if (vif_name == NULL) return false;
+
+    cfg->type = phy_to_type(&phy->state),
+    STRSCPY_WARN(cfg->phy_name, phy_name);
+    STRSCPY_WARN(cfg->if_name, vif_name);
+
+    return true;
+}
+
+static void
+osw_drv_target_scan_req_phy(struct osw_drv_target *target,
+                            struct osw_drv_dummy_phy *phy,
+                            const const radio_scan_type_t type,
+                            uint32_t dwell,
+                            uint32_t *chans,
+                            uint32_t n_chans)
+{
+    if (chans == NULL) return;
+    if (phy == NULL) return;
+
+    const bool first_req = (ds_dlist_is_empty(&target->scans) == true);
+    struct osw_drv_dummy *dummy = &target->dummy;
+
+    struct osw_drv_target_scan *scan = CALLOC(1, sizeof(*scan));
+    const bool prep_ok = osw_drv_target_prep_rcfg(&scan->cfg, dummy, phy);
+    if (prep_ok == false) {
+        FREE(scan);
+        return;
+    }
+
+    scan->target = target;
+    scan->dwell = dwell,
+    scan->type = type,
+    scan->chans = chans;
+    scan->n_chans = n_chans;
+
+    LOGT("osw: drv: target: %s: scan: requesting (first=%d)", scan->cfg.phy_name, first_req);
+    ds_dlist_insert_tail(&target->scans, scan);
+    if (first_req == true) osw_drv_target_scan_run(target);
+}
+
+static void
+osw_drv_target_survey_fill(struct osw_tlv *t,
+                           const radio_entry_t *cfg,
+                           const int c,
+                           const dpp_survey_record_t *delta)
+{
+    const char *phy_name = cfg->phy_name;
+
+    LOGT("%s: %s: chan=%d active=%u busy=%u ext=%u self=%u rx=%u tx=%u noise=%d duration=%u",
+         __func__,
+         phy_name,
+         c,
+         delta->chan_active,
+         delta->chan_busy,
+         delta->chan_busy_ext,
+         delta->chan_self,
+         delta->chan_rx,
+         delta->chan_tx,
+         delta->chan_noise,
+         delta->duration_ms);
+
+    /* Reporting an entry with 0 duration makes no sense.
+     * It's wasteful, and since it's also used for division,
+     * it would cause divide-by-zero fault, so just return.
+     */
+    if (delta->duration_ms == 0) return;
+
+    void *start_chan = osw_tlv_put_nested(t, OSW_STATS_CHAN);
+    {
+        const uint32_t active = delta->duration_ms;
+        const float noise = delta->chan_noise;
+        const uint32_t freq_mhz = chan_to_freq(cfg->type, c);
+
+        osw_tlv_put_string(t, OSW_STATS_CHAN_PHY_NAME, phy_name);
+        osw_tlv_put_u32(t, OSW_STATS_CHAN_FREQ_MHZ, freq_mhz);
+        osw_tlv_put_u32_delta(t, OSW_STATS_CHAN_ACTIVE_MSEC, active);
+        osw_tlv_put_float(t, OSW_STATS_CHAN_NOISE_FLOOR_DBM, noise);
+
+        void *start_cnt = osw_tlv_put_nested(t, OSW_STATS_CHAN_CNT_MSEC);
+        {
+            const uint32_t busy = delta->chan_busy * active / 100;
+            const uint32_t tx = delta->chan_tx * active / 100;
+            const uint32_t rx = delta->chan_rx * active / 100;
+            const uint32_t inbss = delta->chan_self * active / 100;
+
+            osw_tlv_put_u32_delta(t, OSW_STATS_CHAN_CNT_TX, tx);
+            osw_tlv_put_u32_delta(t, OSW_STATS_CHAN_CNT_RX, rx);
+            osw_tlv_put_u32_delta(t, OSW_STATS_CHAN_CNT_RX_INBSS, inbss);
+            osw_tlv_put_u32_delta(t, OSW_STATS_CHAN_CNT_BUSY, busy);
+        }
+        osw_tlv_end_nested(t, start_cnt);
+    }
+    osw_tlv_end_nested(t, start_chan);
+}
+
+static bool
+osw_drv_target_survey_cb(ds_dlist_t *list, void *priv, int status)
+{
+    struct osw_drv_target_survey *s = priv;
+    struct osw_drv *drv = s->target->drv;
+    target_survey_record_t *record;
+    assert(&s->list == list);
+    struct osw_tlv buf = {0};
+    struct osw_tlv *t = s->target->stats ?: &buf;
+
+    LOGT("%s: %s: status = %d", __func__, s->phy_name, status);
+
+    while ((record = ds_dlist_remove_head(list)) != NULL) {
+        const int c = record->info.chan;
+        struct osw_drv_target_survey_entry *e = ds_tree_find(&s->entries, &c);
+
+        if (e == NULL) {
+            e = CALLOC(1, sizeof(*e));
+            e->channel = c;
+            ds_tree_insert(&s->entries, e, &e->channel);
+        }
+
+        if (e->record != NULL) {
+            dpp_survey_record_t delta = {0};
+            target_survey_record_t *old_record = e->record;
+            target_survey_record_t *new_record = record;
+            const bool ok = target_stats_survey_convert(&s->cfg,
+                                                        s->type,
+                                                        new_record,
+                                                        old_record,
+                                                        &delta);
+            if (ok == true) {
+                osw_drv_target_survey_fill(t, &s->cfg, c, &delta);
+            }
+
+            target_survey_record_free(e->record);
+        }
+
+        e->record = record;
+    }
+
+    if (t == &buf && buf.used > 0) {
+        LOGT("%s: %s: reporting %zu bytes", __func__, s->phy_name, buf.used);
+        osw_drv_report_stats(drv, &buf);
+        osw_tlv_fini(&buf);
+    }
+
+    s->requested = false;
+    return true;
+}
+
+static void
+osw_drv_target_survey_req_phy(struct osw_drv_target *target,
+                              struct osw_drv_dummy_phy *phy)
+{
+    const char *phy_name = phy->phy_name.buf;
+    struct osw_drv_dummy *dummy = &target->dummy;
+    struct osw_drv_target_survey *s = ds_tree_find(&target->surveys, phy_name);
+    if (s == NULL) {
+        s = CALLOC(1, sizeof(*s));
+        s->phy_name = STRDUP(phy_name);
+        s->target = target;
+        s->type = RADIO_SCAN_TYPE_ONCHAN;
+        ds_tree_init(&s->entries, ds_int_cmp, struct osw_drv_target_survey_entry, node);
+        ds_dlist_init(&s->list, target_survey_record_t, node);
+        ds_tree_insert(&target->surveys, s, s->phy_name);
+    }
+
+    const bool pok = osw_drv_target_prep_rcfg(&s->cfg, dummy, phy);
+    LOGT("%s: %s: prep=%d requested=%d", __func__, phy_name, pok, s->requested);
+    if (pok == false) return;
+    if (s->requested == true) return;
+
+    const uint32_t n = 1;
+    uint32_t *chans = phy_to_chan(dummy, phy_name);
+    LOGT("%s: %s: chan=%p (%u)", __func__, phy_name, chans, chans ? chans[0] : 0);
+    if (chans == NULL) return;
+
+    s->requested = true;
+    const bool gok = target_stats_survey_get(&s->cfg, chans, n, s->type, osw_drv_target_survey_cb, &s->list, s);
+    LOGT("%s: %s: get=%d", __func__, phy_name, gok);
+    if (gok == false) s->requested = false;
+    FREE(chans);
+}
+
+static void
+osw_drv_target_request_stats_cb(struct osw_drv *drv)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_target *target = container_of(dummy, struct osw_drv_target, dummy);
+    struct osw_drv_dummy_phy *phy;
+    struct osw_tlv t = {0};
+
+    target->stats = &t;
+    ds_tree_foreach(&target->dummy.phy_tree, phy) {
+        const char *phy_name = phy->phy_name.buf;
+        const radio_scan_type_t type = RADIO_SCAN_TYPE_ONCHAN;
+        uint32_t *chans = phy_to_chan(dummy, phy_name);
+        const uint32_t n_chans = chans ? 1 : 0;
+        const uint32_t dwell = 0;
+
+        osw_drv_target_survey_req_phy(target, phy);
+        osw_drv_target_scan_req_phy(target, phy, type, dwell, chans, n_chans);
+    }
+
+    osw_drv_target_fill_sta_stats(dummy, &t);
+    osw_drv_report_stats(drv, &t);
+    osw_tlv_fini(&t);
+    target->stats = NULL;
 }
 
+static void
+osw_drv_target_request_sta_deauth_cb(struct osw_drv *drv,
+                                     const char *phy_name,
+                                     const char *vif_name,
+                                     const struct osw_hwaddr *mac_addr,
+                                     int dot11_reason_code)
+{
+    const bsal_disc_type_t type = BSAL_DISC_TYPE_DEAUTH;
+    /* FIXME: Calling BSAL API isn't ideal, but is
+     * quick and easy. It fits the bill for now.
+     */
+    const int err = target_bsal_client_disconnect(vif_name,
+                                                  mac_addr->octet,
+                                                  type,
+                                                  dot11_reason_code);
+    WARN_ON(err != 0);
+}
 
 static struct osw_drv_target g_osw_drv_target = {
     .dummy = {
@@ -88,9 +753,14 @@ static struct osw_drv_target g_osw_drv_t
         .fini_phy_fn = osw_drv_target_fini_phy_cb,
         .fini_vif_fn = osw_drv_target_fini_vif_cb,
         .request_config_fn = osw_drv_target_request_config_cb,
+        .request_stats_fn = osw_drv_target_request_stats_cb,
+        .request_sta_deauth_fn = osw_drv_target_request_sta_deauth_cb,
+        .push_frame_tx_fn = osw_drv_target_push_frame_tx_cb,
     },
     .phy_tree = DS_TREE_INIT(ds_str_cmp, struct osw_drv_target_phy, node),
     .vif_tree = DS_TREE_INIT(ds_str_cmp, struct osw_drv_target_vif, node),
+    .bsal_vap_tree = DS_TREE_INIT(ds_str_cmp, struct osw_drv_target_bsal_vap, node),
+    .bsal_ue_tree = DS_TREE_INIT((ds_key_cmp_t*) osw_hwaddr_cmp, struct osw_drv_target_bsal_ue, node),
 };
 
 static int
@@ -327,6 +997,27 @@ osw_drv_target_phyconf2schema(const stru
 }
 
 static void
+osw_drv_target_wpa2schema(struct schema_Wifi_VIF_Config *vconf,
+                          struct schema_Wifi_VIF_Config_flags *vchanged,
+                          const struct osw_wpa *wpa,
+                          bool wpa_changed)
+{
+    SCHEMA_SET_BOOL(vconf->wpa, wpa->rsn || wpa->wpa);
+
+    if (wpa->wpa) {
+        if (wpa->akm_psk) SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "wpa-psk");
+        WARN_ON(wpa->akm_sae == true);
+    }
+    if (wpa->rsn) {
+        if (wpa->akm_psk) SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "wpa2-psk");
+        if (wpa->akm_sae) SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "sae");
+    }
+
+    vchanged->wpa = wpa_changed;
+    vchanged->wpa_key_mgmt = wpa_changed;
+}
+
+static void
 osw_drv_target_vifconf2schema(struct osw_drv_vif_config *vif,
                               const struct schema_Wifi_VIF_Config *base_vconf,
                               struct schema_Wifi_VIF_Config *vconf,
@@ -335,6 +1026,7 @@ osw_drv_target_vifconf2schema(struct osw
                               int *n_cconfs)
 {
     struct osw_drv_vif_config_ap *ap = &vif->u.ap;
+    struct osw_drv_vif_config_sta *sta = &vif->u.sta;
     struct osw_hwaddr_str mac_str;
     size_t i;
 
@@ -460,9 +1152,49 @@ osw_drv_target_vifconf2schema(struct osw
             break;
         case OSW_VIF_STA:
             SCHEMA_SET_STR(vconf->mode, "sta");
-            /* FIXME: First phase is getting GW/AP-only
-             * working. STA operation needs to wait.
+
+            /* FIXME: STA is always expected to be the
+             * first/primary interface on a radio implying
+             * that its mac address should be identical to
+             * the radio's base mac address for ACL
+             * filtering purposes on root APs. This isn't
+             * ideal in this case, but that's what the
+             * underlying API expects so play along.
              */
+            SCHEMA_SET_INT(vconf->vif_radio_idx, 0);
+
+            struct osw_drv_vif_sta_network *net = sta->network;
+            if (net != NULL) {
+                if (net->next == NULL) {
+                    osw_drv_target_wpa2schema(vconf, vchanged, &net->wpa,
+                                              sta->network_changed);
+                    SCHEMA_KEY_VAL_APPEND(vconf->wpa_psks, "key", net->psk.str);
+                    SCHEMA_SET_STR(vconf->ssid, net->ssid.buf);
+                    if (osw_hwaddr_is_zero(&net->bssid) == false) {
+                        const char *str = osw_hwaddr2str(&net->bssid, &mac_str);
+                        SCHEMA_SET_STR(vconf->parent, str);
+                    }
+                    *n_cconfs = 0;
+                }
+                else {
+                    /* More than 1 network. Typically onboarding case. */
+                    int j = 0;
+                    while (net && j < *n_cconfs) {
+                        struct schema_Wifi_Credential_Config *c = &cconfs[j];
+                        SCHEMA_SET_STR(c->ssid, net->ssid.buf);
+                        SCHEMA_SET_STR(c->onboard_type, "gre");
+                        /* FIXME: This assumes only WPA-PSK. This is fine for
+                         * now because nothing else is really used and this
+                         * adapter code is a throw-away.
+                         */
+                        SCHEMA_KEY_VAL_APPEND(c->security, "encryption", "WPA-PSK");
+                        SCHEMA_KEY_VAL_APPEND(c->security, "key", net->psk.str);
+                        net = net->next;
+                        j++;
+                    }
+                    *n_cconfs = j;
+                }
+            }
             break;
     }
 }
@@ -528,6 +1260,41 @@ osw_drv_target_schema2phystate(const str
            &info->mac_addr.octet[4],
            &info->mac_addr.octet[5]);
 
+    if (strlen(rstate->country) > 0) {
+        sscanf(rstate->country, "%c%c",
+               &info->reg_domain.ccode[0],
+               &info->reg_domain.ccode[1]);
+        const char *slash = strstr(rstate->country, "/");
+        if (slash != NULL) {
+            info->reg_domain.revision = atoi(slash+1);
+        }
+    }
+
+    if (rstate->hw_params_len > 0) {
+        const char *country_id = SCHEMA_KEY_VAL_NULL(rstate->hw_params, "country_id");
+        const char *reg_domain = SCHEMA_KEY_VAL_NULL(rstate->hw_params, "reg_domain");
+        if (country_id != NULL && reg_domain != NULL) {
+            info->reg_domain.ccode[0] = '0';
+            info->reg_domain.ccode[1] = '0';
+            info->reg_domain.revision = atoi(reg_domain);
+            /* FIXME: Infer OSW_DRV_REG_DFS_ to info->reg_domain.dfs */
+#if 0
+            switch (atoi(reg_domain)) {
+                case 0x3a: info->reg_domain.dfs = OSW_DRV_REG_DFS_FCC; break;
+                case 0x37: info->reg_domain.dfs = OSW_DRV_REG_DFS_ETSI; break;
+                case 0x833a:
+                case 0x8faf: info->reg_domain.dfs = OSW_DRV_REG_DFS_FCC; break;
+                case 0x0014:
+                case 0x0014:
+                case 0x822a:
+                case 0x82be:
+                case 0x8178:
+                case 0x8158:
+            }
+#endif
+        }
+    }
+
     for (i = 0; i < rstate->channels_len; i++) {
         const int ch = atoi(rstate->channels_keys[i]);
         const int freq = osw_drv_target_ch2freq(band_num, ch);
@@ -557,10 +1324,119 @@ osw_drv_target_schema2phystate(const str
 }
 
 static void
+osw_drv_target_vconf2vstate(const struct schema_Wifi_VIF_Config *vconf,
+                            struct schema_Wifi_VIF_State *vstate)
+{
+    SCHEMA_CPY_STR(vstate->pmf, vconf->pmf);
+    SCHEMA_CPY_INT(vstate->ft_mobility_domain, vconf->ft_mobility_domain);
+    SCHEMA_CPY_INT(vstate->wpa, vconf->wpa);
+    SCHEMA_CPY_INT(vstate->wpa_pairwise_tkip, vconf->wpa_pairwise_tkip);
+    SCHEMA_CPY_INT(vstate->rsn_pairwise_tkip, vconf->rsn_pairwise_tkip);
+    SCHEMA_CPY_INT(vstate->wpa_pairwise_ccmp, vconf->wpa_pairwise_ccmp);
+    SCHEMA_CPY_INT(vstate->rsn_pairwise_ccmp, vconf->rsn_pairwise_ccmp);
+
+    int i;
+    for (i = 0; i < vconf->wpa_key_mgmt_len; i++) {
+        SCHEMA_VAL_APPEND(vstate->wpa_key_mgmt, vconf->wpa_key_mgmt[i]);
+    }
+}
+
+static void
+osw_drv_target_schema2wpa(const struct schema_Wifi_VIF_State *vstate,
+                          struct osw_wpa *wpa)
+{
+    wpa->group_rekey_seconds = OSW_WPA_GROUP_REKEY_UNDEFINED;
+
+    if (vstate->wpa == false) return;
+
+    wpa->group_rekey_seconds = vstate->group_rekey_exists == true
+                             ? vstate->group_rekey
+                             : OSW_WPA_GROUP_REKEY_UNDEFINED;
+    wpa->ft_mobility_domain = vstate->ft_mobility_domain;
+
+    bool wpa1 = false;
+    bool wpa2 = false;
+    bool sae = false;
+
+    int i;
+    for (i = 0; i < vstate->wpa_key_mgmt_len; i++) {
+        if (strcmp(vstate->wpa_key_mgmt[i], "wpa-psk") == 0) {
+            wpa->akm_psk = true;
+            wpa1 = true;
+        }
+        if (strcmp(vstate->wpa_key_mgmt[i], "wpa2-psk") == 0) {
+            wpa->akm_psk = true;
+            wpa2 = true;
+        }
+        if (strcmp(vstate->wpa_key_mgmt[i], "sae") == 0) {
+            wpa->akm_sae = true;
+        }
+        if (strstr(vstate->wpa_key_mgmt[i], "ft-wpa") != NULL) {
+            wpa->akm_ft_psk = true;
+        }
+        if (strcmp(vstate->wpa_key_mgmt[i], "ft-sae") == 0) {
+            wpa->akm_ft_sae = true;
+        }
+    }
+
+    if (vstate->wpa_pairwise_tkip_exists == true) {
+        const bool tkip = vstate->wpa_pairwise_tkip ||
+                          vstate->rsn_pairwise_tkip;
+        const bool ccmp = vstate->wpa_pairwise_ccmp ||
+                          vstate->rsn_pairwise_ccmp;
+
+        wpa->wpa = vstate->wpa_pairwise_tkip ||
+                   vstate->wpa_pairwise_ccmp;
+        wpa->rsn = vstate->rsn_pairwise_tkip ||
+                   vstate->rsn_pairwise_ccmp;
+        wpa->pairwise_tkip = tkip;
+        wpa->pairwise_ccmp = ccmp;
+        wpa->pmf = OSW_PMF_DISABLED;
+
+        if (strcmp(vstate->pmf, "optional") == 0) wpa->pmf = OSW_PMF_OPTIONAL;
+        if (strcmp(vstate->pmf, "required") == 0) wpa->pmf = OSW_PMF_REQUIRED;
+    }
+    else {
+        if (wpa1) {
+            wpa->wpa = true;
+            wpa->pairwise_tkip = true;
+        }
+
+        if (wpa2) {
+            wpa->rsn = true;
+            wpa->pairwise_ccmp = true;
+        }
+
+        if (sae) {
+            wpa->rsn = true;
+            wpa->pairwise_ccmp = true;
+        }
+
+        /* FIXME: This will need to change eventually because PMF will
+         * be configurable explicitly in the future.  Also for 802.1X /
+         * WPA3-Enterprise. That'll come later though.
+         */
+        const bool need_11w = wpa->akm_sae ||
+                              wpa->akm_ft_sae;
+        const bool non_11w = wpa->akm_psk ||
+                             wpa->akm_ft_psk;
+
+        if (need_11w == false)
+            wpa->pmf = OSW_PMF_DISABLED;
+        else if (non_11w == true) /* wpa3 transition */
+            wpa->pmf = OSW_PMF_OPTIONAL;
+        else /* wpa3 only */
+            wpa->pmf = OSW_PMF_REQUIRED;
+        }
+}
+
+static void
 osw_drv_target_schema2vifstate(const struct schema_Wifi_VIF_State *vstate,
                                const struct schema_Wifi_Radio_State *rstate,
                                struct osw_drv_vif_state *info)
 {
+    struct osw_drv_vif_state_sta *vsta = &info->u.sta;
+
     info->enabled = vstate->enabled;
     info->vif_type = strcmp(vstate->mode, "ap") == 0 ? OSW_VIF_AP :
                      strcmp(vstate->mode, "ap_vlan") == 0 ? OSW_VIF_AP_VLAN :
@@ -582,7 +1458,9 @@ osw_drv_target_schema2vifstate(const str
             STRSCPY_WARN(info->u.ap.ssid.buf, vstate->ssid);
             info->u.ap.ssid.len = strlen(vstate->ssid);
             info->u.ap.beacon_interval_tu = rstate->bcn_int;
-            info->u.ap.isolated = vstate->ap_bridge == true ? false : true;
+            info->u.ap.isolated = vstate->ap_bridge_exists == true
+                                ? (vstate->ap_bridge == true ? false : true)
+                                : false;
             info->u.ap.mcast2ucast = vstate->mcast2ucast;
             info->u.ap.acl_policy = osw_drv_target_type2policy(vstate->mac_list_type);
             info->u.ap.ssid_hidden = strcmp(vstate->ssid_broadcast, "enabled") == 0 ? false :
@@ -615,52 +1493,7 @@ osw_drv_target_schema2vifstate(const str
                 info->u.ap.channel.width = osw_drv_target_htmode2width(rstate->ht_mode);
                 /* FIXME: derive center_freq0_mhz */
             }
-            info->u.ap.wpa.group_rekey_seconds = vstate->group_rekey_exists == true
-                                               ? vstate->group_rekey
-                                               : OSW_WPA_GROUP_REKEY_UNDEFINED;
-            info->u.ap.wpa.ft_mobility_domain = vstate->ft_mobility_domain;
-            if (vstate->wpa) {
-                int i;
-                for (i = 0; i < vstate->wpa_key_mgmt_len; i++) {
-                    if (strcmp(vstate->wpa_key_mgmt[i], "wpa-psk") == 0) {
-                        info->u.ap.wpa.wpa = true;
-                        info->u.ap.wpa.akm_psk = true;
-                        info->u.ap.wpa.pairwise_tkip = true;
-                    }
-                    if (strcmp(vstate->wpa_key_mgmt[i], "wpa2-psk") == 0) {
-                        info->u.ap.wpa.rsn = true;
-                        info->u.ap.wpa.akm_psk = true;
-                        info->u.ap.wpa.pairwise_ccmp = true;
-                    }
-                    if (strcmp(vstate->wpa_key_mgmt[i], "sae") == 0) {
-                        info->u.ap.wpa.rsn = true;
-                        info->u.ap.wpa.akm_sae = true;
-                        info->u.ap.wpa.pairwise_ccmp = true;
-                    }
-                    if (strstr(vstate->wpa_key_mgmt[i], "ft-wpa") != NULL) {
-                        info->u.ap.wpa.akm_ft_psk = true;
-                    }
-                    if (strcmp(vstate->wpa_key_mgmt[i], "ft-sae") == 0) {
-                        info->u.ap.wpa.akm_ft_sae = true;
-                    }
-                }
-
-                /* FIXME: This will need to change eventually because PMF will
-                 * be configurable explicitly in the future.  Also for 802.1X /
-                 * WPA3-Enterprise. That'll come later though.
-                 */
-                bool need_11w = info->u.ap.wpa.akm_sae ||
-                                info->u.ap.wpa.akm_ft_sae;
-                bool non_11w = info->u.ap.wpa.akm_psk ||
-                               info->u.ap.wpa.akm_ft_psk;
-
-               if (need_11w == false)
-                    info->u.ap.wpa.pmf = OSW_PMF_DISABLED;
-               else if (non_11w == true) /* wpa3 transition */
-                    info->u.ap.wpa.pmf = OSW_PMF_OPTIONAL;
-               else /* wpa3 only */
-                    info->u.ap.wpa.pmf = OSW_PMF_REQUIRED;
-            }
+            osw_drv_target_schema2wpa(vstate, &info->u.ap.wpa);
             if (vstate->mac_list_len > 0) {
                 int i;
                 info->u.ap.acl.count = vstate->mac_list_len;
@@ -701,6 +1534,53 @@ osw_drv_target_schema2vifstate(const str
         case OSW_VIF_AP_VLAN:
             break;
         case OSW_VIF_STA:
+            {
+                int band_num = osw_drv_target_band2num(rstate->freq_band);
+                vsta->link.channel.control_freq_mhz = osw_drv_target_ch2freq(band_num, vstate->channel);
+                vsta->link.channel.width = osw_drv_target_htmode2width(rstate->ht_mode);
+            }
+            STRSCPY_WARN(vsta->link.ssid.buf, vstate->ssid);
+            STRSCPY_WARN(vsta->link.psk.str, vstate->wpa_psks[0]);
+            vsta->link.ssid.len = strlen(vstate->ssid);
+            vsta->link.status = strlen(vstate->parent) > 0
+                              ? OSW_DRV_VIF_STATE_STA_LINK_CONNECTED
+                              : OSW_DRV_VIF_STATE_STA_LINK_DISCONNECTED;
+            memset(&vsta->link.bssid, 0, sizeof(vsta->link.bssid));
+            osw_hwaddr_from_cstr(vstate->parent, &vsta->link.bssid);
+            osw_drv_target_schema2wpa(vstate, &vsta->link.wpa);
+            break;
+    }
+}
+
+static void
+osw_drv_target_nets2vifstate(const char *vif_name,
+                             struct ds_dlist *nets,
+                             struct osw_drv_vif_state *state)
+{
+    struct osw_drv_vif_state_sta *vsta = &state->u.sta;
+    struct osw_drv_vif_sta_network **tail = &vsta->network;
+    struct osw_drv_target_net *i;
+    size_t cnt = 0;
+
+    switch (state->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            ds_dlist_foreach(nets, i) {
+                struct osw_drv_vif_sta_network *n = CALLOC(1, sizeof(*n));
+                n->bssid = i->bssid;
+                n->ssid = i->ssid;
+                n->psk = i->psk;
+                n->wpa = i->wpa;
+                *tail = n;
+                tail = &n->next;
+                cnt++;
+            }
+            LOGI("osw: drv: target: %s: reporting %zu nets", vif_name, cnt);
             break;
     }
 }
@@ -723,6 +1603,13 @@ osw_drv_target_phy_set(struct osw_drv_ta
     target_radio_config_set2(&rconf, &rchanged);
 }
 
+static void// forward decl
+osw_drv_target_vif_set_nets(struct osw_drv_target *target,
+                            const char *vif_name,
+                            const struct schema_Wifi_VIF_Config *vconf,
+                            const struct schema_Wifi_Credential_Config *c,
+                            int n);
+
 static void
 osw_drv_target_vif_set(struct osw_drv_target *priv,
                        struct osw_drv_phy_config *phy,
@@ -737,6 +1624,7 @@ osw_drv_target_vif_set(struct osw_drv_ta
     struct schema_Wifi_Credential_Config cconfs[8] = {0};
     int n_cconfs = ARRAY_SIZE(cconfs);
     const struct osw_state_phy_info *info = osw_state_phy_lookup(phy->phy_name);
+    const char *vif_name = vif->vif_name;
 
     ovsdb_table_select_one(&table_Wifi_Radio_Config,
                            SCHEMA_COLUMN(Wifi_Radio_Config, if_name),
@@ -750,7 +1638,10 @@ osw_drv_target_vif_set(struct osw_drv_ta
 
     osw_drv_target_phyconf2schema(phy, info, &base_rconf, &rconf, &rchanged);
     osw_drv_target_vifconf2schema(vif, &base_vconf, &vconf, &vchanged, cconfs, &n_cconfs);
-    target_vif_config_set2(&vconf, &rconf, cconfs, &vchanged, n_cconfs);
+    const bool ok = target_vif_config_set2(&vconf, &rconf, cconfs, &vchanged, n_cconfs);
+    if (ok == true) {
+        osw_drv_target_vif_set_nets(priv, vif_name, &vconf, cconfs, n_cconfs);
+    }
 }
 
 static const char *
@@ -784,12 +1675,21 @@ osw_drv_target_vif_get_phy_name(const st
 }
 
 static void
+osw_drv_target_vif_free_nets(struct osw_drv_target_vif *vif)
+{
+    struct osw_drv_target_net *n;
+    while ((n = ds_dlist_remove_head(&vif->nets)) != NULL)
+        FREE(n);
+}
+
+static void
 osw_drv_target_vif_gc(struct osw_drv_target_vif *vif)
 {
     struct ds_tree *tree = &vif->target->vif_tree;
 
     if (osw_drv_target_vif_get_exists(vif) == true) return;
 
+    osw_drv_target_vif_free_nets(vif);
     ds_tree_remove(tree, vif);
     FREE(vif->vif_name);
     FREE(vif->phy_name);
@@ -806,6 +1706,10 @@ osw_drv_target_vif_sync(struct osw_drv_t
     struct schema_Wifi_Radio_State rzero = {0};
     const struct schema_Wifi_Radio_State *rstate = &rzero;
     struct osw_drv_vif_state state = {0};
+    const bool exists = osw_drv_target_vif_get_exists(vif);
+
+    if (phy_name == NULL && exists == false)
+        return true;
 
     if (phy_name == NULL)
         return false;
@@ -818,7 +1722,8 @@ osw_drv_target_vif_sync(struct osw_drv_t
         SCHEMA_CPY_STR(vif->state.mode, vif->config.mode);
 
     osw_drv_target_schema2vifstate(&vif->state, rstate, &state);
-    state.exists = osw_drv_target_vif_get_exists(vif);
+    osw_drv_target_nets2vifstate(vif_name, &vif->nets, &state);
+    state.exists = exists;
 
     if (state.exists == true)
         osw_drv_dummy_set_vif(dummy, phy_name, vif_name, &state);
@@ -848,6 +1753,7 @@ osw_drv_target_vif_get(struct osw_drv_ta
         vif->target = target;
         vif->vif_name = STRDUP(vif_name);
         ev_timer_init(&vif->work, osw_drv_target_vif_work_cb, 0, 0);
+        ds_dlist_init(&vif->nets, struct osw_drv_target_net, node);
         ds_tree_insert(tree, vif, vif->vif_name);
     }
     return vif;
@@ -903,6 +1809,60 @@ osw_drv_target_vif_set_exists(struct osw
 }
 
 static void
+osw_drv_target_vif_set_nets(struct osw_drv_target *target,
+                            const char *vif_name,
+                            const struct schema_Wifi_VIF_Config *vconf,
+                            const struct schema_Wifi_Credential_Config *c,
+                            int n)
+{
+    struct osw_drv_target_vif *vif = osw_drv_target_vif_get(target, vif_name);
+
+    LOGI("osw: drv: target: %s: setting nets (%d)", vif_name, n);
+
+    osw_drv_target_vif_free_nets(vif);
+
+    if (n == 0) {
+        struct schema_Wifi_VIF_State vstate = {0};
+        struct osw_drv_target_net *net = CALLOC(1, sizeof(*net));
+        const char *parent = strlen(vconf->parent) > 0
+                           ? vconf->parent
+                           : "00:00:00:00:00:00";
+        const char *psk = vconf->wpa_psks[0];
+        const char *ssid = vconf->ssid;
+        const size_t ssid_len = strlen(ssid);
+
+        /* FIXME */
+        osw_drv_target_vconf2vstate(vconf, &vstate);
+        osw_drv_target_schema2wpa(&vstate, &net->wpa);
+
+        osw_hwaddr_from_cstr(parent, &net->bssid);
+        STRSCPY_WARN(net->psk.str, psk);
+        STRSCPY_WARN(net->ssid.buf, ssid);
+        net->ssid.len = ssid_len;
+
+        ds_dlist_insert_tail(&vif->nets, net);
+    }
+
+    for (; n--; c++) {
+        struct osw_drv_target_net *net = CALLOC(1, sizeof(*net));
+
+        STRSCPY_WARN(net->ssid.buf, c->ssid);
+        net->ssid.len = strlen(c->ssid);
+
+        const char *psk = SCHEMA_KEY_VAL(c->security, "key");
+        STRSCPY_WARN(net->psk.str, psk);
+
+        net->wpa.rsn = true;
+        net->wpa.akm_psk = true;
+        net->wpa.pairwise_ccmp = true;
+
+        ds_dlist_insert_tail(&vif->nets, net);
+    }
+
+    osw_drv_target_vif_sched(vif);
+}
+
+static void
 osw_drv_target_op_vstate_cb(const struct schema_Wifi_VIF_State *vstate,
                             const char *phy)
 {
@@ -951,6 +1911,8 @@ osw_drv_target_op_rstate_cb(const struct
      * deviate from the desired configuration though.
      */
     ds_tree_foreach(&target->vif_tree, tvif) {
+        if (strlen(tvif->state.if_name) == 0) continue;
+
         const char *phy_name = osw_drv_target_vif_get_phy_name(tvif);
         if (phy_name == NULL) continue;
         if (strcmp(phy_name, rstate->if_name) != 0) continue;
@@ -966,6 +1928,7 @@ osw_drv_target_op_client_cb(const struct
 {
     struct osw_drv_target *target = &g_osw_drv_target;
     struct osw_drv_dummy *dummy = &target->dummy;
+    const char *phy_name = NULL;
     struct osw_drv_sta_state info = {0};
     struct osw_hwaddr addr;
 
@@ -982,6 +1945,16 @@ osw_drv_target_op_client_cb(const struct
 
     osw_drv_dummy_set_sta(dummy, NULL, vif, &addr, &info);
 
+    {
+        bsal_client_info_t info = {0};
+        int err = target_bsal_client_info(vif, addr.octet, &info);
+        if (err == 0) {
+            osw_drv_dummy_set_sta_ies(dummy, phy_name, vif, &addr,
+                                      info.assoc_ies,
+                                      info.assoc_ies_len);
+        }
+    }
+
     LOGI("osw: drv: target: %s: %s: %sconnected: key_id=%s/%d",
          vif, client->mac, associated ? "" : "dis",
          client->key_id, info.key_id);
@@ -1028,15 +2001,182 @@ osw_drv_target_op_flush_clients_cb(const
     osw_drv_target_flush_sta(vif);
 }
 
+static void
+osw_drv_target_op_csa_rx_cb(const char *phy_name,
+                            const char *vif_name,
+                            int chan_pri_freq_mhz,
+                            int chan_width_mhz)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
+    const struct osw_channel channel = {
+        .control_freq_mhz = chan_pri_freq_mhz,
+        .width = chan_width_mhz == 20 ? OSW_CHANNEL_20MHZ
+            : chan_width_mhz == 40 ? OSW_CHANNEL_40MHZ
+            : chan_width_mhz == 80 ? OSW_CHANNEL_80MHZ
+            : chan_width_mhz == 160 ? OSW_CHANNEL_160MHZ
+            : OSW_CHANNEL_20MHZ,
+    };
+
+    osw_drv_report_vif_channel_change_advertised(dummy->drv,
+                                                 phy_name,
+                                                 vif_name,
+                                                 &channel);
+}
+
 static const struct target_radio_ops g_rops = {
     .op_vstate = osw_drv_target_op_vstate_cb,
     .op_rstate = osw_drv_target_op_rstate_cb,
     .op_client = osw_drv_target_op_client_cb,
     .op_clients = osw_drv_target_op_clients_cb,
     .op_flush_clients = osw_drv_target_op_flush_clients_cb,
+    .op_csa_rx = osw_drv_target_op_csa_rx_cb,
 };
 
 static void
+osw_drv_target_bsal_vap_register(struct osw_drv_target *target,
+                                 const char *vif_name)
+{
+    assert(target != NULL);
+    assert(vif_name != NULL);
+
+    struct osw_drv_target_bsal_vap *vap = CALLOC(1, sizeof(*vap));
+    //struct osw_drv_target_bsal_ue *ue;
+
+    STRSCPY(vap->cfg.ifname, vif_name);
+    vap->cfg.inact_check_sec = 10;
+    vap->cfg.inact_tmout_sec_normal = 60;
+    vap->cfg.inact_tmout_sec_overload = 30;
+    if (target_bsal_iface_add(&vap->cfg) != 0) {
+        LOGW("osw: drv: target: failed to register vif: %s in basl", vif_name);
+        goto error;
+    }
+
+    ds_tree_insert(&target->bsal_vap_tree, vap, vap->cfg.ifname);
+    LOGI("osw: drv: target: registered vif: %s in bsal", vif_name);
+
+    /*ds_tree_foreach(&target->bsal_ue_tree, ue) {
+        if (target_bsal_client_add(vap->cfg.ifname, (const uint8_t*)&ue->mac_addr.octet, &ue->cfg) == 0) {
+            LOGI("osw: drv: target: registered client: "OSW_HWADDR_FMT" at vif: %s in bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+        }
+        else {
+            LOGW("osw: drv: target: failed to register client: "OSW_HWADDR_FMT" at vif: %s in bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+        }
+    }*/
+
+    return;
+
+error:
+    FREE(vap);
+}
+
+static void
+osw_drv_target_bsal_vap_unregister(struct osw_drv_target *target,
+                                   const char *vif_name)
+{
+    assert(target != NULL);
+    assert(vif_name != NULL);
+
+    struct osw_drv_target_bsal_vap *vap;
+    //struct osw_drv_target_bsal_ue *ue;
+
+    vap = ds_tree_find(&target->bsal_vap_tree, vif_name);
+    if (vap == NULL) {
+        LOGW("osw: drv: target: failed to find vif: %s in regitered bsal's vap tree", vif_name);
+        return;
+    }
+
+    ds_tree_remove(&target->bsal_vap_tree, vap);
+    if (target_bsal_iface_remove(&vap->cfg) == 0)
+        LOGI("osw: drv: target: unregistered vif: %s from bsal", vif_name);
+    else
+        LOGW("osw: drv: target: failed to unregister vif: %s from basl", vif_name);
+
+    /*ds_tree_foreach(&target->bsal_ue_tree, ue) {
+        if (target_bsal_client_remove(vap->cfg.ifname, (const uint8_t*)&ue->mac_addr.octet) == 0) {
+            LOGI("osw: drv: target: unregistered client: "OSW_HWADDR_FMT" from vif: %s from bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+        }
+        else {
+            LOGW("osw: drv: target: failed to unregister client: "OSW_HWADDR_FMT" from vif: %s from bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+        }
+    }*/
+
+    FREE(vap);
+}
+
+static void
+osw_drv_target_bsal_ue_register(struct osw_drv_target *target,
+                                const struct osw_hwaddr *mac_addr)
+{
+    assert(target != NULL);
+    assert(mac_addr != NULL);
+
+    struct osw_drv_target_bsal_ue *ue = CALLOC(1, sizeof(*ue));
+    //struct osw_drv_target_bsal_vap *vap;
+
+    memcpy(&ue->mac_addr, mac_addr, sizeof(ue->mac_addr));
+
+    /*ds_tree_foreach(&target->bsal_vap_tree, vap) {
+        if (target_bsal_client_add(vap->cfg.ifname, (const uint8_t*)&ue->mac_addr.octet, &ue->cfg) == 0) {
+            LOGI("osw: drv: target: registered client: "OSW_HWADDR_FMT" at vif: %s in bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+        }
+        else {
+            LOGW("osw: drv: target: failed to register client: "OSW_HWADDR_FMT" at vif: %s in bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+            goto error;
+        }
+    }*/
+
+    ds_tree_insert(&target->bsal_ue_tree, ue, &ue->mac_addr);
+
+    return;
+
+error:
+    FREE(ue);
+}
+
+static void
+osw_drv_target_bsal_ue_unregister(struct osw_drv_target *target,
+                                  const struct osw_hwaddr *mac_addr)
+{
+    assert(target != NULL);
+    assert(mac_addr != NULL);
+
+    struct osw_drv_target_bsal_ue *ue;
+    //struct osw_drv_target_bsal_vap *vap;
+
+    ue = ds_tree_find(&target->bsal_ue_tree, mac_addr);
+    if (ue == NULL) {
+        LOGW("osw: drv: target: failed to find client: "OSW_HWADDR_FMT" in regitered bsal's ue tree",
+             OSW_HWADDR_ARG(mac_addr));
+        return;
+    }
+
+    /*ds_tree_foreach(&target->bsal_vap_tree, vap) {
+        if (target_bsal_client_remove(vap->cfg.ifname, (const uint8_t*)&ue->mac_addr.octet) == 0) {
+            LOGI("osw: drv: target: unregistered client: "OSW_HWADDR_FMT" from vif: %s from bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+        }
+        else {
+            LOGW("osw: drv: target: failed to unregister client: "OSW_HWADDR_FMT" from vif: %s from bsal",
+                 OSW_HWADDR_ARG(&ue->mac_addr), vap->cfg.ifname);
+        }
+    }*/
+
+    ds_tree_remove(&target->bsal_ue_tree, ue);
+
+    return;
+
+error:
+    FREE(ue);
+}
+
+static void
 callback_Wifi_Radio_Config(ovsdb_update_monitor_t *mon,
                            struct schema_Wifi_Radio_Config *old,
                            struct schema_Wifi_Radio_Config *rconf,
@@ -1067,6 +2207,73 @@ callback_Wifi_VIF_Config(ovsdb_update_mo
 }
 
 static void
+callback_Band_Steering_Config(ovsdb_update_monitor_t *mon,
+                              struct schema_Band_Steering_Config *old,
+                              struct schema_Band_Steering_Config *steer_cfg,
+                              ovsdb_cache_row_t *row)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+            if (steer_cfg->ifnames_len > 0) {
+                int i;
+                for (i = 0; i < steer_cfg->ifnames_len; i++)
+                    osw_drv_target_bsal_vap_register(target, steer_cfg->ifnames_keys[i]);
+            }
+
+            if (steer_cfg->if_name_2g_exists == true)
+                osw_drv_target_bsal_vap_register(target, steer_cfg->if_name_5g);
+
+            if (steer_cfg->if_name_5g_exists == true)
+                osw_drv_target_bsal_vap_register(target, steer_cfg->if_name_2g);
+            break;
+        case OVSDB_UPDATE_MODIFY:
+            break;
+        case OVSDB_UPDATE_DEL:
+            if (old->ifnames_len > 0) {
+                int i;
+                for (i = 0; i < old->ifnames_len; i++)
+                    osw_drv_target_bsal_vap_unregister(target, old->ifnames_keys[i]);
+            }
+
+            if (old->if_name_2g_exists == true)
+                osw_drv_target_bsal_vap_unregister(target, old->if_name_5g);
+
+            if (old->if_name_5g_exists == true)
+                osw_drv_target_bsal_vap_unregister(target, old->if_name_2g);
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+}
+
+static void
+callback_Band_Steering_Clients(ovsdb_update_monitor_t *mon,
+                               struct schema_Band_Steering_Clients *old,
+                               struct schema_Band_Steering_Clients *steer_client,
+                               ovsdb_cache_row_t *row)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_hwaddr mac_addr;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+            osw_hwaddr_from_cstr(steer_client->mac, &mac_addr);
+            osw_drv_target_bsal_ue_register(target, &mac_addr);
+            break;
+        case OVSDB_UPDATE_MODIFY:
+            break;
+        case OVSDB_UPDATE_DEL:
+            osw_hwaddr_from_cstr(old->mac, &mac_addr);
+            osw_drv_target_bsal_ue_unregister(target, &mac_addr);
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+}
+
+static void
 osw_drv_target_conf_sched(struct osw_drv_target *target)
 {
     ev_timer_stop(EV_DEFAULT_ &target->conf_timer);
@@ -1135,11 +2342,126 @@ osw_drv_target_ovsdb_retry_cb(EV_P_ ev_t
 
     OVSDB_CACHE_MONITOR(Wifi_Radio_Config, true);
     OVSDB_CACHE_MONITOR(Wifi_VIF_Config, true);
+    OVSDB_CACHE_MONITOR(Band_Steering_Config, true);
+    OVSDB_CACHE_MONITOR(Band_Steering_Clients, true);
 
     ev_timer_stop(EV_A_ t);
     LOGI("osw: drv: target: ovsdb ready");
 }
 
+static void
+osw_drv_target_bsal_handle_probe_req_event(const struct osw_drv_target_vif *vif,
+                                           const bsal_ev_probe_req_t *event)
+{
+    assert(vif != NULL);
+    assert(event != NULL);
+
+    struct osw_drv_report_vif_probe_req probe_req;
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
+
+    memset(&probe_req, 0, sizeof(probe_req));
+    memcpy(&probe_req.sta_addr.octet, event->client_addr, sizeof(probe_req.sta_addr.octet));
+    probe_req.snr = event->rssi;
+    if (vif->state.ssid_exists == true && strlen(vif->state.ssid) > 0) {
+        STRSCPY(probe_req.ssid.buf, vif->state.ssid);
+        probe_req.ssid.len = strlen(vif->state.ssid) - 1;
+    }
+
+    /* This log is very noisy! */
+    /*LOGD("osw: drv: target: client: "OSW_HWADDR_FMT" sent bsal probe req event snr: %u ssid: %s vif: %s",
+         OSW_HWADDR_ARG(&probe_req.sta_addr), probe_req.snr, probe_req.ssid.len > 0 ? "present" : "(null)",
+         vif->vif_name);*/
+
+    if (probe_req.ssid.len == 0) {
+        struct osw_drv_target_vif *entry;
+        ds_tree_foreach(&target->vif_tree, entry)
+            osw_drv_report_vif_probe_req(dummy->drv, vif->phy_name, vif->vif_name, &probe_req);
+    }
+    else {
+        osw_drv_report_vif_probe_req(dummy->drv, vif->phy_name, vif->vif_name, &probe_req);
+    }
+}
+
+static void
+osw_drv_target_bsal_handle_action_frame_event(const struct osw_drv_target_vif *vif,
+                                              const bsal_ev_action_frame_t *event)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
+    const struct osw_drv_dot11_frame *frame = (const void *)event->data;
+    const void *out_of_bounds = event->data + event->data_len;
+
+    assert(event != NULL);
+    assert(event->data != NULL);
+
+    if (vif == NULL) {
+        LOGD("osw: drv: target: recevied bsal event for unknown vif");
+        return;
+    }
+
+    if ((const void *)&frame->u.action.category >= out_of_bounds) {
+        LOGI("osw: drv: target: %s: action frame: too short", vif->vif_name);
+        return;
+    }
+
+    switch (frame->u.action.category) {
+        case DOT11_RRM_MEAS_REP_IE_CATEGORY_CODE:
+            if ((const void *)&frame->u.action.u.rrm_meas_rep.action >= out_of_bounds) {
+                LOGI("osw: drv: target: %s: action frame: rrm meas rep: too short", vif->vif_name);
+                return;
+            }
+
+            switch (frame->u.action.u.rrm_meas_rep.action) {
+                case DOT11_RRM_MEAS_REP_IE_ACTION_CODE:
+                    LOGD("osw: drv: target: %s: recevied bsal event: RRM Report", vif->vif_name);
+                    osw_drv_report_vif_rrm_report(dummy->drv,
+                                                  vif->phy_name,
+                                                  vif->vif_name,
+                                                  event->data,
+                                                  (size_t)event->data_len);
+                    break;
+            }
+            break;
+        default:
+            LOGD("osw: drv: target: recevied bsal event: unhandled event: 0x%02X", event->data[0]);
+            break;
+    }
+}
+
+static void
+osw_drv_target_bsal_event_cb(bsal_event_t *event)
+{
+    assert(event != NULL);
+
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_target_vif *vif = ds_tree_find(&target->vif_tree, event->ifname);
+
+    if (vif == NULL) {
+        LOGD("osw: drv: target: recevied bsal event for unknown vif: %s", event->ifname);
+        return;
+    }
+
+    if (vif->phy_name == NULL) {
+        LOGD("osw: drv: target: recevied bsal event for vif: %s at unknown phy", event->ifname);
+        return;
+    }
+
+    switch(event->type) {
+        case BSAL_EVENT_PROBE_REQ:
+            osw_drv_target_bsal_handle_probe_req_event(vif, &event->data.probe_req);
+            break;
+        case BSAL_EVENT_AUTH_FAIL:
+            /* TODO */
+            break;
+        case BSAL_EVENT_ACTION_FRAME:
+            osw_drv_target_bsal_handle_action_frame_event(vif, &event->data.action_frame);
+            break;
+        default:
+            ; /* nop */
+    }
+}
+
 void
 osw_drv_target_init_cb(struct osw_drv *drv)
 {
@@ -1151,10 +2473,20 @@ osw_drv_target_init_cb(struct osw_drv *d
         return;
     }
 
+    if (target_bsal_init(osw_drv_target_bsal_event_cb, EV_DEFAULT) != 0) {
+        LOGI("osw: drv: target: failed to initialize bsal");
+        return;
+    }
+
     ev_timer_init(&target->conf_timer, osw_drv_target_conf_timer_cb, 0, 0);
     ev_timer_init(&target->ovsdb_retry, osw_drv_target_ovsdb_retry_cb, 0, 1);
     ev_timer_start(EV_DEFAULT_ &target->ovsdb_retry);
 
+    setenv("TARGET_DISABLE_FALLBACK_PARENTS", "1", 1);
+    setenv("TARGET_DISABLE_ACL_ENFORCE", "1", 1);
+    setenv("TARGET_DISABLE_ACL_MASKING", "1", 1);
+    setenv("TARGET_DISABLE_OVSDB_POKING", "1", 1);
+
     target_radio_init(&g_rops);
     target->drv = drv;
     osw_drv_set_priv(drv, dummy);
@@ -1189,17 +2521,21 @@ osw_drv_target_request_sta_deauth_cb(str
 }
 */
 
-static void
-osw_drv_target_module_init(void *data)
+OSW_MODULE(osw_drv_target)
 {
-    struct osw_drv_dummy *dummy = &g_osw_drv_target.dummy;
+    struct ev_loop *loop = OSW_MODULE_LOAD(osw_ev);
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
 
     if (osw_drv_target_enabled() == false) {
         LOGI("osw: drv: target: disabled");
-        return;
+        return NULL;
     }
 
     osw_drv_dummy_init(dummy);
+    ds_dlist_init(&target->scans, struct osw_drv_target_scan, node);
+    ds_tree_init(&target->surveys, ds_str_cmp, struct osw_drv_target_survey, node);
+    target_init(TARGET_INIT_MGR_SM, loop);
 
     /* FIXME: This could use ovsdb_cache to avoid explicit
      * selects. It might be more efficient.
@@ -1207,19 +2543,13 @@ osw_drv_target_module_init(void *data)
     OVSDB_TABLE_INIT(Wifi_Radio_Config, if_name);
     OVSDB_TABLE_INIT(Wifi_Radio_State, if_name);
     OVSDB_TABLE_INIT(Wifi_VIF_Config, if_name);
-}
+    OVSDB_TABLE_INIT_NO_KEY(Band_Steering_Config);
+    OVSDB_TABLE_INIT(Band_Steering_Clients, mac);
 
-static void
-osw_drv_target_module_fini(void *data)
-{
+    return NULL;
 }
 
-MODULE(osw_drv_target_module,
-       osw_drv_target_module_init,
-       osw_drv_target_module_fini);
-
-static void
-osw_drv_target_ut_phyconf2schema_cb(void *data)
+OSW_UT(osw_drv_target_ut_phyconf2schema)
 {
     struct schema_Wifi_Radio_Config base_rconf = {0};
     struct schema_Wifi_Radio_Config rconf = {0};
@@ -1469,8 +2799,7 @@ osw_drv_target_ut_phyconf2schema_cb(void
     assert(strcmp(rconf.hw_mode, "11n") == 0);
 }
 
-static void
-osw_drv_target_ut_vifconf2schema_ap_cb(void *data)
+OSW_UT(osw_drv_target_ut_vifconf2schema_ap)
 {
     struct schema_Wifi_VIF_Config base_vconf = {0};
     struct schema_Wifi_VIF_Config vconf = {0};
@@ -1743,18 +3072,7 @@ osw_drv_target_ut_vifconf2schema_ap_cb(v
     assert(vconf.vif_radio_idx_exists == false);
 }
 
-static void
-osw_drv_target_ut_schema2phystate_cb(void *data)
-{
-}
-
-static void
-osw_drv_target_ut_schema2vifstate_cb(void *data)
-{
-}
-
-static void
-osw_drv_target_ut_cs_cb(void *data)
+OSW_UT(osw_drv_target_ut_cs)
 {
     struct osw_drv_phy_state info = {0};
     const enum osw_channel_state_dfs s = OSW_CHANNEL_NON_DFS;
@@ -1771,8 +3089,7 @@ osw_drv_target_ut_cs_cb(void *data)
     assert(osw_drv_target_cs_lookup(info.channel_states, info.n_channel_states, 4000) == &info.channel_states[2]);
 }
 
-static void
-osw_drv_target_ut_ch2freq_cb(void *data)
+OSW_UT(osw_drv_target_ut_ch2freq)
 {
     assert(osw_drv_target_ch2freq(1, 1) == 0);
     assert(osw_drv_target_ch2freq(2, 1) == 2412);
@@ -1781,8 +3098,7 @@ osw_drv_target_ut_ch2freq_cb(void *data)
     assert(osw_drv_target_ch2freq(6, 2) == 5935);
 }
 
-static void
-osw_drv_target_ut_keyid_cb(void *data)
+OSW_UT(osw_drv_target_ut_keyid)
 {
     char buf[64];
 
@@ -1793,24 +3109,3 @@ osw_drv_target_ut_keyid_cb(void *data)
     osw_drv_target_keyid2str(buf, sizeof(buf), 10); assert(strcmp(buf, "key-10") == 0);
     osw_drv_target_keyid2str(buf, sizeof(buf), -2); assert(strcmp(buf, "key--2") == 0);
 }
-
-static void
-osw_drv_target_ut_module_init(void *data)
-{
-    osw_ut_register("ow_drv_target_ut_keyid", osw_drv_target_ut_keyid_cb, NULL);
-    osw_ut_register("ow_drv_target_ut_cs", osw_drv_target_ut_cs_cb, NULL);
-    osw_ut_register("ow_drv_target_ut_cs", osw_drv_target_ut_ch2freq_cb, NULL);
-    osw_ut_register("ow_drv_target_ut_phyconf2schema", osw_drv_target_ut_phyconf2schema_cb, NULL);
-    osw_ut_register("ow_drv_target_ut_vifconf2schema_ap", osw_drv_target_ut_vifconf2schema_ap_cb, NULL);
-    osw_ut_register("ow_drv_target_ut_schema2phystate", osw_drv_target_ut_schema2phystate_cb, NULL);
-    osw_ut_register("ow_drv_target_ut_schema2vifstate", osw_drv_target_ut_schema2vifstate_cb, NULL);
-}
-
-static void
-osw_drv_target_ut_module_fini(void *data)
-{
-}
-
-MODULE(osw_drv_target_ut_module,
-       osw_drv_target_ut_module_init,
-       osw_drv_target_ut_module_fini);
Index: core/src/lib/osw/src/osw_drv_ut.c
===================================================================
--- core.orig/src/lib/osw/src/osw_drv_ut.c
+++ core/src/lib/osw/src/osw_drv_ut.c
@@ -1,5 +1,12 @@
 #include "osw_ut.h"
-#include <osw_req.h>
+#include <osw_conf.h>
+#include <osw_mux.h>
+
+struct osw_drv_ut_frame_tx {
+    unsigned int submitted_cnt;
+    unsigned int failed_cnt;
+    unsigned int dropped_cnt;
+};
 
 struct osw_drv_ut_state_obs {
     struct osw_state_observer obs;
@@ -53,13 +60,13 @@ static struct osw_drv_ut_vif vifs[] = {
 };
 
 static struct osw_drv_ut_drv_priv drv1_priv[] = {
-    { "phy1", { "vif1", "vif2" }, {}, NULL},
+    { "phy1", { "vif1", "vif2" }, {}, NULL },
     { "phy2", { "vif3" }, {}, NULL },
-    { NULL, {}, {}, NULL }
+    { NULL, {}, {}, NULL },
 };
 static struct osw_drv_ut_drv_priv drv2_priv[] = {
     { "phy3", { "vif4" }, {}, NULL },
-    { NULL, {}, {}, NULL }
+    { NULL, {}, {}, NULL },
 };
 
 static bool
@@ -160,7 +167,8 @@ osw_drv_ut_drv_get_vif_list_cb(struct os
     for (; priv->phy_name; priv++)
         if (strcmp(priv->phy_name, phy_name) == 0)
             for (vif_name = priv->vif_names; *vif_name != NULL; vif_name++)
-                report_vif_fn(*vif_name, fn_priv);
+                if (strlen(*vif_name) > 0)
+                    report_vif_fn(*vif_name, fn_priv);
 }
 
 static void
@@ -205,14 +213,14 @@ osw_drv_ut_drv_request_vif_state_cb(stru
         if (strcmp(vifs[i].vif_name, vif_name) == 0)
             break;
 
-    info.exists = osw_drv_ut_drv_vif_exists(priv, phy_name, vif_name),
+    info.exists = osw_drv_ut_drv_vif_exists(priv, phy_name, vif_name);
     info.vif_type = OSW_VIF_AP;
 
     if (i != ARRAY_SIZE(vifs))
         memcpy(&info, &vifs[i].state, sizeof(info));
 
 
-    printf("%s: vif_name=%s exists=%d\n", __func__, vif_name, info.exists);
+    printf("%s: vif_name=%s exists=%d %d\n", __func__, vif_name, info.exists, osw_drv_ut_drv_vif_exists(priv, phy_name, vif_name));
     osw_drv_report_vif_state(priv->drv, phy_name, vif_name, &info);
 }
 
@@ -326,12 +334,61 @@ osw_drv_ut_work(struct osw_drv_ut_state_
         printf("%s: work %d\n", __func__,  n);
         ev_run(EV_DEFAULT_ EVRUN_ONCE);
     } while (n-- > 0 && obs->busy == true);
+
     printf("%s: work done\n", __func__);
     assert(n > 0);
 }
 
 static void
-osw_drv_ut_1_fn(void *data)
+osw_drv_ut_push_frame_tx_submit_cb(struct osw_drv *drv,
+                                   const char *phy_name,
+                                   const char *vif_name,
+                                   struct osw_drv_frame_tx_desc *desc)
+{
+    osw_drv_report_frame_tx_state_submitted(drv);
+}
+
+static void
+osw_drv_ut_push_frame_tx_nop_cb(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name,
+                                struct osw_drv_frame_tx_desc *desc)
+{
+    /* Don't react on frame */
+}
+
+static void
+osw_drv_ut_push_frame_tx_fail_cb(struct osw_drv *drv,
+                                 const char *phy_name,
+                                 const char *vif_name,
+                                 struct osw_drv_frame_tx_desc *desc)
+{
+    osw_drv_report_frame_tx_state_failed(drv);
+}
+
+static void
+osw_drv_ut_frame_tx_result_cb(const struct osw_drv_frame_tx_desc *desc,
+                              enum osw_frame_tx_result result,
+                              void *caller_priv)
+{
+    assert(caller_priv != NULL);
+
+    struct osw_drv_ut_frame_tx *frame = (struct osw_drv_ut_frame_tx*) caller_priv;
+
+    switch (result) {
+        case OSW_FRAME_TX_RESULT_SUBMITTED:
+            frame->submitted_cnt++;
+            break;
+        case OSW_FRAME_TX_RESULT_FAILED:
+            frame->failed_cnt++;
+            break;
+        case OSW_FRAME_TX_RESULT_DROPPED:
+            frame->dropped_cnt++;
+            break;
+    }
+}
+
+OSW_UT(osw_drv_ut_1)
 {
     static const struct osw_drv_ops drv1 = {
         .name = "drv1",
@@ -387,7 +444,7 @@ osw_drv_ut_1_fn(void *data)
     {
         printf("checking conf from state\n");
 
-        struct osw_conf *conf = osw_conf_build_from_state();
+        struct ds_tree *phy_tree = osw_conf_build_from_state();
         struct osw_conf_phy *phy;
         struct osw_conf_vif *vif;
         struct osw_conf_psk *psk;
@@ -398,10 +455,10 @@ osw_drv_ut_1_fn(void *data)
         size_t n_acl;
         int key_id;
 
-        ds_tree_foreach(&conf->phy_tree, phy) n_phy++;
+        ds_tree_foreach(phy_tree, phy) n_phy++;
         assert(n_phy == 3);
 
-        phy = ds_tree_find(&conf->phy_tree, "phy1"); assert(phy != NULL);
+        phy = ds_tree_find(phy_tree, "phy1"); assert(phy != NULL);
         vif = ds_tree_find(&phy->vif_tree, "vif1"); assert(vif != NULL); assert(vif->phy == phy);
         key_id = 1; psk = ds_tree_find(&vif->u.ap.psk_tree, &key_id);
         assert(psk != NULL);
@@ -422,13 +479,13 @@ osw_drv_ut_1_fn(void *data)
         n_acl = 0; ds_tree_foreach(&vif->u.ap.acl_tree, acl) n_acl++; assert(n_acl == 0);
         n_vif = 0; ds_tree_foreach(&phy->vif_tree, vif) n_vif++; assert(n_vif == 2);
 
-        phy = ds_tree_find(&conf->phy_tree, "phy2"); assert(phy != NULL);
+        phy = ds_tree_find(phy_tree, "phy2"); assert(phy != NULL);
         vif = ds_tree_find(&phy->vif_tree, "vif3"); assert(vif != NULL); assert(vif->phy == phy);
         n_psk = 0; ds_tree_foreach(&vif->u.ap.psk_tree, psk) n_psk++; assert(n_psk == 0);
         n_acl = 0; ds_tree_foreach(&vif->u.ap.acl_tree, acl) n_acl++; assert(n_acl == 0);
         n_vif = 0; ds_tree_foreach(&phy->vif_tree, vif) n_vif++; assert(n_vif == 1);
 
-        phy = ds_tree_find(&conf->phy_tree, "phy3"); assert(phy != NULL);
+        phy = ds_tree_find(phy_tree, "phy3"); assert(phy != NULL);
         vif = ds_tree_find(&phy->vif_tree, "vif4"); assert(vif != NULL); assert(vif->phy == phy);
         n_psk = 0; ds_tree_foreach(&vif->u.ap.psk_tree, psk) n_psk++; assert(n_psk == 0);
         n_acl = 0; ds_tree_foreach(&vif->u.ap.acl_tree, acl) n_acl++; assert(n_acl == 0);
@@ -537,15 +594,485 @@ osw_drv_ut_1_fn(void *data)
     osw_drv_ut_work(&obs1);
 }
 
-static void
-osw_drv_ut_init(void *data)
+OSW_UT(osw_drv_ut_frame_tx_getters_setters)
 {
-    osw_ut_register("osw_drv_ut_1", osw_drv_ut_1_fn, NULL);
+    static struct osw_drv_ops drv1 = {
+        .name = "drv1",
+        .init_fn = osw_drv_ut_drv_init_1_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+        .push_frame_tx_fn = osw_drv_ut_push_frame_tx_submit_cb,
+    };
+
+    static struct osw_drv_ut_state_obs obs1 = {
+        .busy = false,
+        .obs = {
+            .idle_fn = osw_drv_ut_state_idle_cb,
+            .busy_fn = osw_drv_ut_state_busy_cb,
+            .phy_added_fn = osw_drv_ut_core1_op_phy_added_cb,
+            .phy_removed_fn = osw_drv_ut_core1_op_phy_removed_cb,
+            .phy_changed_fn = osw_drv_ut_core1_op_phy_changed_cb,
+            .vif_added_fn = osw_drv_ut_core1_op_vif_added_cb,
+            .vif_removed_fn = osw_drv_ut_core1_op_vif_removed_cb,
+            .vif_changed_fn = osw_drv_ut_core1_op_vif_changed_cb,
+            .name = "drv ut 1 state",
+        },
+    };
+
+    /* Use only VIF3@PHY2 from driver no. 1 */
+    const uint8_t raw_frame[] = { 0xA, 0xB, 0xC, };
+    struct osw_drv_ut_frame_tx frame_a = { 0, 0, 0, };
+    struct osw_drv_frame_tx_desc *frame_a_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_a);
+
+    osw_time_set_mono_clk(0);
+    osw_drv_init();
+    osw_drv_register_ops(&drv1);
+    osw_state_register_observer(&obs1.obs);
+    osw_drv_ut_work(&obs1);
+
+    /*
+     * Verify getters & setters
+     */
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(osw_drv_frame_tx_desc_get_frame(frame_a_desc) == NULL);
+    assert(osw_drv_frame_tx_desc_get_frame_len(frame_a_desc) == 0);
+    osw_drv_frame_tx_desc_set_frame(frame_a_desc, raw_frame, sizeof(raw_frame));
+    assert(memcmp(raw_frame, osw_drv_frame_tx_desc_get_frame(frame_a_desc), sizeof(raw_frame)) == 0);
+    assert(osw_drv_frame_tx_desc_get_frame_len(frame_a_desc) == sizeof(raw_frame));
 }
 
-static void
-osw_drv_ut_fini(void *data)
+OSW_UT(osw_drv_ut_frame_tx_reuse_desc)
+{
+    static struct osw_drv_ops drv1 = {
+        .name = "drv1",
+        .init_fn = osw_drv_ut_drv_init_1_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+        .push_frame_tx_fn = osw_drv_ut_push_frame_tx_submit_cb,
+    };
+
+    static struct osw_drv_ut_state_obs obs1 = {
+        .busy = false,
+        .obs = {
+            .idle_fn = osw_drv_ut_state_idle_cb,
+            .busy_fn = osw_drv_ut_state_busy_cb,
+            .phy_added_fn = osw_drv_ut_core1_op_phy_added_cb,
+            .phy_removed_fn = osw_drv_ut_core1_op_phy_removed_cb,
+            .phy_changed_fn = osw_drv_ut_core1_op_phy_changed_cb,
+            .vif_added_fn = osw_drv_ut_core1_op_vif_added_cb,
+            .vif_removed_fn = osw_drv_ut_core1_op_vif_removed_cb,
+            .vif_changed_fn = osw_drv_ut_core1_op_vif_changed_cb,
+            .name = "drv ut 1 state",
+        },
+    };
+
+    /* Use only VIF3@PHY2 */
+    const uint8_t raw_frame[] = { 0xA, 0xB, 0xC, };
+    struct osw_drv_ut_frame_tx frame_a = { 0, 0, 0, };
+    struct osw_drv_frame_tx_desc *frame_a_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_a);
+
+    osw_time_set_mono_clk(0);
+    osw_drv_init();
+    osw_drv_register_ops(&drv1);
+    osw_state_register_observer(&obs1.obs);
+    osw_drv_ut_work(&obs1);
+
+    /*
+     * Setup frame
+     */
+    osw_drv_frame_tx_desc_set_frame(frame_a_desc, raw_frame, sizeof(raw_frame));
+
+    /*
+     * Try to schedule frame on invalid phy and vif
+     */
+    assert(osw_mux_frame_tx_schedule("invalid_phy", NULL, frame_a_desc) == false);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(osw_mux_frame_tx_schedule("phy2", "invalid_vif", frame_a_desc) == false);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+
+    /*
+     * Re-use frame, schedule & submit
+     */
+    drv1.push_frame_tx_fn = osw_drv_ut_push_frame_tx_submit_cb;
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_a_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == true);
+    osw_drv_ut_work(&obs1);
+
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(frame_a.submitted_cnt == 1);
+    assert(frame_a.failed_cnt == 0);
+    assert(frame_a.dropped_cnt == 0);
+
+    /*
+     * Re-use frame, schedule & fail
+     */
+    drv1.push_frame_tx_fn = osw_drv_ut_push_frame_tx_fail_cb;
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_a_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == true);
+    osw_drv_ut_work(&obs1);
+
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(frame_a.submitted_cnt == 1);
+    assert(frame_a.failed_cnt == 1);
+    assert(frame_a.dropped_cnt == 0);
+}
+
+OSW_UT(osw_drv_ut_frame_tx_no_drv_feedback_after_push)
+{
+    static struct osw_drv_ops drv1 = {
+        .name = "drv1",
+        .init_fn = osw_drv_ut_drv_init_1_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+        .push_frame_tx_fn = osw_drv_ut_push_frame_tx_nop_cb,
+    };
+
+    static struct osw_drv_ut_state_obs obs1 = {
+        .busy = false,
+        .obs = {
+            .idle_fn = osw_drv_ut_state_idle_cb,
+            .busy_fn = osw_drv_ut_state_busy_cb,
+            .phy_added_fn = osw_drv_ut_core1_op_phy_added_cb,
+            .phy_removed_fn = osw_drv_ut_core1_op_phy_removed_cb,
+            .phy_changed_fn = osw_drv_ut_core1_op_phy_changed_cb,
+            .vif_added_fn = osw_drv_ut_core1_op_vif_added_cb,
+            .vif_removed_fn = osw_drv_ut_core1_op_vif_removed_cb,
+            .vif_changed_fn = osw_drv_ut_core1_op_vif_changed_cb,
+            .name = "drv ut 1 state",
+        },
+    };
+
+    /* Use only VIF3@PHY2 */
+    const uint8_t raw_frame[] = { 0xA, 0xB, 0xC, };
+    struct osw_drv_ut_frame_tx frame_a = { 0, 0, 0, };
+    struct osw_drv_frame_tx_desc *frame_a_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_a);
+
+    osw_time_set_mono_clk(0);
+    osw_drv_init();
+    osw_drv_register_ops(&drv1);
+    osw_state_register_observer(&obs1.obs);
+    osw_drv_ut_work(&obs1);
+
+    /*
+     * Setup frame
+     */
+    osw_drv_frame_tx_desc_set_frame(frame_a_desc, raw_frame, sizeof(raw_frame));
+
+    /*
+     * Schedule frame
+     */
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_a_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == true);
+    osw_drv_ut_work(&obs1);
+
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(frame_a.submitted_cnt == 0);
+    assert(frame_a.failed_cnt == 0);
+    assert(frame_a.dropped_cnt == 1);
+}
+
+OSW_UT(osw_drv_ut_frame_tx_multiple_frames)
 {
+    static struct osw_drv_ops drv1 = {
+        .name = "drv1",
+        .init_fn = osw_drv_ut_drv_init_1_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+        .push_frame_tx_fn = osw_drv_ut_push_frame_tx_nop_cb,
+    };
+
+    static struct osw_drv_ut_state_obs obs1 = {
+        .busy = false,
+        .obs = {
+            .idle_fn = osw_drv_ut_state_idle_cb,
+            .busy_fn = osw_drv_ut_state_busy_cb,
+            .phy_added_fn = osw_drv_ut_core1_op_phy_added_cb,
+            .phy_removed_fn = osw_drv_ut_core1_op_phy_removed_cb,
+            .phy_changed_fn = osw_drv_ut_core1_op_phy_changed_cb,
+            .vif_added_fn = osw_drv_ut_core1_op_vif_added_cb,
+            .vif_removed_fn = osw_drv_ut_core1_op_vif_removed_cb,
+            .vif_changed_fn = osw_drv_ut_core1_op_vif_changed_cb,
+            .name = "drv ut 1 state",
+        },
+    };
+
+    /* Use only VIF3@PHY2 */
+    const uint8_t raw_frame[] = { 0xA, 0xB, 0xC, };
+    struct osw_drv_ut_frame_tx frame_a = { 0, 0, 0, };
+    struct osw_drv_ut_frame_tx frame_b = { 0, 0, 0, };
+    struct osw_drv_ut_frame_tx frame_c = { 0, 0, 0, };
+    struct osw_drv_frame_tx_desc *frame_a_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_a);
+    struct osw_drv_frame_tx_desc *frame_b_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_b);
+    struct osw_drv_frame_tx_desc *frame_c_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_c);
+
+    osw_time_set_mono_clk(0);
+    osw_drv_init();
+    osw_drv_register_ops(&drv1);
+    osw_state_register_observer(&obs1.obs);
+    osw_drv_ut_work(&obs1);
+
+    /*
+     * Setup frame
+     */
+    osw_drv_frame_tx_desc_set_frame(frame_a_desc, raw_frame, sizeof(raw_frame));
+    osw_drv_frame_tx_desc_set_frame(frame_b_desc, raw_frame, sizeof(raw_frame));
+    osw_drv_frame_tx_desc_set_frame(frame_c_desc, raw_frame, sizeof(raw_frame));
+
+    /*
+     * Schedule frames
+     */
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_a_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == true);
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_b_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_b_desc) == true);
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_c_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_c_desc) == true);
+    osw_drv_ut_work(&obs1);
+
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(frame_a.submitted_cnt == 0);
+    assert(frame_a.failed_cnt == 0);
+    assert(frame_a.dropped_cnt == 1);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_b_desc) == false);
+    assert(frame_b.submitted_cnt == 0);
+    assert(frame_b.failed_cnt == 0);
+    assert(frame_b.dropped_cnt == 1);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_c_desc) == false);
+    assert(frame_c.submitted_cnt == 0);
+    assert(frame_c.failed_cnt == 0);
+    assert(frame_c.dropped_cnt == 1);
 }
 
-MODULE(osw_drv_ut, osw_drv_ut_init, osw_drv_ut_fini);
+OSW_UT(osw_drv_ut_frame_tx_schedule_remove_vif)
+{
+    static struct osw_drv_ops drv1 = {
+        .name = "drv1",
+        .init_fn = osw_drv_ut_drv_init_1_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+        .push_frame_tx_fn = osw_drv_ut_push_frame_tx_submit_cb,
+    };
+
+    static struct osw_drv_ut_state_obs obs1 = {
+        .busy = false,
+        .obs = {
+            .idle_fn = osw_drv_ut_state_idle_cb,
+            .busy_fn = osw_drv_ut_state_busy_cb,
+            .phy_added_fn = osw_drv_ut_core1_op_phy_added_cb,
+            .phy_removed_fn = osw_drv_ut_core1_op_phy_removed_cb,
+            .phy_changed_fn = osw_drv_ut_core1_op_phy_changed_cb,
+            .vif_added_fn = osw_drv_ut_core1_op_vif_added_cb,
+            .vif_removed_fn = osw_drv_ut_core1_op_vif_removed_cb,
+            .vif_changed_fn = osw_drv_ut_core1_op_vif_changed_cb,
+            .name = "drv ut 1 state",
+        },
+    };
+
+    /* Use only VIF3@PHY2 */
+    const uint8_t raw_frame[] = { 0xA, 0xB, 0xC, };
+    struct osw_drv_ut_frame_tx frame_a = { 0, 0, 0, };
+    struct osw_drv_frame_tx_desc *frame_a_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_a);
+
+    osw_time_set_mono_clk(0);
+    osw_drv_init();
+    osw_drv_register_ops(&drv1);
+    osw_state_register_observer(&obs1.obs);
+    osw_drv_ut_work(&obs1);
+
+    /*
+     * Setup frame
+     */
+    osw_drv_frame_tx_desc_set_frame(frame_a_desc, raw_frame, sizeof(raw_frame));
+
+    /*
+     * Schedule frame & remove vif1
+     */
+    drv1.push_frame_tx_fn = osw_drv_ut_push_frame_tx_submit_cb;
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_a_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == true);
+    drv1_priv[1].vif_names[0] = "";
+    osw_drv_report_vif_changed(drv1_priv[0].drv, "phy2", "vif3");
+    osw_drv_ut_work(&obs1);
+
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(frame_a.submitted_cnt == 0);
+    assert(frame_a.failed_cnt == 0);
+    assert(frame_a.dropped_cnt == 1);
+}
+
+OSW_UT(osw_drv_ut_frame_tx_schedule_remove_phy)
+{
+    static struct osw_drv_ops drv1 = {
+        .name = "drv1",
+        .init_fn = osw_drv_ut_drv_init_1_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+        .push_frame_tx_fn = osw_drv_ut_push_frame_tx_submit_cb,
+    };
+
+    static struct osw_drv_ut_state_obs obs1 = {
+        .busy = false,
+        .obs = {
+            .idle_fn = osw_drv_ut_state_idle_cb,
+            .busy_fn = osw_drv_ut_state_busy_cb,
+            .phy_added_fn = osw_drv_ut_core1_op_phy_added_cb,
+            .phy_removed_fn = osw_drv_ut_core1_op_phy_removed_cb,
+            .phy_changed_fn = osw_drv_ut_core1_op_phy_changed_cb,
+            .vif_added_fn = osw_drv_ut_core1_op_vif_added_cb,
+            .vif_removed_fn = osw_drv_ut_core1_op_vif_removed_cb,
+            .vif_changed_fn = osw_drv_ut_core1_op_vif_changed_cb,
+            .name = "drv ut 1 state",
+        },
+    };
+
+    /* Use only VIF3@PHY2 */
+    const uint8_t raw_frame[] = { 0xA, 0xB, 0xC, };
+    struct osw_drv_ut_frame_tx frame_a = { 0, 0, 0, };
+    struct osw_drv_frame_tx_desc *frame_a_desc = osw_drv_frame_tx_desc_new(osw_drv_ut_frame_tx_result_cb, &frame_a);
+
+    osw_time_set_mono_clk(0);
+    osw_drv_init();
+    osw_drv_register_ops(&drv1);
+    osw_state_register_observer(&obs1.obs);
+    osw_drv_ut_work(&obs1);
+
+    /*
+     * Setup frame
+     */
+    osw_drv_frame_tx_desc_set_frame(frame_a_desc, raw_frame, sizeof(raw_frame));
+
+    /*
+     * Schedule frame & remove phy1
+     */
+    drv1.push_frame_tx_fn = osw_drv_ut_push_frame_tx_submit_cb;
+    assert(osw_mux_frame_tx_schedule("phy2", "vif3", frame_a_desc) == true);
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == true);
+    drv1_priv[1].phy_name = "";
+    osw_drv_report_phy_changed(drv1_priv[0].drv, "phy2");
+    osw_drv_ut_work(&obs1);
+
+    assert(osw_drv_frame_tx_desc_is_scheduled(frame_a_desc) == false);
+    assert(frame_a.submitted_cnt == 0);
+    assert(frame_a.failed_cnt == 0);
+    assert(frame_a.dropped_cnt == 1);
+}
+
+OSW_UT(osw_drv_ut_csa_to_phy)
+{
+    struct osw_channel_state cs1[] = {
+        { .channel = { .control_freq_mhz = 2412 } },
+        { .channel = { .control_freq_mhz = 2417 } },
+    };
+    struct osw_channel_state cs2[] = {
+        { .channel = { .control_freq_mhz = 5180 } },
+        { .channel = { .control_freq_mhz = 5200 } },
+    };
+    struct osw_drv_phy p1 = {
+        .phy_name = "phy1",
+        .cur_state = {
+            .channel_states = cs1,
+            .n_channel_states = ARRAY_SIZE(cs1),
+        },
+    };
+    struct osw_drv_phy p2 = {
+        .phy_name = "phy2",
+        .cur_state = {
+            .channel_states = cs2,
+            .n_channel_states = ARRAY_SIZE(cs2),
+        },
+    };
+    struct ds_tree drvs;
+    struct osw_drv d1 = {0};
+    struct osw_drv_vif v1 = {
+        .vif_name = "vif1",
+        .cur_state = { .vif_type = OSW_VIF_STA },
+        .phy = &p1,
+    };
+    struct osw_drv_vif v2 = {
+        .vif_name = "vif2",
+        .cur_state = { .vif_type = OSW_VIF_STA },
+        .phy = &p2,
+    };
+    const struct osw_channel c2412 = { .control_freq_mhz = 2412 };
+    const struct osw_channel c2417 = { .control_freq_mhz = 2417 };
+    const struct osw_channel c2437 = { .control_freq_mhz = 2437 };
+    const struct osw_channel c5180 = { .control_freq_mhz = 5180 };
+    const struct osw_channel c5200 = { .control_freq_mhz = 5200 };
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+
+    ds_tree_init(&drvs, ds_void_cmp, struct osw_drv, node);
+    ds_tree_init(&d1.phy_tree, ds_str_cmp, struct osw_drv_phy, node);
+    ds_tree_init(&p1.vif_tree, ds_str_cmp, struct osw_drv_vif, node);
+    ds_tree_init(&p2.vif_tree, ds_str_cmp, struct osw_drv_vif, node);
+    ds_tree_insert(&drvs, &d1, &d1);
+    ds_tree_insert(&d1.phy_tree, &p1, p1.phy_name);
+    ds_tree_insert(&d1.phy_tree, &p2, p2.phy_name);
+    ds_tree_insert(&p1.vif_tree, &v1, v1.vif_name);
+    ds_tree_insert(&p2.vif_tree, &v2, v2.vif_name);
+
+
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p1, &c2412) == true);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p1, &c2417) == true);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p1, &c2437) == false);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p1, &c5180) == false);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p1, &c5200) == false);
+
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p2, &c2412) == false);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p2, &c2417) == false);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p2, &c2437) == false);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p2, &c5180) == true);
+    OSW_UT_EVAL(osw_drv_phy_supports_channel(&p2, &c5200) == true);
+
+    OSW_UT_EVAL(osw_drv_phy_lookup_for_channel(&drvs, &c2412) == &p1);
+    OSW_UT_EVAL(osw_drv_phy_lookup_for_channel(&drvs, &c2417) == &p1);
+    OSW_UT_EVAL(osw_drv_phy_lookup_for_channel(&drvs, &c5180) == &p2);
+    OSW_UT_EVAL(osw_drv_phy_lookup_for_channel(&drvs, &c5200) == &p2);
+
+    OSW_UT_EVAL(osw_drv_phy_lookup_for_channel(&drvs, &c2437) == NULL);
+
+    osw_drv_report_vif_channel_change_advertised_xphy__(&drvs, &d1, p1.phy_name, v1.vif_name, &c2412, &phy, &vif);
+    OSW_UT_EVAL(phy == &p1);
+
+    osw_drv_report_vif_channel_change_advertised_xphy__(&drvs, &d1, p1.phy_name, v1.vif_name, &c5180, &phy, &vif);
+    OSW_UT_EVAL(phy == &p2);
+
+    osw_drv_report_vif_channel_change_advertised_xphy__(&drvs, &d1, p1.phy_name, v1.vif_name, &c2437, &phy, &vif);
+    OSW_UT_EVAL(phy == NULL);
+
+    osw_drv_report_vif_channel_change_advertised_xphy__(&drvs, &d1, p2.phy_name, v2.vif_name, &c5200, &phy, &vif);
+    OSW_UT_EVAL(phy == &p2);
+
+    osw_drv_report_vif_channel_change_advertised_xphy__(&drvs, &d1, p2.phy_name, v2.vif_name, &c2412, &phy, &vif);
+    OSW_UT_EVAL(phy == &p1);
+}
Index: core/src/lib/osw/src/osw_drv_wifihal_3_0.c
===================================================================
--- core.orig/src/lib/osw/src/osw_drv_wifihal_3_0.c
+++ core/src/lib/osw/src/osw_drv_wifihal_3_0.c
@@ -12,6 +12,7 @@
 #include <memutil.h>
 #include <os_time.h>
 #include <osw_drv.h>
+#include <osw_drv_common.h>
 #include <osw_conf.h>
 
 /* 3rd party */
@@ -34,12 +35,14 @@
     int64_t b = clock_mono_ms(); \
     LOGT("%sL%d@%s: [%s] end %"PRIu64" msec", __FILE__, __LINE__, __func__, #fn, b); \
     int64_t c = b - a; \
-    LOGD("%sL%d@%s: [%s] took %"PRIu64" msec", __FILE__, __LINE__, __func__, #fn, c); \
+    LOGT("%sL%d@%s: [%s] took %"PRIu64" msec", __FILE__, __LINE__, __func__, #fn, c); \
     if (c >= MEASURE_MAX) \
         LOGW("%sL%d@%s: [%s] took too long, %"PRIu64" > %d", __FILE__, __LINE__, __func__, #fn, c, MEASURE_MAX); \
     __x; \
 })
 
+#define STEERING_EVENT_QUEUE_CAPACITY 256
+#define MAX_IES_LEN 4096
 
 INT wifihal_stub() /* () means any argument list is valid */
 {
@@ -54,6 +57,17 @@ struct wifihal_3_0_sta_id {
 struct wifihal_3_0_sta {
     struct ds_tree_node node;
     struct wifihal_3_0_sta_id id;
+    uint8_t ies[MAX_IES_LEN];
+    size_t ies_len;
+    struct {
+        bool state;
+        bool ies;
+    } changed;
+};
+
+struct wifihal_3_0_steering_event {
+    struct ds_dlist_node node;
+    wifi_steering_event_t hal_event;
 };
 
 struct wifihal_3_0_priv {
@@ -61,21 +75,25 @@ struct wifihal_3_0_priv {
     struct osw_drv *drv;
     struct osw_conf_mutator conf_mut;
     pthread_mutex_t lock;
+    pthread_mutex_t lock_steering;
+    pthread_cond_t cond_steering;
     ev_async async;
+    ev_async async_steering;
     struct ds_tree sta_tree;
+    struct ds_dlist steering_events_queue;
+    size_t steering_events_queue_len;
     int n_events;
 
     INT (*wifi_getRadioIfName)(INT radioIndex, CHAR *output_string);
-    INT (*wifi_getApName)(INT apIndex, CHAR *output_string);
-    INT (*wifi_getApAssociatedDeviceDiagnosticResult)(INT apIndex, wifi_associated_dev_t **associated_dev_array, UINT *output_array_size);
+    INT (*wifi_getApAssociatedDeviceDiagnosticResult3)(INT apIndex, wifi_associated_dev3_t **associated_dev_array, UINT *output_array_size);
     INT (*wifi_getRadioDfsSupport)(INT radioIndex, BOOL *output_bool);
     INT (*wifi_getRadioDfsEnable)(INT radioIndex, BOOL *output_bool);
     INT (*wifi_getRadioChannels)(INT radioIndex, wifi_channelMap_t *output_map, INT output_map_size);
     INT (*wifi_getApAclDeviceNum)(INT apIndex, UINT *output_uint);
-    //INT (*wifi_getApAclDevices)(INT apIndex, mac_address_t *macArray, UINT maxArraySize, UINT* output_numEntries);
     INT (*wifi_getApAclDevices)(INT apIndex, CHAR *macArray, UINT buf_size);
-    // INT (*wifi_addApAclDevice)(INT apIndex, mac_address_t DeviceMacAddress);         // adds the mac address to the filter list
-    INT (*wifi_addApAclDevice)(INT apIndex, CHAR *DeviceMacAddress);         // adds the mac address to the filter list
+    INT (*wifi_getApAclDevices2)(INT apIndex, mac_address_t *macArray, UINT maxArraySize, UINT* output_numEntries);
+    INT (*wifi_addApAclDevice)(INT apIndex, CHAR *DeviceMacAddress);
+    INT (*wifi_addApAclDevice2)(INT apIndex, mac_address_t DeviceMacAddress);
     INT (*wifi_delApAclDevices)(INT apINdex);
     INT (*wifi_steering_clientDisconnect)(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac, wifi_disconnectType_t type, UINT reason);
     INT (*wifi_pushRadioChannel2)(INT radioIndex, UINT channel, UINT channel_width_MHz, UINT csa_beacon_count);
@@ -88,6 +106,12 @@ struct wifihal_3_0_priv {
     INT (*wifi_getMultiPskKeys)(INT apIndex, wifi_key_multi_psk_t *keys, INT keysNumber);
     INT (*wifi_getMultiPskClientKey)(INT apIndex, mac_address_t mac, wifi_key_multi_psk_t *key);
     INT (*wifi_getHalVersion)(CHAR *output_string);
+    INT (*wifi_getRadioChannelStats)(INT radioIndex, wifi_channelStats_t *input_output_channelStats_array, INT array_size);
+    INT (*wifi_getNeighboringWiFiStatus)(INT radioIndex, wifi_neighbor_ap2_t **neighbor_ap_array, UINT *output_array_size);
+    // INT wifi_getNeighboringWiFiStatus(INT radioIndex, BOOL scan, wifi_neighbor_ap2_t **neighbor_ap_array, UINT *output_array_size);
+    INT (*wifi_steering_eventRegister)(wifi_steering_eventCB_t event_cb);
+    INT (*wifi_sendActionFrame)(INT apIndex, mac_address_t sta, UINT frequency, UCHAR *frame, UINT len);
+    INT (*wifi_mgmt_frame_callbacks_register)(wifi_receivedMgmtFrame_callback mgmtRxCallback);
     void (*wifi_newApAssociatedDevice_callback_register)(wifi_newApAssociatedDevice_callback callback_proc);
     void (*wifi_apDisassociatedDevice_callback_register)(wifi_apDisassociatedDevice_callback callback_proc);
     void (*wifi_apDeAuthEvent_callback_register)(wifi_apDeAuthEvent_callback callback_proc);
@@ -109,6 +133,17 @@ struct wifihal_3_0_priv {
               : ((void *)priv->wifi_##fn == (void *)stub ? "stub" : "real"))); \
     } while (0)
 
+#define DLSYM2(fn, stub) \
+    do { \
+        priv->wifi_##fn##2 = dlsym(NULL, "wifi_hal_"#fn) ?: (dlsym(NULL, "wifi_"#fn) ?: stub); \
+        LOGI("%s: %s2 = %p (%s)", __func__, \
+             #fn, \
+             priv->wifi_##fn, \
+             (priv->wifi_##fn == NULL \
+              ? "null" \
+              : ((void *)priv->wifi_##fn == (void *)stub ? "stub" : "real"))); \
+    } while (0)
+
 typedef void sta_walk_fn_t(struct wifihal_3_0_sta *sta, void *fn_priv);
 typedef bool vap_walk_fn_t(wifi_vap_info_t *vap, void *fn_priv);
 
@@ -130,12 +165,26 @@ drv_is_enabled(void)
 }
 
 static bool
+is_phase2(void)
+{
+    /* FIXME: This should be runtime detected. There doesn't
+     * seem to be a way to do that now though, so fingers
+     * crossed this is enough for now.
+     */
+#ifdef WIFI_HAL_VERSION_3_PHASE2
+    return true;
+#else
+    return false;
+#endif
+}
+
+static bool
 phy_name_to_radio_index(const char *phy_name,
                         wifi_radio_index_t *radio_index);
 
 static void
 osw_conf_mutate_errata_beacon_interval(struct wifihal_3_0_priv *priv,
-                                       struct osw_conf *conf)
+                                       struct ds_tree *phy_tree)
 {
     /* FIXME: This should only be applied conditionally on
      * platforms where Wifi HAL implementation isn't
@@ -143,7 +192,7 @@ osw_conf_mutate_errata_beacon_interval(s
      */
 
     struct osw_conf_phy *phy;
-    ds_tree_foreach(&conf->phy_tree, phy) {
+    ds_tree_foreach(phy_tree, phy) {
         wifi_radio_index_t rix;
 
         if (phy_name_to_radio_index(phy->phy_name, &rix) == false)
@@ -172,10 +221,10 @@ osw_conf_mutate_errata_beacon_interval(s
 
 static void
 osw_conf_mutate_errata_2ghz_vht(struct wifihal_3_0_priv *priv,
-                                struct osw_conf *conf)
+                                struct ds_tree *phy_tree)
 {
     struct osw_conf_phy *phy;
-    ds_tree_foreach(&conf->phy_tree, phy) {
+    ds_tree_foreach(phy_tree, phy) {
         wifi_radio_index_t rix;
 
         if (phy_name_to_radio_index(phy->phy_name, &rix) == false)
@@ -226,17 +275,18 @@ osw_conf_mutate_errata_2ghz_vht(struct w
 
 static void
 osw_conf_mutate_cb(struct osw_conf_mutator *mut,
-                   struct osw_conf *conf)
+                   struct ds_tree *phy_tree)
 {
     struct wifihal_3_0_priv *priv;
     priv = container_of(mut, struct wifihal_3_0_priv, conf_mut);
 
-    osw_conf_mutate_errata_beacon_interval(priv, conf);
-    osw_conf_mutate_errata_2ghz_vht(priv, conf);
+    osw_conf_mutate_errata_beacon_interval(priv, phy_tree);
+    osw_conf_mutate_errata_2ghz_vht(priv, phy_tree);
 }
 
 static struct wifihal_3_0_priv g_priv = {
     .sta_tree = DS_TREE_INIT(sta_id_cmp, struct wifihal_3_0_sta, node),
+    .steering_events_queue = DS_DLIST_INIT(struct wifihal_3_0_steering_event, node),
     .conf_mut = {
         .name = DRV_NAME,
         .mutate_fn = osw_conf_mutate_cb,
@@ -272,6 +322,7 @@ sta_touch(struct wifihal_3_0_priv *priv,
 
     pthread_mutex_lock(lock);
     struct wifihal_3_0_sta *sta = sta_get(tree, ap_index, addr);
+    if (sta != NULL) sta->changed.state = true;
     pthread_mutex_unlock(lock);
 
     if (sta == NULL)
@@ -351,7 +402,8 @@ vap_walk_index_to_info_cb(wifi_vap_info_
     void **p = fn_priv;
     const wifi_vap_index_t *ap_index = p[0];
     if (vap->vap_index != *ap_index) return false;
-    p[1] = vap;
+
+    memcpy(p[1], vap, sizeof(wifi_vap_info_t));
     return true;
 }
 
@@ -361,7 +413,8 @@ vap_walk_name_to_info_cb(wifi_vap_info_t
     void **p = fn_priv;
     const char *vif_name = p[0];
     if (strcmp(vap->vap_name, vif_name) != 0) return false;
-    p[1] = vap;
+
+    memcpy(p[1], vap, sizeof(wifi_vap_info_t));
     return true;
 }
 
@@ -369,11 +422,14 @@ static char *
 ap_index_to_phy_name(const struct wifihal_3_0_priv *priv,
                      UINT ap_index)
 {
-    void *p[2] = { &ap_index, NULL };
+    wifi_vap_info_t vap_arg;
+    vap_arg.radio_index = MAX_NUM_RADIOS;
+
+    void *p[2] = { &ap_index, &vap_arg };
     vap_walk(priv, vap_walk_index_to_info_cb, p);
 
     const wifi_vap_info_t *vap = p[1];
-    if (vap == NULL) return NULL;
+    if (vap->radio_index == MAX_NUM_RADIOS) return NULL;
 
     char buf[MAXIFACENAMESIZE];
     if (MEASURE(priv->wifi_getRadioIfName, (vap->radio_index, buf)) != RETURN_OK)
@@ -390,20 +446,31 @@ static char *
 ap_index_to_vif_name(const struct wifihal_3_0_priv *priv,
                      UINT ap_index)
 {
-    char vif_name[16 + 1] = {0};
-    if (MEASURE(priv->wifi_getApName, (ap_index, vif_name)) != RETURN_OK) return NULL;
-    vif_name[16] = 0;
-    return STRDUP(vif_name);
+    unsigned int i;
+    for (i = 0; i < MAX_NUM_RADIOS; i++) {
+        wifi_vap_info_map_t map = {0};
+        if (MEASURE(priv->wifi_getRadioVapInfoMap, (i, &map)) != RETURN_OK) continue;
+        unsigned int j;
+        for (j = 0; j < map.num_vaps; j++) {
+            const wifi_vap_info_t *vap = &map.vap_array[j];
+            if (vap->vap_index == ap_index) return STRDUP(vap->vap_name);
+        }
+    }
+    return NULL;
 }
 
 int
 vif_name_to_ap_index(const struct wifihal_3_0_priv *priv,
                      const char *vif_name)
 {
-    const void *p[2] = { vif_name, NULL };
+    wifi_vap_info_t vap_arg;
+    vap_arg.radio_index = MAX_NUM_RADIOS;
+
+    const void *p[2] = { vif_name, &vap_arg };
     vap_walk(priv, vap_walk_name_to_info_cb, p);
+
     const wifi_vap_info_t *vap = p[1];
-    if (vap == NULL) return -1;
+    if (vap->radio_index == MAX_NUM_RADIOS) return -1;
     return vap->vap_index;
 }
 
@@ -413,10 +480,13 @@ vap_walk_rix_name_to_info(const struct w
                           const char *vif_name,
                           wifi_vap_info_t *vap)
 {
-    const void *p[2] = { vif_name, NULL };
+    vap->radio_index = MAX_NUM_RADIOS;
+
+    const void *p[2] = { vif_name, vap };
     vap_walk_radio(priv, rix, vap_walk_name_to_info_cb, p);
-    if (p[1] == NULL) return false;
-    memcpy(vap, p[1], sizeof(*vap));
+
+    if ( vap->radio_index == MAX_NUM_RADIOS) return false;
+
     return true;
 }
 
@@ -440,7 +510,20 @@ sta_report_cb(struct wifihal_3_0_sta *st
     }
 
     if (phy_name != NULL && vif_name != NULL) {
-        osw_drv_report_sta_changed(drv, phy_name, vif_name, &sta->id.addr);
+        if (sta->changed.state == true) {
+            sta->changed.state = false;
+            osw_drv_report_sta_changed(drv, phy_name, vif_name, &sta->id.addr);
+        }
+
+        if (sta->changed.ies == true) {
+            sta->changed.ies = false;
+            osw_drv_report_sta_assoc_ies(drv,
+                                         phy_name,
+                                         vif_name,
+                                         &sta->id.addr,
+                                         sta->ies,
+                                         sta->ies_len);
+        }
     }
 
     FREE(phy_name);
@@ -487,8 +570,10 @@ static INT
 sta_connect_cb(INT ap_index, wifi_associated_dev_t *dev)
 {
     const struct osw_hwaddr *addr = (const void *)dev->cli_MACAddress;
-    LOGI("osw: drv: wifihal: " OSW_HWADDR_FMT ": connected: rssi=%d snr=%d",
-         OSW_HWADDR_ARG(addr), dev->cli_RSSI, dev->cli_SNR);
+    char *vif_name = ap_index_to_vif_name(&g_priv, ap_index);
+    LOGI("osw: drv: wifihal: %s: " OSW_HWADDR_FMT ": connected: rssi=%d snr=%d",
+         vif_name, OSW_HWADDR_ARG(addr), dev->cli_RSSI, dev->cli_SNR);
+    FREE(vif_name);
     return sta_touch(&g_priv, ap_index, addr);
 }
 
@@ -496,10 +581,12 @@ static INT
 sta_disconnect_cb(INT ap_index, char *mac, INT event_type)
 {
     struct osw_hwaddr addr = {0};
+    char *vif_name = ap_index_to_vif_name(&g_priv, ap_index);
     sscanf(mac, OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
     /* FIXME: Store event_type */
-    LOGI("osw: drv: wifihal: " OSW_HWADDR_FMT ": disconnected: type=%d",
-         OSW_HWADDR_ARG(&addr), event_type);
+    LOGI("osw: drv: wifihal: %s: " OSW_HWADDR_FMT ": disconnected: type=%d",
+         vif_name, OSW_HWADDR_ARG(&addr), event_type);
+    FREE(vif_name);
     return sta_touch(&g_priv, ap_index, &addr);
 }
 
@@ -507,13 +594,88 @@ static INT
 sta_deauth_cb(int ap_index, char *mac, int reason)
 {
     struct osw_hwaddr addr = {0};
+    char *vif_name = ap_index_to_vif_name(&g_priv, ap_index);
     sscanf(mac, OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
-    LOGI("osw: drv: wifihal: " OSW_HWADDR_FMT ": deauthenticated: reason=%d",
-         OSW_HWADDR_ARG(&addr), reason);
+    LOGI("osw: drv: wifihal: %s: " OSW_HWADDR_FMT ": deauthenticated: reason=%d",
+         vif_name, OSW_HWADDR_ARG(&addr), reason);
+    FREE(vif_name);
     /* FIXME: Store reason */
     return sta_touch(&g_priv, ap_index, &addr);
 }
 
+static void steering_event_cb(UINT steeringgroupIndex, wifi_steering_event_t *wifi_hal_event)
+{
+    struct wifihal_3_0_steering_event *event = NULL;
+    struct wifihal_3_0_priv *priv = &g_priv;
+    struct ds_dlist *queue = &priv->steering_events_queue;
+    pthread_mutex_t *lock = &priv->lock_steering;
+    pthread_cond_t *cond = &priv->cond_steering;
+
+    LOGN("%s RECEIVED HAL EVENT %d ", __func__, wifi_hal_event->type);
+    pthread_mutex_lock(lock);
+    while (priv->steering_events_queue_len >= STEERING_EVENT_QUEUE_CAPACITY)
+    {
+        LOGN("%s: queue is full. Waiting (event: %d)", __func__, wifi_hal_event->type);
+        pthread_cond_wait(cond, lock);
+    }
+
+    event = CALLOC(1, sizeof(*event));
+    memcpy(&event->hal_event, wifi_hal_event, sizeof(event->hal_event));
+
+    ds_dlist_insert_tail(queue, event);
+    priv->steering_events_queue_len++;
+    pthread_mutex_unlock(lock);
+
+    ev_async_send(priv->loop, &priv->async_steering);
+}
+
+static void
+steering_report_event(struct wifihal_3_0_priv *priv)
+{
+    struct wifihal_3_0_steering_event *event = NULL;
+    struct osw_drv_report_vif_probe_req probe_req = {0};
+    struct ds_dlist *queue = &priv->steering_events_queue;
+    pthread_mutex_t *lock = &priv->lock_steering;
+    pthread_cond_t *cond = &priv->cond_steering;
+    char *phy_name;
+    char *vif_name;
+    unsigned int events_counter = 0;
+
+    pthread_mutex_lock(lock);
+    while (ds_dlist_is_empty(queue) == false)
+    {
+        event = ds_dlist_remove_head(queue);
+        priv->steering_events_queue_len--;
+        events_counter++;
+
+        phy_name = ap_index_to_phy_name(priv, event->hal_event.apIndex);
+        vif_name = ap_index_to_vif_name(priv, event->hal_event.apIndex);
+
+        if (WARN_ON(phy_name == NULL)) goto free;
+        if (WARN_ON(vif_name == NULL)) goto free;
+
+        switch (event->hal_event.type)
+        {
+            case WIFI_STEERING_EVENT_PROBE_REQ:
+                memcpy(&probe_req.sta_addr.octet, event->hal_event.data.probeReq.client_mac,
+                        sizeof(probe_req.sta_addr.octet));
+                probe_req.snr = event->hal_event.data.probeReq.rssi;
+                osw_drv_report_vif_probe_req(priv->drv, phy_name, vif_name, &probe_req);
+                break;
+            default:
+                LOGN("Unsupported steering event: %d", event->hal_event.type);
+                break;
+        }
+
+free:
+        FREE(event);
+    }
+    pthread_cond_signal(cond);
+    pthread_mutex_unlock(lock);
+
+    LOGT("%s: processed %u events", __func__, events_counter);
+}
+
 static void
 sta_async_cb(EV_P_ ev_async *arg, int events)
 {
@@ -523,6 +685,86 @@ sta_async_cb(EV_P_ ev_async *arg, int ev
 }
 
 static void
+steering_async_cb(EV_P_ ev_async *arg, int events)
+{
+    struct wifihal_3_0_priv *priv;
+    priv = container_of(arg, struct wifihal_3_0_priv, async_steering);
+    steering_report_event(priv);
+}
+
+#if defined(TARGET_TCHXB7) || defined(TARGET_CXB7) || defined(TARGET_TCHXB8)
+static INT
+received_mgmt_frame_cb(INT apIndex,
+                       mac_address_t sta_mac,
+                       UCHAR *frame,
+                       UINT len,
+                       wifi_mgmtFrameType_t type,
+                       wifi_direction_t dir,
+                       INT sig_dbm)
+#else
+static INT
+received_mgmt_frame_cb(INT apIndex,
+                       mac_address_t sta_mac,
+                       UCHAR *frame,
+                       UINT len,
+                       wifi_mgmtFrameType_t type,
+                       wifi_direction_t dir)
+#endif
+{
+    struct wifihal_3_0_priv *priv = &g_priv;
+    struct ds_tree *tree = &priv->sta_tree;
+    struct ev_loop *loop = priv->loop;
+    ev_async *async = &priv->async;
+    pthread_mutex_t *lock = &priv->lock;
+    INT ret = RETURN_OK;
+
+    pthread_mutex_lock(lock);
+    struct wifihal_3_0_sta *sta = sta_get(tree, apIndex, (const struct osw_hwaddr *)sta_mac);
+    if (sta == NULL)
+        goto unlock;
+
+    if (type == WIFI_MGMT_FRAME_TYPE_ASSOC_REQ ||
+        type == WIFI_MGMT_FRAME_TYPE_REASSOC_REQ) {
+        if (len > MAX_IES_LEN) {
+            LOGE("%s: received mgmt frame size too big (%u vs %u)", __func__,
+                 len, MAX_IES_LEN);
+            ret = RETURN_ERR;
+            goto unlock;
+        }
+
+        /* FIXME: It's unclear, from the Wifi HAL
+         * API documentation, whether the frame
+         * pointer points to 802.11 header, or the
+         * fixed payload, or the variable payload
+         * of the frame.
+         *
+         * This assumes it points to 802.11 frame
+         * for now. If that is proven to be
+         * incorrect, it can be fixed. This needs
+         * testing.
+         */
+        const size_t hdr_len = (2 + 2 + 6 + 6 + 6 + 2);
+        const size_t assoc_len = 2 + 2;
+        const size_t reassoc_len = 2 + 2 + 6;
+        const size_t fixed_len = (type == WIFI_MGMT_FRAME_TYPE_ASSOC_REQ)
+                               ? assoc_len
+                               : reassoc_len;
+        const size_t ies_off = hdr_len + fixed_len;
+        const size_t ies_len = len - ies_off;
+        const void *ies = (frame + ies_off);
+
+        memcpy(&sta->ies, ies, ies_len);
+        sta->ies_len = ies_len;
+        sta->changed.ies = true;
+        ev_async_send(loop, async);
+    }
+unlock:
+    pthread_mutex_unlock(lock);
+
+    return ret;
+}
+
+static void
 osw_drv_init_cb(struct osw_drv *drv)
 {
     struct wifihal_3_0_priv *priv = &g_priv;
@@ -536,17 +778,21 @@ osw_drv_init_cb(struct osw_drv *drv)
 
     ev_async_init(&priv->async, sta_async_cb);
     ev_async_start(priv->loop, &priv->async);
+    priv->steering_events_queue_len = 0;
+    ev_async_init(&priv->async_steering, steering_async_cb);
+    ev_async_start(priv->loop, &priv->async_steering);
     ev_unref(EV_DEFAULT);
 
     DLSYM(getRadioIfName, wifihal_stub);
-    DLSYM(getApName, wifihal_stub);
-    DLSYM(getApAssociatedDeviceDiagnosticResult, wifihal_stub);
+    DLSYM(getApAssociatedDeviceDiagnosticResult3, wifihal_stub);
     DLSYM(getRadioDfsSupport, wifihal_stub);
     DLSYM(getRadioDfsEnable, wifihal_stub);
     DLSYM(getRadioChannels, wifihal_stub);
     DLSYM(getApAclDeviceNum, wifihal_stub);
     DLSYM(getApAclDevices, wifihal_stub);
+    DLSYM2(getApAclDevices, wifihal_stub);
     DLSYM(addApAclDevice, wifihal_stub);
+    DLSYM2(addApAclDevice, wifihal_stub);
     DLSYM(delApAclDevices, wifihal_stub);
     DLSYM(steering_clientDisconnect, wifihal_stub);
     DLSYM(pushRadioChannel2, wifihal_stub);
@@ -561,15 +807,28 @@ osw_drv_init_cb(struct osw_drv *drv)
     DLSYM(newApAssociatedDevice_callback_register, wifihal_stub);
     DLSYM(apDisassociatedDevice_callback_register, wifihal_stub);
     DLSYM(apDeAuthEvent_callback_register, wifihal_stub);
+    DLSYM(getRadioChannelStats, wifihal_stub);
+    DLSYM(getNeighboringWiFiStatus, wifihal_stub);
     DLSYM(getHalVersion, wifihal_stub);
+    DLSYM(steering_eventRegister, wifihal_stub);
+    DLSYM(sendActionFrame, wifihal_stub);
+    DLSYM(mgmt_frame_callbacks_register, wifihal_stub);
 
     priv->wifi_newApAssociatedDevice_callback_register(sta_connect_cb);
     priv->wifi_apDisassociatedDevice_callback_register(sta_disconnect_cb);
     priv->wifi_apDeAuthEvent_callback_register(sta_deauth_cb);
+    if (priv->wifi_steering_eventRegister(steering_event_cb) != RETURN_OK)
+    {
+        LOGI("%s: failed to register steering callback", __func__);
+    }
+    if (priv->wifi_mgmt_frame_callbacks_register(received_mgmt_frame_cb) != RETURN_OK)
+    {
+        LOGI("%s: failed to register mgmt frame callback", __func__);
+    }
 
     char ver[64] = {0};
     priv->wifi_getHalVersion(ver);
-    LOGI("osw: drv: wifihal: version '%s' advertised", ver);
+    LOGI("osw: drv: wifihal: version '%s'%s advertised", ver, is_phase2() ? " phase2" : "");
     if (strstr(ver, "3.0") != ver)
         LOGI("osw: drv: wifihal: only API 3.0.x is supported");
 
@@ -638,13 +897,13 @@ osw_drv_get_sta_list_cb(struct osw_drv *
 
     const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
     int ap_index = vif_name_to_ap_index(priv, vif_name);
-    wifi_associated_dev_t *sta = NULL;
+    wifi_associated_dev3_t *sta = NULL;
     UINT n_sta = 0;
     UINT i;
 
     if (WARN_ON(ap_index < 0)) return;
 
-    if (MEASURE(priv->wifi_getApAssociatedDeviceDiagnosticResult, (ap_index, &sta, &n_sta)) != RETURN_OK) {
+    if (MEASURE(priv->wifi_getApAssociatedDeviceDiagnosticResult3, (ap_index, &sta, &n_sta)) != RETURN_OK) {
         LOGE("%s: cannot get associated device diagnostic result for vap_index: %d",
              __func__, ap_index);
         return;
@@ -1002,43 +1261,44 @@ bss_fill_acl(const wifi_vap_info_t *vap,
     if (WARN_ON(MEASURE(priv->wifi_getApAclDeviceNum, (ap_index, &size)) != RETURN_OK)) return;
     if (size == 0) return; /* nothing to do */
 
-#ifdef WIFI_HAL_VERSION_3_PHASE2
-    mac_address_t *macs = CALLOC(size, sizeof(*macs));
-    UINT len = 0;
-
-    if (WARN_ON(MEASURE(priv->wifi_getApAclDevices, (ap_index, macs, size, &len)) != RETURN_OK)) goto end;
-    if (WARN_ON(len > size)) goto end;
-
-    ap->acl.count = len;
-    ap->acl.list = CALLOC(len, sizeof(*ap->acl.list));
-
-    UINT i;
-    for (i = 0; i < len; i++)
-        memcpy(&ap->acl.list[i].octet, macs[i], MAC_LEN);
+    if (is_phase2() == true) {
+        mac_address_t *macs = CALLOC(size, sizeof(*macs));
+        UINT len = 0;
+
+        if (WARN_ON(MEASURE(priv->wifi_getApAclDevices2, (ap_index, macs, size, &len)) != RETURN_OK)) goto end;
+        if (WARN_ON(len > size)) goto end;
+
+        ap->acl.count = len;
+        ap->acl.list = CALLOC(len, sizeof(*ap->acl.list));
+
+        UINT i;
+        for (i = 0; i < len; i++)
+            memcpy(&ap->acl.list[i].octet, macs[i], MAC_LEN);
 
 end:
-    FREE(macs);
-#else
-    char buf[64*1024]; /* should be big enough */
-    char *bufp = buf;
-    char *p;
-
-    size = sizeof(buf);
-    if (WARN_ON(MEASURE(priv->wifi_getApAclDevices, (ap_index, buf, size)) != RETURN_OK)) return;
-    while ((p = strsep(&bufp, "\n")) != NULL) {
-        static struct osw_hwaddr zero;
-        struct osw_hwaddr addr;
-
-        /* FIXME: This could be done better */
-        sscanf(p, OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
-        if (memcmp(&addr, &zero, sizeof(addr)) == 0)
-            continue;
+        FREE(macs);
+    }
+    else {
+        char buf[64*1024]; /* should be big enough */
+        char *bufp = buf;
+        char *p;
+
+        size = sizeof(buf);
+        if (WARN_ON(MEASURE(priv->wifi_getApAclDevices, (ap_index, buf, size)) != RETURN_OK)) return;
+        while ((p = strsep(&bufp, "\n")) != NULL) {
+            static struct osw_hwaddr zero;
+            struct osw_hwaddr addr;
+
+            /* FIXME: This could be done better */
+            sscanf(p, OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
+            if (memcmp(&addr, &zero, sizeof(addr)) == 0)
+                continue;
 
-        int n = ++ap->acl.count;
-        ap->acl.list = REALLOC(ap->acl.list, n * sizeof(*ap->acl.list));
-        memcpy(&ap->acl.list[n - 1], &addr, sizeof(addr));
+            int n = ++ap->acl.count;
+            ap->acl.list = REALLOC(ap->acl.list, n * sizeof(*ap->acl.list));
+            memcpy(&ap->acl.list[n - 1], &addr, sizeof(addr));
+        }
     }
-#endif
 }
 
 #define MAX_PSK 64
@@ -1150,6 +1410,10 @@ bss_fill_wpa(const wifi_vap_info_t *vap,
         case wifi_security_mode_wpa3_enterprise:
             LOGI("%s: wpa3 enterprise not supported", vap->vap_name);
             break;
+        default:
+            LOGI("%s: Unsupported security mode %d", vap->vap_name, sec->mode);
+            break;
+        
     }
 
     switch (sec->encr) {
@@ -1282,7 +1546,7 @@ osw_drv_request_sta_state_cb(struct osw_
 {
     const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
     struct osw_drv_sta_state sta = {0};
-    wifi_associated_dev_t *arr = NULL;
+    wifi_associated_dev3_t *arr = NULL;
     wifi_vap_info_t vap = {0};
     wifi_radio_index_t rix;
     UINT n = 0;
@@ -1295,7 +1559,7 @@ osw_drv_request_sta_state_cb(struct osw_
         goto report;
 
     INT vix = vap.vap_index;
-    if (MEASURE(priv->wifi_getApAssociatedDeviceDiagnosticResult, (vix, &arr, &n)) != RETURN_OK)
+    if (MEASURE(priv->wifi_getApAssociatedDeviceDiagnosticResult3, (vix, &arr, &n)) != RETURN_OK)
         goto report;
 
     for (i = 0; i < n; i++) {
@@ -1557,10 +1821,20 @@ vap_configure_ap(const struct wifihal_3_
 
         size_t i;
         for (i = 0; i < ap->acl.count; i++) {
-            const struct osw_hwaddr *addr = &ap->acl.list[i];
-            struct osw_hwaddr_str str;
-            osw_hwaddr2str(addr, &str);
-            WARN_ON(priv->wifi_addApAclDevice(vix, str.buf) != RETURN_OK);
+            if (is_phase2() == true) {
+                const struct osw_hwaddr *addr = &ap->acl.list[i];
+                mac_address_t mac_addr;
+                memcpy(mac_addr, addr->octet, sizeof(addr->octet));
+                if (WARN_ON(priv->wifi_addApAclDevice2 == NULL)) continue;
+                WARN_ON(priv->wifi_addApAclDevice2(vix, mac_addr) != RETURN_OK);
+            }
+            else {
+                const struct osw_hwaddr *addr = &ap->acl.list[i];
+                struct osw_hwaddr_str str;
+                osw_hwaddr2str(addr, &str);
+                if (WARN_ON(priv->wifi_addApAclDevice == NULL)) continue;
+                WARN_ON(priv->wifi_addApAclDevice(vix, str.buf) != RETURN_OK);
+            }
         }
 
         *changed = true;
@@ -1909,6 +2183,311 @@ osw_drv_request_sta_deauth_cb(struct osw
     WARN_ON(ret != RETURN_OK);
 }
 
+static void
+osw_drv_fill_tlv_chan_stats(const struct wifihal_3_0_priv *priv,
+                            struct osw_tlv *t,
+                            int rix)
+{
+    wifi_radio_operationParam_t params = {0};
+    wifi_channelMap_t chans[128] = {0};
+    wifi_channelStats_t stats[128] = {0};
+    char phy_name[MAXIFACENAMESIZE] = {0};
+    const size_t n_chans = ARRAY_SIZE(chans);
+    const size_t n_stats = ARRAY_SIZE(stats);
+    size_t i;
+    size_t j;
+
+    if (MEASURE(priv->wifi_getRadioOperatingParameters, (rix, &params)) != RETURN_OK)
+        return;
+
+    if (WARN_ON(MEASURE(priv->wifi_getRadioIfName, (rix, phy_name)) != RETURN_OK))
+        return;
+
+    /* FIXME: This fails when radio is down. This should
+     * generate WARN_ON() only if the radio is expected to
+     * be up?
+     */
+    if (MEASURE(priv->wifi_getRadioChannels, (rix, chans, n_chans)) != RETURN_OK)
+        return;
+
+    for (i = 0, j = 0; i < n_chans; i++) {
+        if (chans[i].ch_number == 0) continue;
+
+        stats[j].ch_number = chans[i].ch_number;
+        j++;
+
+        if (WARN_ON(j == n_stats)) /* shouldn't happen */
+            break;
+    }
+
+    if (WARN_ON(MEASURE(priv->wifi_getRadioChannelStats, (rix, stats, n_stats)) != RETURN_OK))
+        return;
+
+    for (i = 0; i < n_stats; i++) {
+        if (stats[i].ch_number == 0) continue;
+
+        const int chan = stats[i].ch_number;
+        const int freq_mhz = chan_to_mhz(params.band, chan);
+
+        void *start_chan = osw_tlv_put_nested(t, OSW_STATS_CHAN);
+        {
+            const unsigned long active = stats[i].ch_utilization_total / 1000;
+            const float noise = stats[i].ch_noise;
+
+            osw_tlv_put_string(t, OSW_STATS_CHAN_PHY_NAME, phy_name);
+            osw_tlv_put_u32(t, OSW_STATS_CHAN_FREQ_MHZ, freq_mhz);
+            osw_tlv_put_u32(t, OSW_STATS_CHAN_ACTIVE_MSEC, active);
+            osw_tlv_put_float(t, OSW_STATS_CHAN_NOISE_FLOOR_DBM, noise);
+
+            void *start_cnt = osw_tlv_put_nested(t, OSW_STATS_CHAN_CNT_MSEC);
+            {
+                const unsigned long busy = stats[i].ch_utilization_busy / 1000;
+                const unsigned long tx = stats[i].ch_utilization_busy_tx / 1000;
+                const unsigned long rx = stats[i].ch_utilization_busy_rx / 1000;
+                const unsigned long inbss = stats[i].ch_utilization_busy_self / 1000;
+
+                osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_TX, tx);
+                osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_RX, rx);
+                osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_RX_INBSS, inbss);
+                osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_BUSY, busy);
+            }
+            osw_tlv_end_nested(t, start_cnt);
+        }
+        osw_tlv_end_nested(t, start_chan);
+    }
+}
+
+static wifi_freq_bands_t
+band_str_to_enum(const char *str)
+{
+    /* This is crude, but the string is farily free-form as
+     * far as documentation goes. This should be good
+     * enough.
+     */
+    const int b = atoi(str);
+    if (b == 2) return WIFI_FREQUENCY_2_4_BAND;
+    if (b == 5) return WIFI_FREQUENCY_5_BAND;
+    if (b == 6) return WIFI_FREQUENCY_6_BAND;
+    WARN_ON(1);
+    return WIFI_FREQUENCY_2_4_BAND;
+}
+
+static uint32_t
+rssi_to_snr_20mhz(const INT rssi, const INT nf)
+{
+    /* This shouldn't happen, but in case SNR is handed over
+     * on accident, try to guess it and return a sane value.
+     * Chances of RSSI being > 10dBm are really slim and
+     * would require devices to sit next to each other,
+     * antennas touching, on 2.4GHz. Not a real world case
+     * to worry about. */
+    if (rssi > 10) return rssi;
+
+    return rssi - osw_channel_nf_20mhz_fixup(nf);
+}
+
+static void
+osw_drv_fill_tlv_bss_scan_entry(struct osw_tlv *t,
+                                const char *phy_name,
+                                const wifi_neighbor_ap2_t *bss)
+{
+    struct osw_hwaddr bssid = {0};
+    const int n = sscanf(bss->ap_BSSID,
+                         "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+                         &bssid.octet[0], &bssid.octet[1], &bssid.octet[2],
+                         &bssid.octet[3], &bssid.octet[4], &bssid.octet[5]);
+    if (n != 6) return;
+
+    const wifi_freq_bands_t band = band_str_to_enum(bss->ap_OperatingFrequencyBand);
+    const int freq_mhz = chan_to_mhz(band, bss->ap_Channel);
+    const int width_mhz = atoi(bss->ap_OperatingChannelBandwidth); /* FIXME: 80+80? */
+    const char *ssid = bss->ap_SSID;
+    const size_t ssid_len = strnlen(bss->ap_SSID, sizeof(bss->ap_SSID));
+    const uint32_t snr_db = rssi_to_snr_20mhz(bss->ap_SignalStrength,
+                                              bss->ap_Noise);
+
+    LOGT("%s: %s: bssid=%s ssid=%.*s(%zu) freq=%d width=%d "
+         "signal=%d noise=%d snr=%u",
+         __func__,
+         phy_name,
+         bss->ap_BSSID,
+         (int)ssid_len, ssid, ssid_len,
+         freq_mhz,
+         width_mhz,
+         bss->ap_SignalStrength,
+         bss->ap_Noise,
+         snr_db);
+
+    void *s = osw_tlv_put_nested(t, OSW_STATS_BSS_SCAN);
+    osw_tlv_put_string(t, OSW_STATS_BSS_SCAN_PHY_NAME, phy_name);
+    osw_tlv_put_hwaddr(t, OSW_STATS_BSS_SCAN_MAC_ADDRESS, &bssid);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_FREQ_MHZ, freq_mhz);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_WIDTH_MHZ, width_mhz);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_SNR_DB, snr_db);
+    osw_tlv_put_buf(t, OSW_STATS_BSS_SCAN_SSID, ssid, ssid_len);
+    // TODO: OSW_STATS_BSS_SCAN_IES
+    osw_tlv_end_nested(t, s);
+}
+
+static void
+osw_drv_fill_tlv_bss_scan_stats(const struct wifihal_3_0_priv *priv,
+                                struct osw_tlv *t,
+                                int rix)
+{
+    char phy_name[MAXIFACENAMESIZE] = {0};
+
+    if (MEASURE(priv->wifi_getRadioIfName, (rix, phy_name)) != RETURN_OK)
+        return;
+
+    LOGD("%s: rix=%d phy_name=%s", __func__, rix, phy_name);
+
+    wifi_neighbor_ap2_t *bss = NULL;
+    UINT n_bss = 0;
+    if (MEASURE(priv->wifi_getNeighboringWiFiStatus, (rix, &bss, &n_bss)) != RETURN_OK)
+        return;
+
+    UINT i;
+    for (i = 0; i < n_bss; i++) {
+        osw_drv_fill_tlv_bss_scan_entry(t, phy_name, &bss[i]);
+    }
+
+    free(bss);
+}
+
+static void
+osw_drv_fill_tlv_sta_stats(const struct wifihal_3_0_priv *priv,
+                           struct osw_tlv *t,
+                           int rix)
+{
+    wifi_vap_info_map_t map = {0};
+    char phy_name[MAXIFACENAMESIZE] = {0};
+
+    if (MEASURE(priv->wifi_getRadioIfName, (rix, phy_name)) != RETURN_OK) return;
+    if (MEASURE(priv->wifi_getRadioVapInfoMap, (rix, &map)) != RETURN_OK) return;
+    if (WARN_ON(map.num_vaps > ARRAY_SIZE(map.vap_array))) return;
+
+    unsigned int i;
+    for (i = 0; i < map.num_vaps; i++) {
+        const wifi_vap_info_t *vap = &map.vap_array[i];
+        const char *vif_name = vap->vap_name;
+        const wifi_vap_index_t vix = vap->vap_index;
+        wifi_associated_dev3_t *stas = NULL;
+        UINT n_sta = 0;
+
+        if (MEASURE(priv->wifi_getApAssociatedDeviceDiagnosticResult3, (vix, &stas, &n_sta)) != RETURN_OK) {
+            LOGE("%s: cannot get associated device diagnostic result for vap_index: %d",
+                    __func__, vix);
+            continue;
+        }
+
+        UINT j;
+        for (j = 0; j < n_sta; j++) {
+            const wifi_associated_dev3_t *sta = &stas[j];
+
+            if (sta->cli_Active == false) continue;
+
+            struct osw_hwaddr addr;
+            memcpy(addr.octet, sta->cli_MACAddress, MAC_LEN);
+            const INT snr = sta->cli_SNR;
+            const UINT tx_rate = sta->cli_LastDataDownlinkRate;
+            const UINT rx_rate = sta->cli_LastDataUplinkRate;
+            const ULONG tx_bytes = sta->cli_BytesSent;
+            const ULONG rx_bytes = sta->cli_BytesReceived;
+            const ULONG tx_frames = sta->cli_PacketsSent;
+            const ULONG rx_frames = sta->cli_PacketsReceived;
+            const ULONG tx_retries = sta->cli_RetransCount;
+
+            void *s = osw_tlv_put_nested(t, OSW_STATS_STA);
+            osw_tlv_put_string(t, OSW_STATS_STA_PHY_NAME, phy_name);
+            osw_tlv_put_string(t, OSW_STATS_STA_VIF_NAME, vif_name);
+            osw_tlv_put_hwaddr(t, OSW_STATS_STA_MAC_ADDRESS, &addr);
+
+            osw_tlv_put_u32(t, OSW_STATS_STA_SNR_DB, snr);
+            osw_tlv_put_u32(t, OSW_STATS_STA_TX_BYTES, tx_bytes);
+            osw_tlv_put_u32(t, OSW_STATS_STA_RX_BYTES, rx_bytes);
+            osw_tlv_put_u32(t, OSW_STATS_STA_TX_FRAMES, tx_frames);
+            osw_tlv_put_u32(t, OSW_STATS_STA_RX_FRAMES, rx_frames);
+            osw_tlv_put_u32(t, OSW_STATS_STA_TX_RATE_MBPS, tx_rate);
+            osw_tlv_put_u32(t, OSW_STATS_STA_RX_RATE_MBPS, rx_rate);
+            osw_tlv_put_u32(t, OSW_STATS_STA_TX_RETRIES, tx_retries);
+
+            osw_tlv_end_nested(t, s);
+        }
+
+        free(stas);
+    }
+}
+
+static void
+osw_drv_request_stats_cb(struct osw_drv *drv)
+{
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    struct osw_tlv t = {0};
+    int rix;
+
+    for (rix = 0; rix < MAX_NUM_RADIOS; rix++) {
+        osw_drv_fill_tlv_chan_stats(priv, &t, rix);
+        osw_drv_fill_tlv_bss_scan_stats(priv, &t, rix);
+        osw_drv_fill_tlv_sta_stats(priv, &t, rix);
+    }
+
+    osw_drv_report_stats(drv, &t);
+    osw_tlv_fini(&t);
+}
+
+static void
+osw_drv_push_frame_tx_cb(struct osw_drv *drv,
+                         const char *phy_name,
+                         const char *vif_name,
+                         struct osw_drv_frame_tx_desc *desc)
+{
+    const size_t dot11_header_size = sizeof(struct osw_drv_dot11_frame_header);
+    const uint8_t *payload = osw_drv_frame_tx_desc_get_frame(desc);
+    const struct osw_drv_dot11_frame *frame = (const struct osw_drv_dot11_frame*) payload;
+    const struct osw_channel *channel = osw_drv_frame_tx_desc_get_channel(desc);
+    const UINT freq_mhz = channel ? channel->control_freq_mhz : 0;
+    size_t payload_len = osw_drv_frame_tx_desc_get_frame_len(desc);
+    INT ret;
+    INT apIndex;
+    mac_address_t sta_addr = {0};
+    UCHAR *hal_payload;
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+
+    if (vif_name == NULL) {
+        LOGD("osw: drv: wifi_hal_3_0: vif_name is required, failing");
+        osw_drv_report_frame_tx_state_failed(drv);
+        return;
+    }
+
+    apIndex = vif_name_to_ap_index(priv, vif_name);
+
+    if (dot11_header_size >= payload_len) {
+        LOGD("osw: drv: wifi_hal_3_0: frame tx too small, failing");
+        osw_drv_report_frame_tx_state_failed(drv);
+        return;
+    }
+
+    /* FIXME: This assumes the payload is an action frame
+     * but it doesn't have to be.
+     */
+    payload += dot11_header_size;
+    payload_len -= dot11_header_size;
+
+    /* HAL API has non-const arguments. Instead of casting
+     * make a copy for be type-clean.
+     */
+    hal_payload = MEMNDUP(payload, payload_len);
+    memcpy(&sta_addr, &frame->header.da, sizeof(sta_addr));
+
+    ret = MEASURE(priv->wifi_sendActionFrame, (apIndex, sta_addr, freq_mhz, hal_payload, payload_len));
+    if (ret == RETURN_OK)
+        osw_drv_report_frame_tx_state_submitted(drv);
+    else
+        osw_drv_report_frame_tx_state_failed(drv);
+
+    FREE(hal_payload);
+}
+
 const struct osw_drv_ops g_wifihal_3_0_ops = {
     .name = DRV_NAME,
     .init_fn = osw_drv_init_cb,
@@ -1920,6 +2499,8 @@ const struct osw_drv_ops g_wifihal_3_0_o
     .request_sta_state_fn = osw_drv_request_sta_state_cb,
     .request_config_fn = osw_drv_request_config_cb,
     .request_sta_deauth_fn = osw_drv_request_sta_deauth_cb,
+    .request_stats_fn = osw_drv_request_stats_cb,
+    .push_frame_tx_fn = osw_drv_push_frame_tx_cb,
 };
 
 OSW_DRV_DEFINE(g_wifihal_3_0_ops);
Index: core/src/lib/osw/src/osw_ev.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_ev.c
@@ -0,0 +1,7 @@
+#include <ev.h>
+#include <osw_module.h>
+
+OSW_MODULE(osw_ev)
+{
+    return EV_DEFAULT;
+}
Index: core/src/lib/osw/src/osw_module.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_module.c
@@ -0,0 +1,40 @@
+#include <osw_module.h>
+#include <log.h>
+
+static struct ds_tree g_osw_module_list = DS_TREE_INIT(ds_str_cmp, struct osw_module, node);
+
+void
+osw_module_register(struct osw_module *m)
+{
+    assert(ds_tree_find(&g_osw_module_list, m->name) == NULL);
+    LOGD("ow: module: registering: %s (%s)", m->name, m->file);
+    ds_tree_insert(&g_osw_module_list, m, m->name);
+}
+
+static void
+osw_module_load__(struct osw_module *m)
+{
+    assert(m != NULL);
+    if (m->loaded == true) return;
+    LOGI("ow: module: loading: %s (%s)", m->name, m->file);
+    m->data = m->fn();
+    m->loaded = true;
+}
+
+void *
+osw_module_load_name(const char *name)
+{
+    struct osw_module *m = ds_tree_find(&g_osw_module_list, name);
+    LOGD("ow: module: resolving: %s", name);
+    osw_module_load__(m);
+    return m->data;
+}
+
+void
+osw_module_load(void)
+{
+    struct osw_module *m;
+    ds_tree_foreach(&g_osw_module_list, m) {
+        osw_module_load__(m);
+    }
+}
Index: core/src/lib/osw/src/osw_mux.c
===================================================================
--- core.orig/src/lib/osw/src/osw_mux.c
+++ core/src/lib/osw/src/osw_mux.c
@@ -1,8 +1,20 @@
 #include <memutil.h>
+#include <log.h>
+#include <util.h>
+#include <const.h>
 #include <osw_conf.h>
+#include <osw_drv_common.h>
 #include <osw_drv.h>
+#include <osw_time.h>
+#include <osw_module.h>
 #include "osw_drv_i.h"
 
+static inline bool
+osw_mux_drv_is_ready(struct osw_drv *drv)
+{
+    return drv->initialized == true && drv->unregistered == false;
+}
+
 bool
 osw_mux_request_config(struct osw_drv_conf *conf)
 {
@@ -51,14 +63,16 @@ osw_mux_request_config(struct osw_drv_co
     return requested;
 }
 
-static struct osw_drv *
-osw_mux_phy_to_drv(const char *phy_name)
+static struct osw_drv_phy *
+osw_mux_lookup_phy_by_name(const char *phy_name)
 {
     struct osw_drv *drv;
 
-    ds_tree_foreach(&g_osw_drv_tree, drv)
-        if (ds_tree_find(&drv->phy_tree, phy_name) != NULL)
-            return drv;
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+        if (phy != NULL)
+            return phy;
+    }
 
     return NULL;
 }
@@ -69,9 +83,74 @@ osw_mux_request_sta_deauth(const char *p
                            const struct osw_hwaddr *mac_addr,
                            int dot11_reason_code)
 {
-    struct osw_drv *drv = osw_mux_phy_to_drv(phy_name);
-    if (drv == NULL) return false;
-    drv->ops->request_sta_deauth_fn(drv, phy_name, vif_name,
-                                    mac_addr, dot11_reason_code);
+    struct osw_drv_phy *phy = osw_mux_lookup_phy_by_name(phy_name);
+    if (phy == NULL) return false;
+    if (phy->drv->ops->request_sta_deauth_fn == NULL) return false;
+    phy->drv->ops->request_sta_deauth_fn(phy->drv, phy_name, vif_name,
+                                         mac_addr, dot11_reason_code);
     return true;
 }
+
+bool
+osw_mux_frame_tx_schedule(const char *phy_name,
+                          const char *vif_name,
+                          struct osw_drv_frame_tx_desc *desc)
+{
+    assert(phy_name != NULL);
+    assert(desc != NULL);
+
+    struct osw_drv_phy *phy = NULL;
+    struct osw_drv_vif *vif = NULL;
+
+    if (desc->state != OSW_DRV_FRAME_TX_STATE_UNUSED)
+        return false;
+
+    phy = osw_mux_lookup_phy_by_name(phy_name);
+    if (phy == NULL)
+        return false;
+
+    if (phy->drv->ops->push_frame_tx_fn == NULL)
+        return false;
+
+    if (vif_name != NULL)
+        vif = ds_tree_find(&phy->vif_tree, vif_name);
+
+    if (vif_name != NULL && vif == NULL)
+        return false;
+
+    STRSCPY(desc->phy_name.buf, phy_name);
+    if (vif_name != NULL) STRSCPY_WARN(desc->vif_name.buf, vif_name);
+    desc->state = OSW_DRV_FRAME_TX_STATE_PENDING;
+    desc->list = &phy->drv->frame_tx_list;
+    ds_dlist_insert_head(desc->list, desc);
+
+    osw_drv_work_all_schedule();
+
+    return true;
+}
+
+void
+osw_mux_request_stats(void)
+{
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        if (osw_mux_drv_is_ready(drv) == true)
+            if (drv->ops->request_stats_fn != NULL)
+                drv->ops->request_stats_fn(drv);
+}
+
+void
+osw_mux_poll(void)
+{
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        osw_drv_invalidate(drv);
+    }
+}
+
+OSW_MODULE(osw_mux)
+{
+    return NULL;
+}
Index: core/src/lib/osw/src/osw_rrm_meas.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_rrm_meas.c
@@ -0,0 +1,594 @@
+#include <endian.h>
+#include <ev.h>
+#include <log.h>
+#include <const.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_timer.h>
+#include <osw_time.h>
+#include <osw_drv_common.h>
+#include <osw_drv_mediator.h>
+#include <osw_drv.h>
+#include <osw_mux.h>
+#include <osw_throttle.h>
+#include <osw_state.h>
+#include <osw_rrm_meas.h>
+#include <osw_state.h>
+#include <osw_util.h>
+
+typedef bool
+osw_rrm_meas_mux_frame_tx_schedule_fn_t(const char *phy_name,
+                                        const char *vif_name,
+                                        struct osw_drv_frame_tx_desc *desc);
+
+enum osw_rrm_meas_desc_state {
+    OSW_RRM_MEAS_DESC_STATE_EMPTY = 0,
+    OSW_RRM_MEAS_DESC_STATE_PENDING,
+    OSW_RRM_MEAS_DESC_STATE_IN_TRANSIT,
+};
+
+struct osw_rrm_meas_desc {
+    struct osw_rrm_meas_sta *sta;
+    const struct osw_rrm_meas_sta_observer *observer;
+    enum osw_rrm_meas_desc_state state;
+    uint8_t frame_buf [OSW_DRV_FRAME_TX_DESC_BUF_SIZE];
+    ssize_t frame_len;
+    uint8_t dialog_token;
+    const char *vif_name;
+    const char *phy_name;
+    osw_rrm_meas_mux_frame_tx_schedule_fn_t *mux_frame_tx_schedule_fn;
+
+    struct ds_dlist_node node;
+};
+
+struct osw_rrm_meas_sta {
+    struct ds_tree *owner;
+    struct osw_hwaddr mac_addr;
+    struct osw_throttle *throttle;
+    struct osw_timer work_timer;
+    struct osw_drv_frame_tx_desc *frame_tx_desc;
+    struct ds_dlist desc_list;
+    struct ds_tree neigh_tree;
+    uint8_t dialog_token_generator;
+
+    struct ds_tree_node node;
+};
+
+/* FIXME: combine rrm and btm into common action frame module */
+
+/* FIXME: This should not be global */
+static struct ds_tree g_sta_tree = DS_TREE_INIT((ds_key_cmp_t *)osw_hwaddr_cmp, struct osw_rrm_meas_sta, node);
+
+/* FIXME: forward decl should be avoided */
+static struct osw_rrm_meas_sta *
+osw_rrm_meas_get_sta(const struct osw_hwaddr *sta_addr);
+
+static uint8_t
+osw_rrm_meas_desc_generate_dialog_token(struct osw_rrm_meas_sta *rrm_meas_sta)
+{
+    ASSERT(rrm_meas_sta != NULL, "");
+    return rrm_meas_sta->dialog_token_generator++;
+}
+
+static void
+osw_rrm_meas_desc_reset(struct osw_rrm_meas_desc *desc)
+{
+    ASSERT(desc != NULL, "");
+
+    desc->state = OSW_RRM_MEAS_DESC_STATE_EMPTY;
+    memset(&desc->frame_buf, 0, sizeof(desc->frame_buf));
+    desc->frame_len = 0;
+    desc->dialog_token = 0;
+}
+
+static ssize_t
+osw_rrm_meas_build_frame(const struct osw_rrm_meas_req_params *req_params,
+                         const struct osw_hwaddr *sta_addr,
+                         const struct osw_hwaddr *bssid,
+                         uint8_t dialog_token,
+                         uint8_t *frame_buf,
+                         size_t frame_buf_size)
+{
+    ASSERT(req_params != NULL, "");
+    ASSERT(frame_buf != NULL, "");
+    ASSERT(frame_buf_size > 0, "");
+
+    struct osw_drv_dot11_frame *frame = (struct osw_drv_dot11_frame*) frame_buf;
+    size_t frame_len = 0;
+    struct osw_drv_dot11_meas_req_ie *meas_req_ie;
+    struct osw_drv_dot11_meas_req_ie_subel_ssid *subel_ssid;
+    struct osw_drv_dot11_meas_req_ie_subel_bri *subel_bri;
+    struct osw_drv_dot11_meas_req_ie_subel_rep_det *subel_rep_det;
+
+    frame_len += offsetof(struct osw_drv_dot11_frame, u.action.u.rrm_meas_req);
+    frame_len += C_FIELD_SZ(struct osw_drv_dot11_frame, u.action.u.rrm_meas_req);
+    frame_len += sizeof(struct osw_drv_dot11_meas_req_ie);
+    frame_len += sizeof(struct osw_drv_dot11_meas_req_ie_subel_ssid);
+    frame_len += (uint8_t)req_params->ssid.len;
+    frame_len += sizeof(struct osw_drv_dot11_meas_req_ie_subel_bri);
+    frame_len += sizeof(struct osw_drv_dot11_meas_req_ie_subel_rep_det);
+
+    if (frame_len > frame_buf_size) {
+        LOGW("osw: rrm_meas: [sta: "OSW_HWADDR_FMT"] failed to build frame, to small buffer (len: %zu size: %zu)",
+             OSW_HWADDR_ARG(sta_addr), frame_len, frame_buf_size);
+        return -1;
+    }
+
+    frame->header.frame_control = htole16(0xd0);         // action frame
+    frame->header.duration      = htole16((uint16_t)60); // FIXME proper duration calculation if needed
+    frame->header.seq_ctrl      = htole16(0x0000);
+    memcpy(&frame->header.da, &sta_addr->octet, sizeof(frame->header.da));
+    /* If bssid is not provided leave it empty for
+     * lower layers to handle */
+    if (bssid != NULL)  memcpy(&frame->header.sa, &bssid->octet, sizeof(frame->header.sa));
+    if (bssid != NULL)  memcpy(&frame->header.bssid, &bssid->octet, sizeof(frame->header.bssid));
+
+    frame->u.action.category = DOT11_RRM_MEAS_REP_IE_CATEGORY_CODE;
+
+    frame->u.action.u.rrm_meas_req.action       = DOT11_RRM_MEAS_REQ_IE_ACTION_CODE;
+    frame->u.action.u.rrm_meas_req.dialog_token = dialog_token;
+    frame->u.action.u.rrm_meas_req.repetitions  = 0x0000;
+
+    meas_req_ie                = (struct osw_drv_dot11_meas_req_ie*) frame->u.action.u.rrm_meas_req.variable;
+    meas_req_ie->tag           = 0x26; // measurement request
+    meas_req_ie->token         = 0x00; // FIXME
+    meas_req_ie->req_mode      = 0x00;
+    meas_req_ie->req_type      = 0x05; // beacon request
+    meas_req_ie->op_class      = req_params->op_class;
+    meas_req_ie->channel       = req_params->channel;
+    meas_req_ie->rand_interval = htole16(0x0000);
+    meas_req_ie->duration      = htole16(0x0064);
+    meas_req_ie->meas_mode     = 0x01; // active
+    memcpy(meas_req_ie->bssid, &req_params->bssid.octet, OSW_HWADDR_LEN);
+
+    subel_ssid          = (struct osw_drv_dot11_meas_req_ie_subel_ssid*) meas_req_ie->variable;
+    subel_ssid->tag     = 0x00;
+    subel_ssid->tag_len = (uint8_t)req_params->ssid.len;
+    if (subel_ssid->tag_len) {
+        memcpy(subel_ssid->ssid, req_params->ssid.buf, subel_ssid->tag_len);
+    }
+
+    subel_bri                       = (struct osw_drv_dot11_meas_req_ie_subel_bri*) ((uint8_t*)subel_ssid + 2 + subel_ssid->tag_len);
+    subel_bri->tag                  = 0x01;
+    subel_bri->tag_len              = 0x02;
+    subel_bri->reporting_condition  = 0x00; // report to be issued after each measurement
+    subel_bri->thr_offs             = 0x00;
+
+    subel_rep_det                   = (struct osw_drv_dot11_meas_req_ie_subel_rep_det*) ((uint8_t*)subel_bri + 2 + subel_bri->tag_len);
+    subel_rep_det->tag              = 0x02;
+    subel_rep_det->tag_len          = 0x01;
+    subel_rep_det->reporting_detail = 0x00; // no fixed length fields or elements
+
+    meas_req_ie->tag_len = (uint8_t)((uint8_t*)subel_rep_det - (uint8_t*)meas_req_ie) + subel_rep_det->tag_len;
+
+    return frame_len;
+}
+
+size_t
+osw_rrm_meas_rep_parse_update_neighs(const void *action_data,
+                                     const size_t action_len,
+                                     const struct osw_hwaddr *sta_addr)
+{
+    const struct element *elem;
+    const struct osw_drv_dot11_frame_action *action = action_data;
+    const void *out_of_bounds = (const uint8_t *)action_data + action_len;
+    const void *ies_start = &action->u.rrm_meas_rep.variable[0];
+    const uint8_t *ies = ies_start;
+    const struct osw_drv_dot11_meas_rep_ie *meas_rep_ie;
+    struct osw_rrm_meas_rep_neigh *neigh;
+    struct osw_hwaddr bssid;
+    struct osw_rrm_meas_sta *sta = osw_rrm_meas_get_sta(sta_addr);
+    size_t len = out_of_bounds - ies_start;
+    size_t neigh_count = 0;
+
+    if ((const void *)&action->category >= out_of_bounds) return -5;
+    if ((const void *)&action->u.rrm_meas_rep.action >= out_of_bounds) return -6;
+    if (ies_start >= out_of_bounds) return -7;
+
+    if (action->category != DOT11_RRM_MEAS_REP_IE_CATEGORY_CODE) return -3;
+    if (action->u.rrm_meas_rep.action != DOT11_RRM_MEAS_REP_IE_ACTION_CODE) return -4;
+
+    /* FIXME: dialog token: correlate multiple in-flight or timed-out responses */
+
+    for_each_ie(elem, ies, len) {
+        if (elem->id == DOT11_RRM_MEAS_REP_IE_TAG &&
+            elem->datalen >= sizeof(*meas_rep_ie)) {
+
+            meas_rep_ie = (const void *)elem;
+            /* if refused */
+            if ((meas_rep_ie->report_mode) & DOT11_RRM_MEAS_REP_IE_REP_MODE_REFUSED_MSK) {
+                LOGI("osw: rrm_meas: [sta: "OSW_HWADDR_FMT
+                     "] measurement token: %d"
+                     " refused RRM request",
+                     OSW_HWADDR_ARG(&(sta->mac_addr)),
+                     meas_rep_ie->token);
+                break;
+            }
+
+            memcpy(bssid.octet, meas_rep_ie->bssid, OSW_HWADDR_LEN);
+            neigh = ds_tree_find(&sta->neigh_tree, &bssid);
+            if (neigh == NULL) {
+                LOGT("osw: rrm_meas: allocating new neighbor");
+                neigh = CALLOC(1, sizeof(*neigh));
+                neigh->bssid = bssid;
+                ds_tree_insert(&sta->neigh_tree, neigh, &neigh->bssid);
+            }
+
+            neigh->op_class = meas_rep_ie->op_class;
+            neigh->channel = meas_rep_ie->channel;
+            neigh->rcpi = meas_rep_ie->rcpi;
+            neigh->scan_start_time = le64toh(meas_rep_ie->start_time);
+            ++neigh_count;
+
+            LOGD("osw: rrm_meas: [sta: "OSW_HWADDR_FMT
+                 "] measurement token: %d"
+                 " reporting neighbor: "OSW_HWADDR_FMT
+                 " channel: %d rcpi: %d",
+                 OSW_HWADDR_ARG(&(sta->mac_addr)),
+                 meas_rep_ie->token,
+                 OSW_HWADDR_ARG(&(neigh->bssid)),
+                 neigh->channel,
+                 neigh->rcpi);
+
+            /* for further parsing:
+             * struct osw_drv_dot11_meas_rep_ie_subel_rep_frag_id * frag_id;
+             * if (elem->datalen >= sizeof(*meas_rep_ie) + sizeof(*frag_id)) {
+             *    frag_id = ((void *)elem) + sizeof(*meas_rep_ie);
+             * }
+             */
+        }
+    }
+    return neigh_count;
+}
+
+void
+osw_rrm_meas_rep_cb(struct osw_state_observer *self,
+                    const struct osw_state_vif_info *vif,
+                    const uint8_t *data,
+                    size_t len)
+{
+    const void *out_of_bounds = data + len;
+    const struct osw_drv_dot11_frame *frame = (const void *)data;
+    const void *action_data = &frame->u.action;
+    const size_t action_len = out_of_bounds - action_data;
+    const size_t sa_len = sizeof(frame->header.sa);
+    const void *sa = &frame->header.sa;
+    const void *sa_last_byte = sa + sa_len - 1;
+    struct osw_hwaddr sta_addr;
+
+    if (WARN_ON(sa_len != OSW_HWADDR_LEN)) return;
+    if (WARN_ON(sa_last_byte >= out_of_bounds)) return;
+    if (WARN_ON(action_data >= out_of_bounds)) return;
+
+    memcpy(sta_addr.octet, frame->header.sa, sa_len);
+
+    LOGI("osw: rrm_meas: %s/"OSW_HWADDR_FMT": received report from",
+         vif->vif_name,
+         OSW_HWADDR_ARG(&sta_addr));
+
+    osw_rrm_meas_rep_parse_update_neighs(action_data, action_len, &sta_addr);
+}
+
+static void
+osw_rrm_meas_sta_schedule_work_at(struct osw_rrm_meas_sta *rrm_meas_sta, uint64_t timestamp)
+{
+    ASSERT(rrm_meas_sta != NULL, "");
+    osw_timer_arm_at_nsec(&rrm_meas_sta->work_timer, timestamp);
+}
+
+static void
+osw_rrm_meas_sta_try_req_tx(struct osw_rrm_meas_sta *rrm_meas_sta)
+{
+    ASSERT(rrm_meas_sta != NULL, "");
+
+    const struct osw_drv_dot11_frame *frame = NULL;
+    struct osw_rrm_meas_desc *desc = NULL;
+
+    if (ds_dlist_is_empty(&rrm_meas_sta->desc_list) == true) {
+        goto cease_tx_attempt;
+    }
+
+    ds_dlist_foreach(&rrm_meas_sta->desc_list, desc)
+    {
+        frame = (const struct osw_drv_dot11_frame*) &desc->frame_buf;
+        switch (desc->state) {
+            case OSW_RRM_MEAS_DESC_STATE_PENDING:
+                /* just continue */
+                break;
+            case OSW_RRM_MEAS_DESC_STATE_IN_TRANSIT:
+                LOGT("osw: rrm_meas: [sta: "OSW_HWADDR_FMT" dialog_token: %u] req already in transit",
+                     OSW_HWADDR_ARG(&rrm_meas_sta->mac_addr), frame->u.action.u.rrm_meas_req.dialog_token);
+                goto cease_tx_attempt;
+            case OSW_RRM_MEAS_DESC_STATE_EMPTY:
+                LOGT("osw: rrm_meas: [sta: "OSW_HWADDR_FMT" dialog_token: %u] cannot tx empty req",
+                     OSW_HWADDR_ARG(&rrm_meas_sta->mac_addr), frame->u.action.u.rrm_meas_req.dialog_token);
+                goto cease_tx_attempt;
+        }
+
+        if (rrm_meas_sta->throttle != NULL) {
+            uint64_t next_at_nsec;
+            bool result;
+
+            result = osw_throttle_tap(rrm_meas_sta->throttle, &next_at_nsec);
+            if (result == false) {
+                osw_rrm_meas_sta_schedule_work_at(rrm_meas_sta, next_at_nsec);
+                LOGT("osw: rrm_meas: [sta: "OSW_HWADDR_FMT"] cease req tx attempt due to throttle condition",
+                     OSW_HWADDR_ARG(&rrm_meas_sta->mac_addr));
+                goto cease_tx_attempt;
+            }
+        }
+
+        desc->state = OSW_RRM_MEAS_DESC_STATE_IN_TRANSIT;
+
+        osw_drv_frame_tx_desc_set_frame(rrm_meas_sta->frame_tx_desc, desc->frame_buf, desc->frame_len);
+        if (desc->mux_frame_tx_schedule_fn == NULL) {
+            LOGE("osw: rrm_meas: no mux to send frame to");
+            goto cease_tx_attempt;
+        }
+
+        if (desc->phy_name == NULL || desc->vif_name == NULL) {
+            LOGE("osw: rrm_meas: phy_name or vif_name not provided - ceasing tx");
+        } else {
+            desc->mux_frame_tx_schedule_fn(desc->phy_name, desc->vif_name, rrm_meas_sta->frame_tx_desc);
+            LOGD("osw: rrm_meas: [sta: "OSW_HWADDR_FMT" dialog_token: %u] req was passed to drv",
+                 OSW_HWADDR_ARG(&rrm_meas_sta->mac_addr), frame->u.action.u.rrm_meas_req.dialog_token);
+        }
+        return;
+
+cease_tx_attempt:
+        LOGD("osw: rrm_meas: [sta: "OSW_HWADDR_FMT"] req tx attempt was ceased", OSW_HWADDR_ARG(&rrm_meas_sta->mac_addr));
+    }
+}
+
+static void
+osw_rrm_meas_sta_work_timer_cb(struct osw_timer *timer)
+{
+    struct osw_rrm_meas_sta *sta = (struct osw_rrm_meas_sta*) container_of(timer, struct osw_rrm_meas_sta, work_timer);
+    osw_rrm_meas_sta_try_req_tx(sta);
+}
+
+static void
+osw_rrm_meas_drv_frame_tx_result_cb(const struct osw_drv_frame_tx_desc *tx_desc,
+                                    enum osw_frame_tx_result result,
+                                    void *caller_priv)
+{
+    const struct osw_drv_dot11_frame *drv_frame = NULL;
+    const struct osw_drv_dot11_frame *rrm_meas_frame = NULL;
+    struct osw_rrm_meas_sta *sta = (struct osw_rrm_meas_sta *) caller_priv;
+    struct osw_rrm_meas_desc *rrm_meas_desc = ds_dlist_head(&sta->desc_list);
+
+    if (WARN_ON(rrm_meas_desc == NULL)) {
+        goto ignore_tx_report;
+    }
+
+    if (rrm_meas_desc->state != OSW_RRM_MEAS_DESC_STATE_IN_TRANSIT)
+        goto ignore_tx_report;
+
+    drv_frame = (const struct osw_drv_dot11_frame*) osw_drv_frame_tx_desc_get_frame(tx_desc);
+    rrm_meas_frame = (const struct osw_drv_dot11_frame*) &rrm_meas_desc->frame_buf;
+    if (WARN_ON(drv_frame == NULL))
+        goto ignore_tx_report;
+    if (WARN_ON(rrm_meas_frame == NULL))
+        goto ignore_tx_report;
+    if (WARN_ON(drv_frame->u.action.u.rrm_meas_req.dialog_token != rrm_meas_frame->u.action.u.rrm_meas_req.dialog_token))
+        goto ignore_tx_report;
+
+    LOGD("osw: rrm_meas: [sta: "OSW_HWADDR_FMT" dialog token: %u] drv reported req tx result: %s",
+         OSW_HWADDR_ARG(&sta->mac_addr), rrm_meas_frame->u.action.u.rrm_meas_req.dialog_token,
+         osw_frame_tx_result_to_cstr(result));
+
+    switch (result) {
+        case OSW_FRAME_TX_RESULT_SUBMITTED:
+            if (rrm_meas_desc->observer != NULL &&
+                rrm_meas_desc->observer->req_tx_complete_fn != NULL)
+                rrm_meas_desc->observer->req_tx_complete_fn(rrm_meas_desc->observer);
+            break;
+        case OSW_FRAME_TX_RESULT_FAILED:
+        case OSW_FRAME_TX_RESULT_DROPPED:
+            if (rrm_meas_desc->observer != NULL &&
+                rrm_meas_desc->observer->req_tx_error_fn != NULL)
+                rrm_meas_desc->observer->req_tx_error_fn(rrm_meas_desc->observer);
+            break;
+    }
+
+    osw_rrm_meas_desc_reset(rrm_meas_desc);
+    return;
+
+ignore_tx_report:
+        LOGD("osw: rrm_meas: [sta: "OSW_HWADDR_FMT"] ignored drv req tx report result: %s",
+             OSW_HWADDR_ARG(&sta->mac_addr), osw_frame_tx_result_to_cstr(result));
+}
+
+static struct osw_rrm_meas_sta *
+osw_rrm_meas_get_sta(const struct osw_hwaddr *sta_addr)
+{
+    ASSERT(sta_addr != NULL, "");
+
+    struct osw_rrm_meas_sta *sta = ds_tree_find(&g_sta_tree, sta_addr);
+
+    if (sta != NULL)
+        return sta;
+
+    sta = CALLOC(1, sizeof(*sta));
+    sta->owner = &g_sta_tree;
+    memcpy(&sta->mac_addr, sta_addr, sizeof(sta->mac_addr));
+    osw_timer_init(&sta->work_timer, osw_rrm_meas_sta_work_timer_cb);
+    sta->frame_tx_desc = osw_drv_frame_tx_desc_new(osw_rrm_meas_drv_frame_tx_result_cb, sta);
+    ds_dlist_init(&sta->desc_list, struct osw_rrm_meas_desc, node);
+    ds_tree_init(&sta->neigh_tree, (ds_key_cmp_t *)osw_hwaddr_cmp, struct osw_rrm_meas_rep_neigh, node);
+
+    ds_tree_insert(sta->owner, sta, &sta->mac_addr);
+
+    return sta;
+}
+
+static void
+osw_rrm_meas_rep_neigh_free(struct osw_rrm_meas_rep_neigh *neigh)
+{
+    ASSERT(neigh != NULL, "");
+    FREE(neigh);
+}
+
+static void
+osw_rrm_meas_desc_free(struct osw_rrm_meas_desc *desc)
+{
+    ASSERT(desc != NULL, "");
+    FREE(desc->vif_name);
+    FREE(desc->phy_name);
+    FREE(desc);
+}
+
+static void
+osw_rrm_meas_sta_free(struct osw_rrm_meas_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    struct osw_rrm_meas_desc *desc;
+    struct osw_rrm_meas_rep_neigh *neigh;
+
+    osw_throttle_free(sta->throttle);
+    osw_timer_disarm(&sta->work_timer);
+    osw_drv_frame_tx_desc_free(sta->frame_tx_desc);
+
+    while ((desc = ds_dlist_remove_head(&sta->desc_list)) != NULL) {
+        osw_rrm_meas_desc_free(desc);
+    }
+
+    while ((neigh = ds_tree_remove_head(&sta->neigh_tree)) != NULL) {
+        osw_rrm_meas_rep_neigh_free(neigh);
+    }
+
+    ds_tree_remove(sta->owner, sta);
+    FREE(sta);
+}
+
+struct osw_rrm_meas_desc *
+osw_rrm_meas_get_desc_internal(const struct osw_hwaddr *sta_addr,
+                               const struct osw_rrm_meas_sta_observer *observer,
+                               const char *phy_name,
+                               const char *vif_name,
+                               osw_rrm_meas_mux_frame_tx_schedule_fn_t *mux_frame_tx_schedule_fn)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(observer != NULL, "");
+    ASSERT(mux_frame_tx_schedule_fn != NULL, "");
+
+    struct osw_rrm_meas_sta *sta = osw_rrm_meas_get_sta(sta_addr);
+    struct osw_rrm_meas_desc *desc = CALLOC(1, sizeof(*desc));
+
+    desc->sta = sta;
+    desc->observer = observer;
+    desc->mux_frame_tx_schedule_fn = mux_frame_tx_schedule_fn;
+    if (vif_name != NULL)
+        desc->vif_name = STRDUP(vif_name);
+    if (phy_name != NULL)
+        desc->phy_name = STRDUP(phy_name);
+
+    ds_dlist_insert_tail(&sta->desc_list, desc);
+
+    return desc;
+}
+
+struct osw_rrm_meas_desc *
+osw_rrm_meas_get_desc(const struct osw_hwaddr *sta_addr,
+                      const struct osw_rrm_meas_sta_observer *observer,
+                      const char *phy_name,
+                      const char *vif_name)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(observer != NULL, "");
+
+    /* If phy_name and/or vif_name is not specified
+     * pass NULL for lower layers to handle it as a
+     * best-effort */
+    return osw_rrm_meas_get_desc_internal(sta_addr,
+                                          observer,
+                                          phy_name,
+                                          vif_name,
+                                          osw_mux_frame_tx_schedule);
+}
+
+bool
+osw_rrm_meas_desc_set_req_params(struct osw_rrm_meas_desc *desc,
+                                 const struct osw_rrm_meas_req_params *params)
+{
+    ASSERT(desc != NULL, "");
+
+    struct osw_rrm_meas_sta *rrm_meas_sta = desc->sta;
+    const struct osw_state_vif_info *vif_info = osw_state_vif_lookup(desc->phy_name,
+                                                                     desc->vif_name);
+    const struct osw_hwaddr *bssid = NULL;
+    if (vif_info != NULL && vif_info->drv_state != NULL)
+        bssid = &vif_info->drv_state->mac_addr;
+    else {
+        LOGW("osw: rrm_meas: vif not found in osw_state when setting frame parameters");
+    }
+
+    ds_dlist_remove(&rrm_meas_sta->desc_list, desc);
+    ds_dlist_insert_tail(&rrm_meas_sta->desc_list, desc);
+
+    if (params == NULL) {
+        osw_rrm_meas_desc_reset(desc);
+        return true;
+    }
+
+    desc->dialog_token = osw_rrm_meas_desc_generate_dialog_token(rrm_meas_sta);
+
+    desc->frame_len = osw_rrm_meas_build_frame(params,
+                                               &rrm_meas_sta->mac_addr,
+                                               bssid,
+                                               desc->dialog_token,
+                                               desc->frame_buf,
+                                               sizeof(desc->frame_buf));
+    if (desc->frame_len < 0) {
+        osw_rrm_meas_desc_reset(desc);
+        return false;
+    }
+
+    desc->state = OSW_RRM_MEAS_DESC_STATE_PENDING;
+    osw_rrm_meas_sta_schedule_work_at(rrm_meas_sta, 0);
+
+    return true;
+}
+
+struct osw_rrm_meas_sta *
+osw_rrm_meas_desc_get_sta(struct osw_rrm_meas_desc *desc)
+{
+    ASSERT(desc != NULL, "");
+    ASSERT(desc->sta != NULL, "");
+    return desc->sta;
+}
+
+void
+osw_rrm_meas_sta_set_throttle(struct osw_rrm_meas_sta *rrm_meas_sta,
+                              struct osw_throttle *throttle)
+{
+    ASSERT(rrm_meas_sta != NULL, "");
+    ASSERT(throttle != NULL, "");
+
+    osw_throttle_free(rrm_meas_sta->throttle);
+    rrm_meas_sta->throttle = throttle;
+
+    osw_rrm_meas_sta_schedule_work_at(rrm_meas_sta, 0);
+}
+
+const struct osw_rrm_meas_rep_neigh *
+osw_rrm_meas_get_neigh(const struct osw_hwaddr *sta_addr,
+                       const struct osw_hwaddr *bssid)
+{
+    struct osw_rrm_meas_sta *sta = ds_tree_find(&g_sta_tree, sta_addr);
+    return ds_tree_find(&sta->neigh_tree, bssid);
+}
+
+OSW_MODULE(osw_rrm_meas)
+{
+    struct osw_state_observer *state_observer = CALLOC(1, sizeof(*state_observer));
+    state_observer->name = "osw_rrm_meas";
+    state_observer->vif_rrm_rep_fn = osw_rrm_meas_rep_cb;
+    osw_state_register_observer(state_observer);
+    return NULL;
+}
+
+#include "osw_rrm_meas_ut.c"
Index: core/src/lib/osw/src/osw_rrm_meas_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_rrm_meas_ut.c
@@ -0,0 +1,282 @@
+#include "osw_ut.h"
+#include "osw_drv_common.h"
+#include "osw_drv_i.h"
+#include "osw_state_i.h"
+
+struct osw_rrm_meas_ut_dummy_drv {
+    unsigned int frame_tx_cnt;
+    uint8_t frame_buf [OSW_DRV_FRAME_TX_DESC_BUF_SIZE];
+    ssize_t frame_len;
+};
+
+struct osw_rrm_meas_ut_sta_observer {
+    const struct osw_rrm_meas_sta_observer observer;
+    unsigned int tx_complete_cnt;
+    unsigned int tx_error_cnt;
+};
+
+/* FIXME pass this as a cookie instead of having global variable */
+static struct osw_rrm_meas_ut_dummy_drv g_dummy_drv = {
+    .frame_tx_cnt = 0,
+    .frame_buf = { 0 },
+    .frame_len = 0,
+};
+
+OSW_UT(osw_rrm_meas_ut_build_frame)
+{
+    static const unsigned char ref_frame_1[] = {
+        0xd0, 0x00, 0x3c, 0x00, 0xd4, 0x61, 0x9d, 0x53,
+        0x75, 0x05, 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe,
+        0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe, 0x00, 0x00,
+        0x05, 0x00, 0x00, 0x00, 0x00, 0x26, 0x19, 0x00,
+        0x00, 0x05, 0x51, 0x00, 0x00, 0x00, 0x64, 0x00,
+        0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+        0x00, 0x01, 0x02, 0x00, 0x00, 0x02, 0x01, 0x00,
+    };
+
+    static const unsigned char ref_frame_2[] = {
+        0xd0, 0x00, 0x3c, 0x00, 0xd4, 0x61, 0x9d, 0x53,
+        0x75, 0x05, 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe,
+        0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe, 0x00, 0x00,
+        0x05, 0x00, 0x00, 0x00, 0x00, 0x26, 0x19, 0x00,
+        0x00, 0x05, 0x51, 0x00, 0x00, 0x00, 0x64, 0x00,
+        0x01, 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0x00,
+        0x00, 0x01, 0x02, 0x00, 0x00, 0x02, 0x01, 0x00,
+    };
+    static const unsigned char ref_frame_3[] = {
+        0xd0, 0x00, 0x3c, 0x00, 0xd4, 0x61, 0x9d, 0x53,
+        0x75, 0x05, 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe,
+        0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe, 0x00, 0x00,
+        0x05, 0x00, 0x00, 0x00, 0x00, 0x26, 0x25, 0x00,
+        0x00, 0x05, 0x51, 0x00, 0x00, 0x00, 0x64, 0x00,
+        0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+        0x0c, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
+        0x2d, 0x73, 0x73, 0x69, 0x64, 0x01, 0x02, 0x00,
+        0x00, 0x02, 0x01, 0x00,
+    };
+
+    uint8_t frame_buf[OSW_DRV_FRAME_TX_DESC_BUF_SIZE] = { 0 };
+    ssize_t frame_len = 0;
+
+    const struct osw_hwaddr bssid = { .octet = { 0x52, 0xb4, 0xf7, 0xf0, 0x1a, 0xbe } };
+    const struct osw_hwaddr sta_addr = { .octet = { 0xd4, 0x61, 0x9d, 0x53, 0x75, 0x05 } };
+    const uint8_t dialog_token = 0;
+
+    const struct osw_rrm_meas_req_params req_params_1 = {
+        .op_class = 81,
+        .channel = 0, // all supported channels on provided op_class
+        .bssid    = { .octet = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } }, //broadcast
+        .ssid     = { .buf = "", .len = strlen("") }, //any ssid
+    };
+
+    const struct osw_rrm_meas_req_params req_params_2 = {
+        .op_class = 81,
+        .channel  = 0,
+        .bssid    = { .octet = { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe } },
+        .ssid     = { .buf = "", .len = strlen("") },
+    };
+
+    const struct osw_rrm_meas_req_params req_params_3 = {
+        .op_class = 81,
+        .channel  = 0,
+        .bssid    = { .octet = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
+        .ssid     = { .buf = "example-ssid", .len = strlen("example-ssid") },
+    };
+
+    frame_len = osw_rrm_meas_build_frame(&req_params_1, &sta_addr, &bssid, dialog_token, frame_buf, sizeof(frame_buf));
+    assert(frame_len == sizeof(ref_frame_1));
+    assert(memcmp(&frame_buf, &ref_frame_1, frame_len) == 0);
+
+    frame_len = osw_rrm_meas_build_frame(&req_params_2, &sta_addr, &bssid, dialog_token, frame_buf, sizeof(frame_buf));
+    assert(frame_len == sizeof(ref_frame_2));
+    assert(memcmp(&frame_buf, &ref_frame_2, frame_len) == 0);
+
+    frame_len = osw_rrm_meas_build_frame(&req_params_3, &sta_addr, &bssid, dialog_token, frame_buf, sizeof(frame_buf));
+    assert(frame_len == sizeof(ref_frame_3));
+    assert(memcmp(&frame_buf, &ref_frame_3, frame_len) == 0);
+}
+
+static bool
+osw_rrm_meas_ut_mux_frame_tx_schedule_success(const char *phy_name,
+                                         const char *vif_name,
+                                         struct osw_drv_frame_tx_desc *desc)
+{
+    g_dummy_drv.frame_tx_cnt++;
+    memcpy(&g_dummy_drv.frame_buf, osw_drv_frame_tx_desc_get_frame(desc), osw_drv_frame_tx_desc_get_frame_len(desc));
+    g_dummy_drv.frame_len = osw_drv_frame_tx_desc_get_frame_len(desc);
+
+    osw_rrm_meas_drv_frame_tx_result_cb(desc, OSW_FRAME_TX_RESULT_SUBMITTED, desc->caller_priv);
+
+    return true;
+}
+
+static bool
+osw_rrm_meas_ut_mux_frame_tx_schedule_error(const char *phy_name,
+                                            const char *vif_name,
+                                            struct osw_drv_frame_tx_desc *desc)
+{
+    g_dummy_drv.frame_tx_cnt++;
+    memcpy(&g_dummy_drv.frame_buf, osw_drv_frame_tx_desc_get_frame(desc), osw_drv_frame_tx_desc_get_frame_len(desc));
+    g_dummy_drv.frame_len = osw_drv_frame_tx_desc_get_frame_len(desc);
+
+    osw_rrm_meas_drv_frame_tx_result_cb(desc, OSW_FRAME_TX_RESULT_FAILED, desc->caller_priv);
+
+    return true;
+}
+
+static void
+osw_rrm_meas_req_tx_complete_cb(const struct osw_rrm_meas_sta_observer *observer)
+{
+    struct osw_rrm_meas_ut_sta_observer *sta_observer = (struct osw_rrm_meas_ut_sta_observer*) container_of(observer, struct osw_rrm_meas_ut_sta_observer, observer);
+    sta_observer->tx_complete_cnt++;
+}
+
+static void
+osw_rrm_meas_req_tx_error_cb(const struct osw_rrm_meas_sta_observer *observer)
+{
+    struct osw_rrm_meas_ut_sta_observer *sta_observer = (struct osw_rrm_meas_ut_sta_observer*) container_of(observer, struct osw_rrm_meas_ut_sta_observer, observer);
+    sta_observer->tx_error_cnt++;
+}
+
+OSW_UT(osw_rrm_meas_ut_send_single_meas)
+{
+    const struct osw_drv_dot11_frame *frame = NULL;
+    const struct osw_hwaddr sta_addr = { .octet = { 0xd4, 0x61, 0x9d, 0x53, 0x75, 0x05, } };
+    const struct osw_rrm_meas_req_params req_params = {
+        .op_class = 81,
+        .channel  = 0,
+        .bssid    = { .octet = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } },
+        .ssid     = { .buf = "", .len = strlen("") },
+    };
+    char *phy_name = "phy0";
+    char *vif_name = "vif0";
+    struct osw_rrm_meas_desc *desc = NULL;
+    struct osw_rrm_meas_ut_sta_observer sta_observer = {
+        .observer = {
+            .req_tx_complete_fn = osw_rrm_meas_req_tx_complete_cb,
+            .req_tx_error_fn = osw_rrm_meas_req_tx_error_cb,
+        },
+        .tx_complete_cnt = 0,
+        .tx_error_cnt = 0,
+    };
+    bool result;
+
+    osw_time_set_mono_clk(0);
+    osw_time_set_wall_clk(0);
+
+    desc = osw_rrm_meas_get_desc_internal(&sta_addr,
+                                          &sta_observer.observer,
+                                          phy_name,
+                                          vif_name,
+                                          osw_rrm_meas_ut_mux_frame_tx_schedule_success);
+    assert(desc != NULL);
+
+    /* Schedule RRM Measurement Request */
+    result = osw_rrm_meas_desc_set_req_params(desc, &req_params);
+    osw_ut_time_advance(0);
+
+    assert(result == true);
+    assert(sta_observer.tx_complete_cnt == 1);
+    assert(sta_observer.tx_error_cnt == 0);
+    assert(g_dummy_drv.frame_tx_cnt == 1);
+    frame = (const struct osw_drv_dot11_frame*) &g_dummy_drv.frame_buf;
+    assert(frame->u.action.u.rrm_meas_req.dialog_token == 0);
+
+    /* Schedule RRM Measurement Request again for connected STA */
+    result = osw_rrm_meas_desc_set_req_params(desc, &req_params);
+    osw_ut_time_advance(0);
+
+    assert(result == true);
+    assert(sta_observer.tx_complete_cnt == 2);
+    assert(sta_observer.tx_error_cnt == 0);
+    assert(g_dummy_drv.frame_tx_cnt == 2);
+    frame = (const struct osw_drv_dot11_frame*) &g_dummy_drv.frame_buf;
+    assert(frame->u.action.u.rrm_meas_req.dialog_token == 1);
+
+    /* Recreate desc, but with failing drv tx */
+    osw_rrm_meas_sta_free(desc->sta);
+
+    desc = osw_rrm_meas_get_desc_internal(&sta_addr,
+                                          &sta_observer.observer,
+                                          phy_name,
+                                          vif_name,
+                                          osw_rrm_meas_ut_mux_frame_tx_schedule_error);
+
+    /* Schedule RRM Measurement Request again for connected STA */
+    result = osw_rrm_meas_desc_set_req_params(desc, &req_params);
+    osw_ut_time_advance(0);
+
+    assert(result == true);
+    assert(sta_observer.tx_complete_cnt == 2);
+    assert(sta_observer.tx_error_cnt == 1);
+    assert(g_dummy_drv.frame_tx_cnt == 3);
+    frame = (const struct osw_drv_dot11_frame*) &g_dummy_drv.frame_buf;
+    assert(frame->u.action.u.rrm_meas_req.dialog_token == 0);
+    osw_rrm_meas_sta_free(desc->sta);
+}
+
+OSW_UT(osw_rrm_meas_ut_process_rrm_report)
+{
+    const struct osw_hwaddr sta_mac_1 = { .octet = { 0xde, 0xad, 0xca, 0xfe, 0xfe, 0xed } };
+    const struct osw_hwaddr sta_mac_2 = { .octet = { 0x01, 0x23, 0x34, 0x56, 0x78, 0x9a } };
+    const struct osw_hwaddr neigh1_mac_1 = { .octet = { 0xfe, 0x9f, 0x07, 0x00, 0xb1, 0x8c } };
+    const struct osw_hwaddr neigh2_mac_1 = { .octet = { 0xfe, 0x9f, 0x07, 0x00, 0xb1, 0x69 } };
+    static const unsigned char report_frame_1[] = {
+        0x05, 0x01, 0x01, 0x27, 0x21, 0x02, 0x00, 0x05,
+        0x80, 0x2c, 0x21, 0x37, 0xfd, 0xa8, 0x00, 0x00,
+        0x00, 0x00, 0x1e, 0x00, 0x09, 0xa4, 0xff, 0xfe,
+        0x9f, 0x07, 0x00, 0xb1, 0x8c, 0x00, 0xe1, 0xe9,
+        0x28, 0x2e, 0x02, 0x02, 0x01, 0x00, 0x27, 0x21,
+        0x02, 0x00, 0x05, 0x80, 0x2c, 0x21, 0x37, 0xfd,
+        0xa8, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x09,
+        0xa2, 0xff, 0xfe, 0x9f, 0x07, 0x00, 0xb1, 0x69,
+        0x00, 0xa0, 0xd7, 0x28, 0x2e, 0x02, 0x02, 0x01,
+        0x00,
+    };
+
+    static const unsigned char report_frame_2[] = {
+        0x05, 0x01, 0x01, 0x27, 0x03, 0x02, 0x04, 0x05,
+        0xd8, 0x0b, 0xb4, 0xf4,
+    };
+    size_t neigh_count;
+    struct osw_rrm_meas_rep_neigh *neigh;
+    struct osw_rrm_meas_desc *sta_desc_1, *sta_desc_2;
+    struct osw_rrm_meas_sta_observer sta_observer = {
+        .req_tx_complete_fn = osw_rrm_meas_req_tx_complete_cb,
+        .req_tx_error_fn = osw_rrm_meas_req_tx_error_cb,
+    };
+
+    /* create 2 stations */
+    sta_desc_1 = osw_rrm_meas_get_desc(&sta_mac_1, &sta_observer, NULL, NULL);
+    sta_desc_2 = osw_rrm_meas_get_desc(&sta_mac_2, &sta_observer, NULL, NULL);
+    assert(sta_desc_1 != NULL);
+    assert(sta_desc_2 != NULL);
+
+    /* validate report of 2 neighbors */
+    neigh_count = osw_rrm_meas_rep_parse_update_neighs(report_frame_1,
+                                                       sizeof(report_frame_1),
+                                                       &sta_mac_1);
+    assert(neigh_count == 2);
+
+    neigh = (struct osw_rrm_meas_rep_neigh *)osw_rrm_meas_get_neigh(&sta_mac_1, &neigh1_mac_1);
+    assert(neigh != NULL);
+    assert(memcmp(neigh->bssid.octet, neigh1_mac_1.octet, OSW_HWADDR_LEN) == 0);
+    assert(neigh->op_class == 128);
+    assert(neigh->channel == 44);
+    assert(neigh->rcpi == 164);
+    assert(neigh->scan_start_time == 0x00000000a8fd3721);
+
+    neigh = (struct osw_rrm_meas_rep_neigh *)osw_rrm_meas_get_neigh(&sta_mac_1, &neigh2_mac_1);
+    assert(neigh != NULL);
+    assert(memcmp(neigh->bssid.octet, neigh2_mac_1.octet, OSW_HWADDR_LEN) == 0);
+    assert(neigh->op_class == 128);
+    assert(neigh->channel == 44);
+    assert(neigh->rcpi == 162);
+    assert(neigh->scan_start_time == 0x00000000a8fd3721);
+
+    /* validate rejected report */
+    neigh_count = osw_rrm_meas_rep_parse_update_neighs(report_frame_2,
+                                                       sizeof(report_frame_2),
+                                                       &sta_mac_2);
+    assert(neigh_count == 0);
+}
Index: core/src/lib/osw/src/osw_sampler.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_sampler.c
@@ -0,0 +1,107 @@
+#include <stdbool.h>
+#include <memutil.h>
+#include <os_time.h>
+#include <math.h>
+#include <osw_sampler.h>
+
+/* FIXME: This can be greatly simplified. This is
+ * essentially a periodic timer with an aligned arming time
+ * and an offset against that alignment.
+ */
+
+/* This should be power of 2. If changed unit tests will
+ * need to be tweaked because comparing floats is a tricky
+ * business.
+ */
+#define OSW_SAMPLER_GRACE_SEC (1.0 / 256.0) /* roughly 4ms */
+
+static inline double double_max(double a, double b) { return a > b ? a : b; }
+static inline double double_min(double a, double b) { return a < b ? a : b; }
+
+void
+osw_sampler_set_period_seconds(struct osw_sampler *s,
+                               const double seconds)
+{
+    s->period_seconds = seconds;
+}
+
+bool
+osw_sampler_is_started(struct osw_sampler *s)
+{
+    return s->next_poll_tstamp > 0;
+}
+
+double
+osw_timer_adjust(double *at,
+                 double *latency,
+                 double *started_at,
+                 const double margin,
+                 const double now)
+{
+    if (*started_at <= 0) return 0;
+
+    const double delay = now - *started_at;
+    const double new_latency = delay + margin;
+    const double error = new_latency - *latency;
+    *started_at = 0;
+    *latency = new_latency;
+    *at -= error;
+    return error;
+}
+
+double
+osw_sampler_adjust(struct osw_sampler *s,
+                   const double now)
+{
+    return osw_timer_adjust(&s->next_poll_tstamp,
+                            &s->poll_delay_seconds,
+                            &s->poll_started_tstamp,
+                            OSW_SAMPLER_GRACE_SEC,
+                            now);
+}
+
+static unsigned int
+osw_sampler_advance(double *tstamp,
+                    const double now,
+                    const double period)
+{
+    if (now < *tstamp) return 0;
+    const unsigned int ticks = floor((now - *tstamp) / period) + 1;
+    *tstamp += ticks * period;
+    return ticks;
+}
+
+void
+osw_sampler_start_at(struct osw_sampler *s,
+                     const double now)
+{
+    s->poll_started_tstamp = now;
+    s->poll_delay_seconds = 0;
+    s->next_poll_tstamp = 0;
+    osw_sampler_advance(&s->next_poll_tstamp, now, s->period_seconds);
+    osw_sampler_adjust(s, now);
+}
+
+double
+osw_sampler_get_remaining_seconds(const struct osw_sampler *s,
+                                  const double now)
+{
+    const double b = s->next_poll_tstamp - now;
+    const double y = double_max(0, b);
+    return y;
+}
+
+int
+osw_sampler_run(struct osw_sampler *s,
+                const double now)
+{
+    const unsigned int ticks = osw_sampler_advance(&s->next_poll_tstamp, now, s->period_seconds);
+    if (ticks > 0) {
+        s->poll_started_tstamp = now;
+        return ticks;
+    }
+
+    return false;
+}
+
+#include "osw_sampler_ut.c.h"
Index: core/src/lib/osw/src/osw_sampler_ut.c.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_sampler_ut.c.h
@@ -0,0 +1,30 @@
+#include <ev.h>
+#include <assert.h>
+#include <osw_ut.h>
+
+#include <stdio.h>
+
+OSW_UT(osw_sampler)
+{
+    const double t0 = 1.0;
+    struct osw_sampler s_;
+    struct osw_sampler *s = &s_;
+    osw_sampler_set_period_seconds(s, 1.0);
+    osw_sampler_start_at(s, t0);
+    assert(s->next_poll_tstamp == 2.0 - OSW_SAMPLER_GRACE_SEC);
+    assert(osw_sampler_get_remaining_seconds(s, t0) == (1.0 - OSW_SAMPLER_GRACE_SEC));
+
+    const double t1 = s->next_poll_tstamp;
+    assert(osw_sampler_get_remaining_seconds(s, t1) == 0);
+    assert(osw_sampler_run(s, t1) == 1);
+    assert(s->next_poll_tstamp == (3.0 - OSW_SAMPLER_GRACE_SEC));
+    assert(osw_sampler_get_remaining_seconds(s, t1) == s->period_seconds);
+
+    const double t2 = 2.0;
+    assert(osw_sampler_run(s, t2) == 0);
+    assert(s->next_poll_tstamp == (3.0 - OSW_SAMPLER_GRACE_SEC));
+
+    const double t3 = 4.0;
+    assert(osw_sampler_run(s, t3) == 2);
+    assert(osw_sampler_run(s, t3) == 0);
+}
Index: core/src/lib/osw/src/osw_sta_cache.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_sta_cache.c
@@ -0,0 +1,677 @@
+#include <time.h>
+#include <memutil.h>
+#include <const.h>
+#include <util.h>
+#include <log.h>
+#include <ds_tree.h>
+#include <ds_dlist.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_ut.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_sta_cache.h>
+#include "osw_sta_i.h"
+#include "osw_sta_link_i.h"
+
+#define OSW_STA_GC_PERIOD_SEC 60.
+#define OSW_STA_GC_EXPIRATION_SEC OSW_STA_GC_PERIOD_SEC
+
+struct osw_sta_cache {
+    struct osw_state_observer state_obs;
+    struct ds_dlist observer_list;
+    struct ds_tree sta_tree;
+    ev_signal sigusr1;
+};
+
+static struct osw_sta_link*
+osw_sta_link_create(const struct osw_state_vif_info *vif)
+{
+    ASSERT(vif != NULL, "");
+    ASSERT(vif->vif_name != NULL, "");
+
+    struct osw_sta_link *link = CALLOC(1, sizeof(*link));
+    STRSCPY_WARN(link->vif_name.buf, vif->vif_name);
+    link->vif = vif;
+    return link;
+}
+
+static void
+osw_sta_link_free(struct osw_sta_link *link)
+{
+    ASSERT(link != NULL, "");
+
+    FREE(link->assoc_req_ies);
+    FREE(link);
+}
+
+static bool
+osw_sta_is_alive(struct osw_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    struct osw_sta_link *link;
+    const uint64_t now_nsec = osw_time_mono_clk();
+
+    ds_tree_foreach(&sta->link_tree, link) {
+        if (link->connected == true)
+            return true;
+
+        if (link->last_connect_tstamp_nsec > 0 && OSW_TIME_SEC(now_nsec - link->last_connect_tstamp_nsec) <= OSW_STA_GC_EXPIRATION_SEC)
+           return true;
+
+        if (link->last_probe_req_tstamp_nsec > 0 && OSW_TIME_SEC(now_nsec - link->last_probe_req_tstamp_nsec) <= OSW_STA_GC_EXPIRATION_SEC)
+           return true;
+    }
+
+    return false;
+}
+
+static void
+osw_sta_free(struct osw_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    struct osw_sta_link *link;
+    struct osw_sta_link *tmp_link;
+    struct osw_sta_observer *obs;
+    struct osw_sta_observer *tmp_obs;
+
+    ds_tree_foreach_safe(&sta->link_tree, link, tmp_link) {
+        ds_tree_remove(&sta->link_tree, link);
+        osw_sta_link_free(link);
+    }
+    ds_dlist_foreach_safe(&sta->observer_list, obs, tmp_obs) {
+        ds_dlist_remove(&sta->observer_list, obs);
+    }
+    osw_timer_disarm(&sta->gc);
+    FREE(sta);
+}
+
+static void
+osw_sta_gc_cb(struct osw_timer *timer)
+{
+    struct osw_sta_cache_observer *obs;
+    struct osw_sta *sta = container_of(timer, struct osw_sta, gc);
+
+    if (osw_sta_is_alive(sta) == true)
+        return;
+
+    ds_dlist_foreach(&sta->cache->observer_list, obs)
+        if (obs->vanished_fn != NULL)
+            obs->vanished_fn(obs, sta);
+
+    LOGD("osw: sta: "OSW_HWADDR_FMT": gc absent", OSW_HWADDR_ARG(&sta->mac_addr));
+    ds_tree_remove(&sta->cache->sta_tree, sta);
+    osw_sta_free(sta);
+}
+
+static struct osw_sta*
+osw_sta_create(struct osw_sta_cache *cache,
+               const struct osw_hwaddr *mac_addr)
+{
+    ASSERT(mac_addr != NULL, "");
+
+    struct osw_sta *sta = CALLOC(1, sizeof(*sta));
+
+    memcpy(&sta->mac_addr, mac_addr, sizeof(*mac_addr));
+    sta->cache = cache;
+    ds_tree_init(&sta->link_tree, ds_str_cmp, struct osw_sta_link, node);
+    ds_dlist_init(&sta->observer_list, struct osw_sta_observer, node);
+    osw_timer_init(&sta->gc, osw_sta_gc_cb);
+    osw_timer_arm_at_nsec(&sta->gc, osw_time_mono_clk() + OSW_TIME_SEC(OSW_STA_GC_PERIOD_SEC));
+
+    return sta;
+}
+
+static struct osw_sta*
+osw_sta_cache_get_sta(struct osw_sta_cache *cache,
+                      const struct osw_hwaddr *mac_addr)
+{
+    ASSERT(mac_addr != NULL, "");
+
+    struct osw_sta_cache_observer *obs;
+    struct osw_sta *sta;
+
+    sta = ds_tree_find(&cache->sta_tree, mac_addr);
+    if (sta != NULL)
+        return sta;
+
+    sta = osw_sta_create(cache, mac_addr);
+    ds_tree_insert(&cache->sta_tree, sta, &sta->mac_addr);
+
+    ds_dlist_foreach(&cache->observer_list, obs)
+        if (obs->appeared_fn != NULL)
+            obs->appeared_fn(obs, sta);
+
+    return sta;
+}
+
+static struct osw_sta_link*
+osw_sta_get_link(struct osw_sta *sta,
+                 const struct osw_state_vif_info *vif)
+{
+    ASSERT(sta != NULL, "");
+    ASSERT(vif != NULL, "");
+
+    struct osw_sta_link *link = ds_tree_find(&sta->link_tree, vif->vif_name);
+    if (link != NULL)
+        return link;
+
+    link = osw_sta_link_create(vif);
+    ds_tree_insert(&sta->link_tree, link, link->vif_name.buf);
+
+    return link;
+}
+
+static void
+osw_sta_cache_sta_connected_cb(struct osw_state_observer *self,
+                               const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct osw_sta_observer *obs;
+    struct osw_sta_cache *cache = container_of(self, struct osw_sta_cache, state_obs);
+    struct osw_sta* sta = osw_sta_cache_get_sta(cache, sta_info->mac_addr);
+    struct osw_sta_link *link = osw_sta_get_link(sta, sta_info->vif);
+
+    link->connected = true;
+    link->last_connect_tstamp_nsec = OSW_TIME_SEC(sta_info->connected_at);
+    FREE(link->assoc_req_ies);
+    if (link->assoc_req_ies != NULL && link->assoc_req_ies_len > 0) {
+        link->assoc_req_ies = MEMNDUP(sta_info->assoc_req_ies, sta_info->assoc_req_ies_len);
+        link->assoc_req_ies_len = sta_info->assoc_req_ies_len;
+    }
+
+    ds_dlist_foreach(&sta->observer_list, obs)
+        if (obs->connected_fn != NULL)
+            obs->connected_fn(obs, sta, link);
+}
+
+static void
+osw_sta_cache_sta_disconnected_cb(struct osw_state_observer *self,
+                                  const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct osw_sta_observer *obs;
+    struct osw_sta_cache *cache = container_of(self, struct osw_sta_cache, state_obs);
+    struct osw_sta* sta = osw_sta_cache_get_sta(cache, sta_info->mac_addr);
+    struct osw_sta_link *link = osw_sta_get_link(sta, sta_info->vif);
+
+    link->connected = false;
+
+    ds_dlist_foreach(&sta->observer_list, obs)
+        if (obs->disconnected_fn != NULL)
+            obs->disconnected_fn(obs, sta, link);
+}
+
+static void
+osw_sta_cache_vif_removed_cb(struct osw_state_observer *self,
+                             const struct osw_state_vif_info *vif)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(vif != NULL, "");
+
+    struct osw_sta* sta;
+    struct osw_sta_cache *cache = container_of(self, struct osw_sta_cache, state_obs);
+
+    ds_tree_foreach(&cache->sta_tree, sta) {
+        struct osw_sta_link *link = ds_tree_find(&sta->link_tree, vif->vif_name);
+        if (link == NULL)
+            continue;
+
+        ds_tree_remove(&sta->link_tree, link);
+        osw_sta_link_free(link);
+    }
+}
+
+static void
+osw_sta_cache_vif_changed_cb(struct osw_state_observer *self,
+                             const struct osw_state_vif_info *vif)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(vif != NULL, "");
+
+    struct osw_sta* sta;
+    struct osw_sta_cache *cache = container_of(self, struct osw_sta_cache, state_obs);
+
+    ds_tree_foreach(&cache->sta_tree, sta) {
+        struct osw_sta_link *link = ds_tree_find(&sta->link_tree, vif->vif_name);
+        if (link == NULL)
+            continue;
+
+        link->vif = vif;
+    }
+}
+
+static void
+osw_sta_cache_vif_probe_req_cb(struct osw_state_observer *self,
+                               const struct osw_state_vif_info *vif,
+                               const struct osw_drv_report_vif_probe_req *probe_req)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(vif != NULL, "");
+    ASSERT(probe_req != NULL, "");
+
+    struct osw_sta_observer *obs;
+    struct osw_sta_cache *cache = container_of(self, struct osw_sta_cache, state_obs);
+    struct osw_sta* sta = osw_sta_cache_get_sta(cache, &probe_req->sta_addr);
+    struct osw_sta_link *link = osw_sta_get_link(sta, vif);
+
+    link->last_probe_req_tstamp_nsec = osw_time_mono_clk();
+
+    ds_dlist_foreach(&sta->observer_list, obs)
+        if (obs->probe_req_fn != NULL)
+            obs->probe_req_fn(obs, sta, link, probe_req);
+}
+
+static void
+osw_sta_cache_dump(struct osw_sta_cache *cache)
+{
+    ASSERT(cache != NULL, "");
+
+    struct osw_sta *sta;
+
+    LOGI("osw: sta_cache: ");
+    LOGI("osw: sta_cache: sta_tree:");
+
+    ds_tree_foreach(&cache->sta_tree, sta) {
+        struct osw_sta_link *link;
+
+        LOGI("osw: sta_cache:   sta: "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&sta->mac_addr));
+        LOGI("osw: sta_cache:     link_tree:");
+
+        ds_tree_foreach(&sta->link_tree, link) {
+            char last_connect_tstamp_buf[64] = { 0 };
+            char last_probe_req_tstamp_buf[64] = { 0 };
+            const time_t last_connect_tstamp = OSW_TIME_TO_TIME_T(link->last_connect_tstamp_nsec);
+            const time_t last_probe_req_tstamp = OSW_TIME_TO_TIME_T(link->last_probe_req_tstamp_nsec);
+            struct tm buf;
+
+            if (link->last_connect_tstamp_nsec != 0)
+                strftime(last_connect_tstamp_buf, sizeof(last_connect_tstamp_buf), "%F %T", localtime_r(&last_connect_tstamp, &buf));
+            else
+                STRSCPY(last_connect_tstamp_buf, "(nil)");
+
+            if (link->last_probe_req_tstamp_nsec != 0)
+                strftime(last_probe_req_tstamp_buf, sizeof(last_probe_req_tstamp_buf), "%F %T", localtime_r(&last_probe_req_tstamp, &buf));
+            else
+                STRSCPY(last_probe_req_tstamp_buf, "(nil)");
+
+            LOGI("osw: sta_cache:       link: vif: %s", link->vif_name.buf);
+            LOGI("osw: sta_cache:         connected: %s", link->connected == true ? "true" : "false");
+            LOGI("osw: sta_cache:         assoc_req_ies: (%s)", link->assoc_req_ies != NULL ? "present" : "nil");
+            LOGI("osw: sta_cache:         assoc_req_ies_len: %zu", link->assoc_req_ies_len);
+            LOGI("osw: sta_cache:         last_connect_tstamp: %s", last_connect_tstamp_buf);
+            LOGI("osw: sta_cache:         last_probe_req_tstamp: %s", last_probe_req_tstamp_buf);
+        }
+    }
+}
+
+static void
+osw_sta_cache_sigusr1_cb(EV_P_ ev_signal *arg,
+                         int events)
+{
+    struct osw_sta_cache *sta_cache = container_of(arg, struct osw_sta_cache, sigusr1);
+    osw_sta_cache_dump(sta_cache);
+}
+
+static struct osw_sta_cache g_sta_cache = {
+    .state_obs = {
+        .name = "osw_sta_cache",
+        .vif_removed_fn = osw_sta_cache_vif_removed_cb,
+        .vif_changed_fn = osw_sta_cache_vif_changed_cb,
+        .vif_probe_req_fn = osw_sta_cache_vif_probe_req_cb,
+        .sta_connected_fn = osw_sta_cache_sta_connected_cb,
+        .sta_disconnected_fn = osw_sta_cache_sta_disconnected_cb,
+    },
+    .observer_list = DS_DLIST_INIT(struct osw_sta_cache_observer, node),
+    .sta_tree = DS_TREE_INIT((ds_key_cmp_t*) osw_hwaddr_cmp, struct osw_sta, node),
+};
+
+static void
+osw_sta_cache_init_priv(struct osw_sta_cache *cache)
+{
+    osw_state_register_observer(&cache->state_obs);
+    ev_signal_init(&cache->sigusr1, osw_sta_cache_sigusr1_cb, SIGUSR1);
+    ev_signal_start(EV_DEFAULT_ &cache->sigusr1);
+    ev_unref(EV_DEFAULT);
+}
+
+static void
+osw_sta_cache_init(void)
+{
+    osw_sta_cache_init_priv(&g_sta_cache);
+}
+
+void
+osw_sta_cache_register_observer(struct osw_sta_cache_observer *observer)
+{
+    ASSERT(observer != NULL, "");
+
+    struct osw_sta* sta;
+    struct osw_sta_cache *cache = &g_sta_cache;
+
+    ds_dlist_insert_tail(&cache->observer_list, observer);
+    if (observer->appeared_fn == NULL)
+        return;
+
+    ds_tree_foreach(&cache->sta_tree, sta)
+        observer->appeared_fn(observer, sta);
+}
+
+void
+osw_sta_cache_unregister_observer(struct osw_sta_cache_observer *observer)
+{
+    ASSERT(observer != NULL, "");
+    struct osw_sta_cache *cache = &g_sta_cache;
+    ds_dlist_remove(&cache->observer_list, observer);
+}
+
+struct osw_sta*
+osw_sta_cache_lookup_sta(const struct osw_hwaddr *sta_addr)
+{
+    ASSERT(sta_addr != NULL, "");
+    struct osw_sta_cache *cache = &g_sta_cache;
+    return ds_tree_find(&cache->sta_tree, sta_addr);
+}
+
+void
+osw_sta_register_observer(struct osw_sta *sta,
+                          struct osw_sta_observer *observer)
+{
+    ASSERT(sta != NULL, "");
+    ASSERT(observer != NULL, "");
+
+    struct osw_sta_link *link;
+
+    ds_dlist_insert_tail(&sta->observer_list, observer);
+    if (observer->connected_fn == NULL)
+        return;
+
+    ds_tree_foreach(&sta->link_tree, link)
+        if (link->connected == true)
+            observer->connected_fn(observer, sta, link);
+}
+
+void
+osw_sta_unregister_observer(struct osw_sta *sta,
+                            struct osw_sta_observer *observer)
+{
+    ASSERT(sta != NULL, "");
+    ASSERT(observer != NULL, "");
+
+    ds_dlist_remove(&sta->observer_list, observer);
+}
+
+const struct osw_hwaddr*
+osw_sta_get_mac_addr(const struct osw_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return &sta->mac_addr;
+}
+
+const struct osw_state_vif_info*
+osw_sta_link_get_vif_info(const struct osw_sta_link *link)
+{
+    ASSERT(link != NULL, "");
+    return link->vif;
+}
+
+struct osw_sta_cache_ut_lifecycle_sta_cnt {
+    unsigned int appeared_cnt;
+    unsigned int vanished_cnt;
+    unsigned int connected_cnt;
+    unsigned int disconnected_cnt;
+    unsigned int probe_req_cnt;
+};
+
+struct osw_sta_cache_ut_lifecycle_ctx {
+    const struct osw_hwaddr sta_addr_a;
+    const struct osw_hwaddr sta_addr_b;
+
+    struct osw_drv_vif_state drv_vif_state_0;
+    struct osw_state_vif_info vif_0;
+    struct osw_drv_vif_state drv_vif_state_1;
+    struct osw_state_vif_info vif_1;
+
+    struct osw_state_sta_info sta_info_a;
+    struct osw_state_sta_info sta_info_b;
+
+    struct osw_sta_cache_observer sta_cache_observer;
+    struct osw_sta_observer sta_a_observer;
+    struct osw_sta_observer sta_b_observer;
+
+    struct osw_drv_report_vif_probe_req sta_b_probe_req;
+
+    struct osw_sta_cache_ut_lifecycle_sta_cnt sta_a_cnt;
+    struct osw_sta_cache_ut_lifecycle_sta_cnt sta_b_cnt;
+};
+
+static void
+osw_sta_cache_ut_lifecycle_sta_appeared_cb(struct osw_sta_cache_observer *self,
+                                           struct osw_sta *sta)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_cache_observer);
+
+    if (osw_hwaddr_cmp(osw_sta_get_mac_addr(sta), &ctx->sta_addr_a) == 0) {
+        ctx->sta_a_cnt.appeared_cnt++;
+        osw_sta_register_observer(sta, &ctx->sta_a_observer);
+    }
+    else if (osw_hwaddr_cmp(osw_sta_get_mac_addr(sta), &ctx->sta_addr_b) == 0) {
+        ctx->sta_b_cnt.appeared_cnt++;
+        osw_sta_register_observer(sta, &ctx->sta_b_observer);
+    }
+    else {
+        assert(false);
+    }
+}
+
+static void
+osw_sta_cache_ut_lifecycle_sta_vanished_cb(struct osw_sta_cache_observer *self,
+                                           struct osw_sta *sta)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_cache_observer);
+
+    assert(osw_sta_get_mac_addr(sta) != NULL);
+    
+    if (osw_hwaddr_cmp(osw_sta_get_mac_addr(sta), &ctx->sta_addr_a) == 0) {
+        ctx->sta_a_cnt.vanished_cnt++;
+        osw_sta_register_observer(sta, &ctx->sta_a_observer);
+    }
+    else if (osw_hwaddr_cmp(osw_sta_get_mac_addr(sta), &ctx->sta_addr_b) == 0) {
+        ctx->sta_b_cnt.vanished_cnt++;
+        osw_sta_register_observer(sta, &ctx->sta_b_observer);
+    }
+    else {
+        assert(false);
+    }
+}
+
+static void
+osw_sta_cache_ut_lifecycle_sta_a_connected_cb(struct osw_sta_observer *self,
+                                              struct osw_sta *sta,
+                                              const struct osw_sta_link *link)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_a_observer);
+    ctx->sta_a_cnt.connected_cnt++;
+}
+
+static void
+osw_sta_cache_ut_lifecycle_sta_a_disconnected_cb(struct osw_sta_observer *self,
+                                                 struct osw_sta *sta,
+                                                 const struct osw_sta_link *link)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_a_observer);
+    ctx->sta_a_cnt.disconnected_cnt++;
+}
+
+static void
+osw_sta_cache_ut_lifecycle_sta_a_probe_req_cb(struct osw_sta_observer *self,
+                                              struct osw_sta *sta,
+                                              const struct osw_sta_link *link,
+                                              const struct osw_drv_report_vif_probe_req *probe_req)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_b_observer);
+    ctx->sta_a_cnt.probe_req_cnt++;
+}
+
+static void
+osw_sta_cache_ut_lifecycle_sta_b_connected_cb(struct osw_sta_observer *self,
+                                              struct osw_sta *sta,
+                                              const struct osw_sta_link *link)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_b_observer);
+    ctx->sta_b_cnt.connected_cnt++;
+}
+
+static void
+osw_sta_cache_ut_lifecycle_sta_b_disconnected_cb(struct osw_sta_observer *self,
+                                                 struct osw_sta *sta,
+                                                 const struct osw_sta_link *link)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_b_observer);
+    ctx->sta_b_cnt.disconnected_cnt++;
+}
+
+static void
+osw_sta_cache_ut_lifecycle_sta_b_probe_req_cb(struct osw_sta_observer *self,
+                                              struct osw_sta *sta,
+                                              const struct osw_sta_link *link,
+                                              const struct osw_drv_report_vif_probe_req *probe_req)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = container_of(self, struct osw_sta_cache_ut_lifecycle_ctx, sta_b_observer);
+    ctx->sta_b_cnt.probe_req_cnt++;
+}
+
+static struct osw_sta_cache_ut_lifecycle_ctx*
+osw_sta_cache_ut_lifecycle_ctx_get(void)
+{
+    static struct osw_sta_cache_ut_lifecycle_ctx ctx = {
+        .sta_addr_a = { .octet = { 0xAA, }, },
+        .sta_addr_b = { .octet = { 0xBB, }, },
+
+        .drv_vif_state_0 = {
+            .mac_addr = { .octet = { 0xCC, }, },
+        },
+        .vif_0 = {
+            .vif_name = "vif_0",
+            .drv_state = &ctx.drv_vif_state_0,
+        },
+        .drv_vif_state_1 = {
+            .mac_addr = { .octet = { 0xDD, }, },
+        },
+        .vif_1 = {
+            .vif_name = "vif_1",
+            .drv_state = &ctx.drv_vif_state_1,
+        },
+
+        .sta_info_a = {
+            .mac_addr = &ctx.sta_addr_a,
+            .vif = &ctx.vif_0,
+        },
+        .sta_info_b = {
+            .mac_addr = &ctx.sta_addr_b,
+            .vif = &ctx.vif_1,
+        },
+
+        .sta_b_probe_req = {
+            .sta_addr = { .octet = { 0xBB, }, },
+        },
+
+        .sta_cache_observer = {
+            .name = "osw_sta_cache_ut",
+            .appeared_fn = osw_sta_cache_ut_lifecycle_sta_appeared_cb,
+            .vanished_fn = osw_sta_cache_ut_lifecycle_sta_vanished_cb,
+        },
+        .sta_a_observer = {
+            .name = "osw_sta_cache_ut_sta_a",
+            .connected_fn = osw_sta_cache_ut_lifecycle_sta_a_connected_cb,
+            .disconnected_fn = osw_sta_cache_ut_lifecycle_sta_a_disconnected_cb,
+            .probe_req_fn = osw_sta_cache_ut_lifecycle_sta_a_probe_req_cb,
+        },
+        .sta_b_observer = {
+            .name = "osw_sta_cache_ut_sta_b",
+            .connected_fn = osw_sta_cache_ut_lifecycle_sta_b_connected_cb,
+            .disconnected_fn = osw_sta_cache_ut_lifecycle_sta_b_disconnected_cb,
+            .probe_req_fn = osw_sta_cache_ut_lifecycle_sta_b_probe_req_cb,
+        },
+    };
+
+    return &ctx;
+}
+
+OSW_UT(osw_sta_cache_ut_lifecycle)
+{
+    struct osw_sta_cache_ut_lifecycle_ctx *ctx = osw_sta_cache_ut_lifecycle_ctx_get();
+
+    osw_ut_time_init();
+    osw_sta_cache_init();
+
+    /* STA A connects before registering sta_cache observer */
+    g_sta_cache.state_obs.sta_connected_fn(&g_sta_cache.state_obs, &ctx->sta_info_a);
+
+    osw_sta_cache_register_observer(&ctx->sta_cache_observer);
+    assert(ctx->sta_a_cnt.appeared_cnt == 1);
+    assert(ctx->sta_a_cnt.vanished_cnt == 0);
+    assert(ctx->sta_a_cnt.connected_cnt == 1);
+    assert(ctx->sta_a_cnt.disconnected_cnt == 0);
+    assert(ctx->sta_a_cnt.probe_req_cnt == 0);
+
+    /* STA B probes (wildcard) */
+    g_sta_cache.state_obs.vif_probe_req_fn(&g_sta_cache.state_obs, &ctx->vif_0, &ctx->sta_b_probe_req);
+    g_sta_cache.state_obs.vif_probe_req_fn(&g_sta_cache.state_obs, &ctx->vif_1, &ctx->sta_b_probe_req);
+    assert(ctx->sta_b_cnt.appeared_cnt == 1);
+    assert(ctx->sta_b_cnt.vanished_cnt == 0);
+    assert(ctx->sta_b_cnt.connected_cnt == 0);
+    assert(ctx->sta_b_cnt.disconnected_cnt == 0);
+    assert(ctx->sta_b_cnt.probe_req_cnt == 2);
+
+    /* STA B connects */
+    g_sta_cache.state_obs.sta_connected_fn(&g_sta_cache.state_obs, &ctx->sta_info_b);
+    assert(ctx->sta_b_cnt.appeared_cnt == 1);
+    assert(ctx->sta_b_cnt.vanished_cnt == 0);
+    assert(ctx->sta_b_cnt.connected_cnt == 1);
+    assert(ctx->sta_b_cnt.disconnected_cnt == 0);
+    assert(ctx->sta_b_cnt.probe_req_cnt == 2);
+
+    /* Both STAs disconnect */
+    g_sta_cache.state_obs.sta_disconnected_fn(&g_sta_cache.state_obs, &ctx->sta_info_a);
+    assert(ctx->sta_a_cnt.appeared_cnt == 1);
+    assert(ctx->sta_a_cnt.vanished_cnt == 0);
+    assert(ctx->sta_a_cnt.connected_cnt == 1);
+    assert(ctx->sta_a_cnt.disconnected_cnt == 1);
+    assert(ctx->sta_a_cnt.probe_req_cnt == 0);
+
+    g_sta_cache.state_obs.sta_disconnected_fn(&g_sta_cache.state_obs, &ctx->sta_info_b);
+    assert(ctx->sta_b_cnt.appeared_cnt == 1);
+    assert(ctx->sta_b_cnt.vanished_cnt == 0);
+    assert(ctx->sta_b_cnt.connected_cnt == 1);
+    assert(ctx->sta_b_cnt.disconnected_cnt == 1);
+    assert(ctx->sta_b_cnt.probe_req_cnt == 2);
+
+    /* Wait until both STAs will vanish */
+    osw_ut_time_advance(OSW_TIME_SEC(60));
+
+    assert(ctx->sta_a_cnt.appeared_cnt == 1);
+    assert(ctx->sta_a_cnt.vanished_cnt == 1);
+    assert(ctx->sta_a_cnt.connected_cnt == 1);
+    assert(ctx->sta_a_cnt.disconnected_cnt == 1);
+    assert(ctx->sta_a_cnt.probe_req_cnt == 0);
+
+    assert(ctx->sta_b_cnt.appeared_cnt == 1);
+    assert(ctx->sta_b_cnt.vanished_cnt == 1);
+    assert(ctx->sta_b_cnt.connected_cnt == 1);
+    assert(ctx->sta_b_cnt.disconnected_cnt == 1);
+    assert(ctx->sta_b_cnt.probe_req_cnt == 2);
+}
+
+OSW_MODULE(osw_sta_cache)
+{
+    OSW_MODULE_LOAD(osw_state);
+    osw_sta_cache_init();
+    return NULL;
+}
Index: core/src/lib/osw/src/osw_sta_i.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_sta_i.h
@@ -0,0 +1,17 @@
+#ifndef OSW_STA_I_H
+#define OSW_STA_I_H
+
+struct osw_sta_cache;
+
+struct osw_sta {
+    struct osw_sta_cache *cache;
+    struct osw_hwaddr mac_addr;
+    struct ds_tree link_tree;
+    struct ds_dlist observer_list;
+
+    struct osw_timer gc;
+
+    struct ds_tree_node node;
+};
+
+#endif /* OSW_STA_I_H */
Index: core/src/lib/osw/src/osw_sta_link_i.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_sta_link_i.h
@@ -0,0 +1,18 @@
+#ifndef OSW_STA_LINK_I_H
+#define OSW_STA_LINK_I_H
+
+struct osw_sta_link {
+    struct osw_ifname vif_name;
+    const struct osw_state_vif_info *vif;
+
+    bool connected;
+    void *assoc_req_ies;
+    size_t assoc_req_ies_len;
+
+    uint64_t last_connect_tstamp_nsec;
+    uint64_t last_probe_req_tstamp_nsec;
+
+    struct ds_tree_node node;
+};
+
+#endif /* OSW_STA_LINK_I_H */
Index: core/src/lib/osw/src/osw_state.c
===================================================================
--- core.orig/src/lib/osw/src/osw_state.c
+++ core/src/lib/osw/src/osw_state.c
@@ -3,15 +3,16 @@
 #include <os.h>
 #include <memutil.h>
 #include <osw_state.h>
+#include <osw_module.h>
 #include "osw_state_i.h"
 #include "osw_drv_i.h"
 
 struct ds_dlist g_osw_state_observer_list = DS_DLIST_INIT(struct osw_state_observer, node);
 
 #define osw_log_state_observer_register(o) \
-    LOGI("osw: state: registering observer: name=%s", o->name)
+    LOGD("osw: state: registering observer: name=%s", o->name)
 #define osw_log_state_observer_unregister(o) \
-    LOGI("osw: state: unregistering observer: name=%s", o->name)
+    LOGD("osw: state: unregistering observer: name=%s", o->name)
 
 static void
 osw_state_observer_notify_add(struct osw_state_observer *observer)
@@ -58,8 +59,17 @@ osw_state_observer_notify_remove(struct
 
     ds_tree_foreach(&g_osw_drv_tree, drv) {
         ds_tree_foreach(&drv->phy_tree, phy) {
+            if (phy->cur_state.exists == false)
+                continue;
+
             ds_tree_foreach(&phy->vif_tree, vif) {
+                if (vif->cur_state.exists == false)
+                    continue;
+
                 ds_tree_foreach(&vif->sta_tree, sta) {
+                    if (sta->cur_state.connected == false)
+                        continue;
+
                     if (observer->sta_disconnected_fn != NULL)
                         observer->sta_disconnected_fn(observer, &sta->pub);
                 }
@@ -133,6 +143,42 @@ osw_state_vif_lookup(const char *phy_nam
     return NULL;
 }
 
+const struct osw_state_vif_info *
+osw_state_vif_lookup_by_mac_addr(const struct osw_hwaddr *mac_addr)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+
+    /* TODO This may be optimized by introducing global (mac addr, vif) tree. */
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        ds_tree_foreach(&drv->phy_tree, phy)
+            if (phy->cur_state.exists == true)
+                ds_tree_foreach(&phy->vif_tree, vif)
+                    if (vif->cur_state.exists == true)
+                        if (osw_hwaddr_cmp(&vif->cur_state.mac_addr, mac_addr) == 0)
+                            return &vif->pub;
+
+    return NULL;
+}
+
+const struct osw_state_vif_info *
+osw_state_vif_lookup_by_vif_name(const char *vif_name)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        ds_tree_foreach(&drv->phy_tree, phy)
+            if (phy->cur_state.exists == true)
+                if ((vif = ds_tree_find(&phy->vif_tree, vif_name)) != NULL)
+                    if (vif->cur_state.exists == true)
+                        return &vif->pub;
+
+    return NULL;
+}
+
 const struct osw_state_sta_info *
 osw_state_sta_lookup(const char *phy_name,
                      const char *vif_name,
@@ -252,3 +298,9 @@ osw_state_sta_get_list(osw_state_report_
             osw_state_sta_get_list_on_phy(fn, phy, vif_name, priv);
     }
 }
+
+OSW_MODULE(osw_state)
+{
+    OSW_MODULE_LOAD(osw_drv);
+    return NULL;
+}
Index: core/src/lib/osw/src/osw_state_i.h
===================================================================
--- core.orig/src/lib/osw/src/osw_state_i.h
+++ core/src/lib/osw/src/osw_state_i.h
@@ -1,5 +1,5 @@
-#ifndef OSW_STATE_I_H
-#define OSW_STATE_I_H
+#ifndef OSW_STATE_I_H_INCLUDED
+#define OSW_STATE_I_H_INCLUDED
 
 #include <osw_state.h>
 #include <ds_dlist.h>
@@ -14,4 +14,4 @@
 
 extern struct ds_dlist g_osw_state_observer_list;
 
-#endif
+#endif /* OSW_STATE_I_H_INCLUDED */
Index: core/src/lib/osw/src/osw_stats.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_stats.c
@@ -0,0 +1,655 @@
+#include <math.h>
+
+/* opensync */
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <stdbool.h>
+#include <memutil.h>
+#include <const.h>
+#include <os_time.h>
+#include <log.h>
+
+/* osw */
+#include <osw_tlv.h>
+#include <osw_tlv_merge.h>
+#include <osw_sampler.h>
+#include <osw_stats.h>
+#include <osw_stats_subscriber.h>
+#include <osw_stats_defs.h>
+#include <osw_util.h>
+#include <osw_module.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_mux.h>
+
+// FIXME: Add denial of service detection/prevention against number of buckets per subscriber.
+
+/* If a bucket is not filled within N sampling
+ * periods then it should be freed up.
+ */
+#define OSW_STATS_BUCKET_EXPIRE_AFTER_N_PERIODS 30
+
+static void
+set_enum_bit(unsigned long *mask, int i, bool set)
+{
+    const unsigned long bit = (1 << i);
+    *mask &= ~bit;
+    if (set == true) *mask |= bit;
+}
+
+static int
+osw_stats_double_cmp(const void *a, const void *b)
+{
+    const double *x = a;
+    const double *y = b;
+    if (*x < *y) return -1;
+    else if (*x > *y) return 1;
+    else return 0;
+}
+
+struct osw_stats_bucket {
+    struct ds_tree_node node;
+    struct osw_tlv key;
+    struct osw_tlv data;
+    struct osw_tlv last;
+    unsigned int idle_periods;
+};
+
+struct osw_stats_poller {
+    struct ds_tree_node node;
+    struct ds_dlist subscribers;
+    struct osw_sampler sampler;
+    double seconds;
+};
+
+struct osw_stats_subscriber {
+    struct ds_dlist_node node;
+    struct ds_dlist_node poll_node;
+    struct osw_stats *stats;
+    struct osw_stats_poller *poller;
+    struct ds_tree buckets[OSW_STATS_MAX__];
+    double report_at;
+    double report_seconds;
+    double poll_seconds;
+    unsigned long stats_mask;
+    osw_stats_subscriber_report_fn_t *report_fn;
+    void *report_priv;
+};
+
+struct osw_stats {
+    struct ds_dlist subscribers;
+    struct ds_tree pollers;
+    struct osw_timer work;
+};
+
+/* FIXME: This should be stored/allocated in OSW_MODULE().
+ * The last place to untagle this global is osw_stats_put()
+ * and integration against osw_drv core.
+ */
+static struct osw_stats g_osw_stats;
+
+static void
+osw_stats_reschedule(struct osw_stats *stats)
+{
+    if (stats == NULL) return;
+    osw_timer_arm_at_nsec(&stats->work, 0);
+}
+
+static bool
+osw_stats_bucket_is_expired(struct osw_stats_bucket *b)
+{
+    return b->idle_periods >= OSW_STATS_BUCKET_EXPIRE_AFTER_N_PERIODS;
+}
+
+static void
+osw_stats_bucket_expire_work(struct osw_stats_bucket *b)
+{
+    if (b->data.used > 0) {
+        b->idle_periods = 0;
+    }
+    else {
+        b->idle_periods++;
+    }
+}
+
+static void
+osw_stats_bucket_free(struct ds_tree *buckets, struct osw_stats_bucket *b)
+{
+    if (b == NULL) return;
+    if (buckets != NULL) ds_tree_remove(buckets, b);
+    osw_tlv_fini(&b->key);
+    osw_tlv_fini(&b->data);
+    osw_tlv_fini(&b->last);
+    FREE(b);
+}
+
+static bool
+osw_stats_first_to_bool(const bool inherited,
+                        const enum osw_tlv_merge_first_policy f)
+{
+    switch (f) {
+        case OSW_TLV_INHERIT_FIRST: return inherited;
+        case OSW_TLV_DELTA_AGAINST_ZERO: return true;
+        case OSW_TLV_TWO_SAMPLES_MINIMUM: return false;
+    }
+    assert(0);
+    return true;
+}
+
+static void
+osw_stats_subscriber_put(struct osw_stats_subscriber *sub,
+                         const enum osw_stats_id id,
+                         const struct osw_stats_defs *defs,
+                         const struct osw_tlv *key,
+                         const void *data,
+                         const size_t len)
+{
+    const int bit = 1 << id;
+    if ((sub->stats_mask & bit) == 0) return;
+
+    struct ds_tree *tree = &sub->buckets[id];
+    struct osw_stats_bucket *bucket = ds_tree_find(tree, key);
+    const bool first = osw_stats_first_to_bool(true, defs->first);
+
+    if (bucket == NULL) {
+        bucket = CALLOC(1, sizeof(*bucket));
+        osw_tlv_copy(&bucket->key, key);
+        ds_tree_insert(tree, bucket, &bucket->key);
+    }
+
+    osw_tlv_merge(&bucket->data,
+                  &bucket->last,
+                  data, len,
+                  first,
+                  defs->tpolicy,
+                  defs->mpolicy,
+                  defs->size);
+}
+
+void
+osw_stats_subscriber_flush(struct osw_stats_subscriber *sub)
+{
+    const size_t n = ARRAY_SIZE(sub->buckets);
+    size_t i;
+
+    /* FIXME: Before running this loop (and calling
+     * report_fn) it would be useful to run a set of sanity,
+     * and fixup operations. For example if OSW_STATS_CHAN
+     * buckets are present, and they have NOISE_FLOOR_DBM
+     * defined, then it could be used to synthesize RSSI_DBM
+     * in OSW_STATS_BSS_SCAN buckets that provided only
+     * SNR_DB, such that the consumer (report_fn) can get
+     * more data, even if the underlying (raw) reports were
+     * incomplete and would require aggregating. IOW This
+     * could offload the fixup phase to here, instead of
+     * per-subscriber.
+     */
+
+    for (i = 0; i < n; i++) {
+        const enum osw_stats_id id = i;
+        const struct osw_stats_defs *defs = osw_stats_defs_lookup(id);
+        struct ds_tree *buckets = &sub->buckets[i];
+        struct osw_stats_bucket *b;
+        struct osw_stats_bucket *tmp;
+
+        ds_tree_foreach_safe(buckets, b, tmp) {
+            osw_stats_bucket_expire_work(b);
+            if (osw_stats_bucket_is_expired(b) == true) {
+                osw_stats_bucket_free(buckets, b);
+                continue;
+            }
+
+            if (b->data.used == 0) {
+                continue;
+            }
+
+            if (sub->report_fn != NULL) {
+                if (defs != NULL &&
+                    defs->postprocess_fn != NULL) {
+                    defs->postprocess_fn(&b->data);
+                }
+                sub->report_fn(id, &b->data, &b->last, sub->report_priv);
+            }
+
+            osw_tlv_reset(&b->data);
+        }
+    }
+}
+
+static void
+osw_stats_subscriber_free_buckets(struct osw_stats_subscriber *sub)
+{
+    const size_t n = ARRAY_SIZE(sub->buckets);
+    size_t i;
+
+    for (i = 0; i < n; i++) {
+        struct ds_tree *buckets = &sub->buckets[i];
+        struct osw_stats_bucket *tmp;
+        struct osw_stats_bucket *b;
+
+        ds_tree_foreach_safe(buckets, b, tmp) {
+            osw_stats_bucket_free(buckets, b);
+        }
+    }
+}
+
+static int
+memcmp_safe(const void *a, const void *b, size_t alen, size_t blen)
+{
+    int r = memcmp(a, b, alen > blen ? blen : alen);
+    if (alen == blen) return r;
+    if (r != 0) return r;
+    if (alen > blen) return 1;
+    if (blen > alen) return -1;
+    return 0;
+}
+
+static int
+osw_tlv_cmp_cb(const void *a, const void *b)
+{
+    const struct osw_tlv *x = a;
+    const struct osw_tlv *y = b;
+    return memcmp_safe(x->data, y->data, x->used, y->used);
+}
+
+struct osw_stats_subscriber *
+osw_stats_subscriber_alloc(void)
+{
+    struct osw_stats_subscriber *sub = CALLOC(1, sizeof(*sub));
+    size_t i;
+    for (i = 0; i < ARRAY_SIZE(sub->buckets); i++) {
+        ds_tree_init(&sub->buckets[i],
+                     osw_tlv_cmp_cb,
+                     struct osw_stats_bucket,
+                     node);
+    }
+    return sub;
+}
+
+void
+osw_stats_subscriber_free(struct osw_stats_subscriber *sub)
+{
+    if (sub == NULL) return;
+    assert(sub->stats == NULL);
+    assert(sub->poller == NULL);
+    osw_stats_subscriber_free_buckets(sub);
+    FREE(sub);
+}
+
+void
+osw_stats_subscriber_set_report_fn(struct osw_stats_subscriber *sub,
+                                   osw_stats_subscriber_report_fn_t *fn,
+                                   void *priv)
+{
+    sub->report_fn = fn;
+    sub->report_priv = priv;
+    osw_stats_reschedule(sub->stats);
+}
+
+void
+osw_stats_subscriber_set_report_seconds(struct osw_stats_subscriber *sub,
+                                        double seconds)
+{
+    sub->report_seconds = seconds;
+    osw_stats_reschedule(sub->stats);
+}
+
+void
+osw_stats_subscriber_set_poll_seconds(struct osw_stats_subscriber *sub,
+                                      double seconds)
+{
+    sub->poll_seconds = seconds;
+    osw_stats_reschedule(sub->stats);
+}
+
+void
+osw_stats_subscriber_set_phy(struct osw_stats_subscriber *sub,
+                             bool enabled)
+{
+    set_enum_bit(&sub->stats_mask, OSW_STATS_PHY, enabled);
+    osw_stats_reschedule(sub->stats);
+}
+
+void
+osw_stats_subscriber_set_vif(struct osw_stats_subscriber *sub,
+                             bool enabled)
+{
+    set_enum_bit(&sub->stats_mask, OSW_STATS_VIF, enabled);
+    osw_stats_reschedule(sub->stats);
+}
+
+void
+osw_stats_subscriber_set_sta(struct osw_stats_subscriber *sub,
+                             bool enabled)
+{
+    set_enum_bit(&sub->stats_mask, OSW_STATS_STA, enabled);
+    osw_stats_reschedule(sub->stats);
+}
+
+void
+osw_stats_subscriber_set_chan(struct osw_stats_subscriber *sub,
+                              bool enabled)
+{
+    set_enum_bit(&sub->stats_mask, OSW_STATS_CHAN, enabled);
+    osw_stats_reschedule(sub->stats);
+}
+
+void
+osw_stats_subscriber_set_bss(struct osw_stats_subscriber *sub,
+                              bool enabled)
+{
+    set_enum_bit(&sub->stats_mask, OSW_STATS_BSS_SCAN, enabled);
+    osw_stats_reschedule(sub->stats);
+}
+
+static void
+osw_stats_run_subscribers(struct osw_stats *stats,
+                          const double now,
+                          bool *poll,
+                          double *remaining_seconds)
+{
+    struct osw_stats_subscriber *sub;
+    struct osw_stats_subscriber *ts;
+    struct osw_stats_poller *p;
+    struct osw_stats_poller *tp;
+
+    ds_dlist_foreach(&stats->subscribers, sub) {
+        p = sub->poller;
+        if (p != NULL && p->seconds != sub->poll_seconds) {
+            ds_dlist_remove(&p->subscribers, sub);
+            sub->poller = NULL;
+            p = NULL;
+        }
+        if (p == NULL && sub->poll_seconds > 0) {
+            p = ds_tree_find(&stats->pollers, &sub->poll_seconds);
+            if (p == NULL) {
+                p = CALLOC(1, sizeof(*p));
+                ds_dlist_init(&p->subscribers, struct osw_stats_subscriber, poll_node);
+                p->seconds = sub->poll_seconds;
+                osw_sampler_set_period_seconds(&p->sampler, p->seconds);
+                osw_sampler_start_at(&p->sampler, now);
+                ds_tree_insert(&stats->pollers, p, &p->seconds);
+            }
+        }
+        if (sub->poller == NULL && p != NULL) {
+            ds_dlist_insert_tail(&p->subscribers, sub);
+        }
+        sub->poller = p;
+    }
+
+    *poll = false;
+    ds_tree_foreach_safe(&stats->pollers, p, tp) {
+        if (ds_dlist_is_empty(&p->subscribers) == true) {
+            ds_tree_remove(&stats->pollers, p);
+            FREE(p);
+            continue;
+        }
+
+        struct osw_sampler *s = &p->sampler;
+        const int ticks = osw_sampler_run(s, now);
+        if (ticks > 0) *poll = true;
+
+        const double r = osw_sampler_get_remaining_seconds(s, now);
+        osw_min_duration(remaining_seconds, r);
+    }
+
+    ds_dlist_foreach_safe(&stats->subscribers, sub, ts) {
+        const bool expired = osw_periodic_eval(&sub->report_at, sub->report_seconds, 0, now);
+        if (expired == true) {
+            osw_stats_subscriber_flush(sub);
+        }
+
+        if (sub->report_at == 0) {
+            continue;
+        }
+
+        const double r = sub->report_at - now;
+        osw_min_duration(remaining_seconds, r);
+    }
+}
+
+void
+osw_stats_run(bool *poll,
+              double *remaining_seconds,
+              const double now)
+{
+    osw_stats_run_subscribers(&g_osw_stats, now, poll, remaining_seconds);
+}
+
+static void
+osw_stats_register_subscriber__(struct osw_stats *stats,
+                                struct osw_stats_subscriber *sub)
+{
+    assert(sub->stats == NULL);
+    ds_dlist_insert_tail(&stats->subscribers, sub);
+    sub->stats = stats;
+    osw_stats_reschedule(stats);
+}
+
+void
+osw_stats_register_subscriber(struct osw_stats_subscriber *sub)
+{
+    return osw_stats_register_subscriber__(&g_osw_stats, sub);
+}
+
+void
+osw_stats_unregister_subscriber(struct osw_stats_subscriber *sub)
+{
+    struct osw_stats *stats = sub->stats;
+    struct osw_stats_poller *p = sub->poller;
+    assert(stats != NULL);
+    if (p != NULL) {
+        ds_dlist_remove(&p->subscribers, sub);
+        sub->poller = NULL;
+    }
+    ds_dlist_remove(&stats->subscribers, sub);
+    osw_stats_reschedule(stats);
+    sub->stats = NULL;
+}
+
+static bool
+osw_stats_put_key_chan(struct osw_tlv *key,
+                       const struct osw_stats_defs *defs,
+                       const struct osw_tlv_hdr **tb)
+{
+    const struct osw_tlv_hdr *phy_name = tb[OSW_STATS_CHAN_PHY_NAME];
+    const struct osw_tlv_hdr *freq_mhz = tb[OSW_STATS_CHAN_FREQ_MHZ];
+
+    if (phy_name == NULL) return false;
+    if (freq_mhz == NULL) return false;
+
+    osw_tlv_put_copy(key, phy_name);
+    osw_tlv_put_copy(key, freq_mhz);
+    return true;
+}
+
+static bool
+osw_stats_put_key_bss_scan(struct osw_tlv *key,
+                           const struct osw_stats_defs *defs,
+                           const struct osw_tlv_hdr **tb)
+{
+    const struct osw_tlv_hdr *phy_name = tb[OSW_STATS_BSS_SCAN_PHY_NAME];
+    const struct osw_tlv_hdr *bssid = tb[OSW_STATS_BSS_SCAN_MAC_ADDRESS];
+
+    if (phy_name == NULL) return false;
+    if (bssid == NULL) return false;
+
+    osw_tlv_put_copy(key, phy_name);
+    osw_tlv_put_copy(key, bssid);
+    return true;
+}
+
+static bool
+osw_stats_put_key_sta(struct osw_tlv *key,
+                      const struct osw_stats_defs *defs,
+                      const struct osw_tlv_hdr **tb)
+{
+    const struct osw_tlv_hdr *phy_name = tb[OSW_STATS_STA_PHY_NAME];
+    const struct osw_tlv_hdr *vif_name = tb[OSW_STATS_STA_VIF_NAME];
+    const struct osw_tlv_hdr *sta_addr = tb[OSW_STATS_STA_MAC_ADDRESS];
+
+    if (phy_name == NULL) return false;
+    if (vif_name == NULL) return false;
+    if (sta_addr == NULL) return false;
+
+    osw_tlv_put_copy(key, phy_name);
+    osw_tlv_put_copy(key, vif_name);
+    osw_tlv_put_copy(key, sta_addr);
+    return true;
+}
+
+static bool
+osw_stats_put_key(struct osw_tlv *key,
+                  const enum osw_stats_id id,
+                  const struct osw_stats_defs *defs,
+                  const struct osw_tlv_hdr **tb)
+{
+    switch (id) {
+        case OSW_STATS_PHY: return false;
+        case OSW_STATS_VIF: return false;
+        case OSW_STATS_STA: return osw_stats_put_key_sta(key, defs, tb);
+        case OSW_STATS_CHAN: return osw_stats_put_key_chan(key, defs, tb);
+        case OSW_STATS_BSS_SCAN: return osw_stats_put_key_bss_scan(key, defs, tb);
+        case OSW_STATS_MAX__: return false;
+    }
+    return false;
+}
+
+static double
+osw_stats_adjust_poll(struct osw_stats *stats,
+                      const double now)
+{
+    struct osw_stats_poller *p;
+    double largest = 0;
+
+    ds_tree_foreach(&stats->pollers, p) {
+        double const error = osw_sampler_adjust(&p->sampler, now);
+        if (fabs(error) > fabs(largest)) largest = error;
+    }
+
+    return largest;
+}
+
+static void
+osw_stats_put_one(struct osw_stats *stats,
+                  const struct osw_tlv_hdr *src)
+{
+    const enum osw_stats_id id = src->id;
+    const struct osw_stats_defs *defs = osw_stats_defs_lookup(id);
+    struct osw_stats_subscriber *sub;
+    struct osw_tlv key = {0};
+    const void *data = osw_tlv_get_data(src);
+    const size_t len = src->len;
+
+    if (defs == NULL) {
+        // FIXME warning
+        return;
+    }
+
+    const size_t size = defs->size;
+    const struct osw_tlv_policy *p = defs->tpolicy;
+    const struct osw_tlv_hdr *tb[size];
+
+    memset(tb, 0, size * sizeof(*tb));
+    const size_t remaining = osw_tlv_parse(data, len, p, tb, size);
+
+    if (remaining != 0) {
+        // FIXME warning
+    }
+
+
+    if (osw_stats_put_key(&key, id, defs, tb) == false) {
+        // FIXME warning
+        return;
+    }
+
+    ds_dlist_foreach(&stats->subscribers, sub) {
+        osw_stats_subscriber_put(sub, id, defs, &key, data, len);
+    }
+
+    osw_tlv_fini(&key);
+}
+
+static void
+osw_stats_put_tlv(struct osw_stats *stats,
+                  const struct osw_tlv *src)
+{
+    const void *ptr = src->data;
+    size_t len = src->used;
+    const struct osw_tlv_hdr *i;
+
+    osw_tlv_for_each(i, ptr, len) {
+        osw_stats_put_one(stats, i);
+    }
+}
+
+/* If any sampler adjusts by more than 5ms then it
+ * may suggest there's something unexpected
+ * happening. Sometimes it's fine - more stations
+ * appear, which changes the amount of time spent
+ * collecting stats, or CPU load changes. In
+ * either case it's a nice-to-have info to be
+ * shown and which shouldn't really show too too
+ * often.
+ */
+#define OSW_STATS_ADJUST_THRESHOLD_INFO 0.005
+
+void
+osw_stats_put(const struct osw_tlv *src)
+{
+    struct osw_stats *stats = &g_osw_stats;
+    const double now = OSW_TIME_TO_DBL(osw_time_mono_clk());
+
+    osw_stats_put_tlv(stats, src);
+
+    /* FIXME: Due to async nature of stats, a single poll
+     * action can generate multiple put calls. To handle
+     * that properly the adjustment should be called after
+     * system reaches idle state again or, the call needs to
+     * be debounced.
+     */
+    const double largest = osw_stats_adjust_poll(stats, now);
+    if (largest >= OSW_STATS_ADJUST_THRESHOLD_INFO) {
+        LOGD("osw: stats: adjustment of %lfseconds", largest);
+    }
+}
+
+static void
+osw_stats_work_cb(struct osw_timer *t)
+{
+    struct osw_stats *stats = container_of(t, struct osw_stats, work);
+    const double now = OSW_TIME_TO_DBL(osw_time_mono_clk());
+    double seconds = -1;
+    bool poll;
+
+    LOGT("osw: stats: running");
+    osw_stats_run(&poll, &seconds, now);
+
+    if (seconds >= 0) {
+        osw_timer_arm_at_nsec(&stats->work, OSW_TIME_SEC(now + seconds));
+    }
+
+    if (poll == true) {
+        LOGT("osw: stats: requesting");
+        osw_mux_request_stats();
+    }
+}
+
+static void
+osw_stats_init(struct osw_stats *stats)
+{
+    ds_dlist_init(&stats->subscribers, struct osw_stats_subscriber, node);
+    ds_tree_init(&stats->pollers, osw_stats_double_cmp, struct osw_stats_poller, node);
+    osw_timer_init(&stats->work, osw_stats_work_cb);
+}
+
+OSW_MODULE(osw_stats)
+{
+    OSW_MODULE_LOAD(osw_timer);
+    OSW_MODULE_LOAD(osw_mux);
+    struct osw_stats *s = &g_osw_stats;
+    osw_stats_init(s);
+    return NULL;
+}
+
+#include "osw_stats_ut.c.h"
Index: core/src/lib/osw/src/osw_stats_defs.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_stats_defs.c
@@ -0,0 +1,18 @@
+#include <osw_stats_defs.h>
+#include "osw_stats_defs_sta.c.h"
+#include "osw_stats_defs_chan.c.h"
+#include "osw_stats_defs_bss_scan.c.h"
+
+const struct osw_stats_defs *
+osw_stats_defs_lookup(enum osw_stats_id stats_id)
+{
+    switch (stats_id) {
+        case OSW_STATS_PHY: return NULL;
+        case OSW_STATS_VIF: return NULL;
+        case OSW_STATS_STA: return &g_osw_stats_defs_sta;
+        case OSW_STATS_CHAN: return &g_osw_stats_defs_chan;
+        case OSW_STATS_BSS_SCAN: return &g_osw_stats_defs_bss_scan;
+        case OSW_STATS_MAX__: return NULL;
+    }
+    return NULL;
+}
Index: core/src/lib/osw/src/osw_stats_defs_bss_scan.c.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_stats_defs_bss_scan.c.h
@@ -0,0 +1,27 @@
+static const struct osw_tlv_policy
+g_osw_stats_tp_bss_scan[OSW_STATS_BSS_SCAN_MAX__] = {
+    [OSW_STATS_BSS_SCAN_PHY_NAME] = { .type = OSW_TLV_STRING },
+    [OSW_STATS_BSS_SCAN_MAC_ADDRESS] = { .type = OSW_TLV_HWADDR },
+    [OSW_STATS_BSS_SCAN_FREQ_MHZ] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_BSS_SCAN_SSID] = { .type = OSW_TLV_UNSPEC },
+    [OSW_STATS_BSS_SCAN_WIDTH_MHZ] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_BSS_SCAN_IES] = { .type = OSW_TLV_UNSPEC },
+    [OSW_STATS_BSS_SCAN_SNR_DB] = { .type = OSW_TLV_U32 },
+};
+
+static const struct osw_tlv_merge_policy
+g_osw_stats_mp_bss_scan[OSW_STATS_BSS_SCAN_MAX__] = {
+    [OSW_STATS_BSS_SCAN_PHY_NAME] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_BSS_SCAN_MAC_ADDRESS] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_BSS_SCAN_FREQ_MHZ] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_BSS_SCAN_SSID] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_BSS_SCAN_IES] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_BSS_SCAN_WIDTH_MHZ] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_BSS_SCAN_SNR_DB] = { .type = OSW_TLV_OP_OVERWRITE },
+};
+
+static const struct osw_stats_defs g_osw_stats_defs_bss_scan = {
+    .tpolicy = g_osw_stats_tp_bss_scan,
+    .mpolicy = g_osw_stats_mp_bss_scan,
+    .size = OSW_STATS_BSS_SCAN_MAX__,
+};
Index: core/src/lib/osw/src/osw_stats_defs_chan.c.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_stats_defs_chan.c.h
@@ -0,0 +1,121 @@
+static const struct osw_tlv_policy
+g_osw_stats_tp_chan_cnt[OSW_STATS_CHAN_CNT_MAX__] = {
+    [OSW_STATS_CHAN_CNT_TX] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_CHAN_CNT_RX] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_CHAN_CNT_RX_INBSS] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_CHAN_CNT_BUSY] = { .type = OSW_TLV_U32 },
+};
+
+static const struct osw_tlv_policy
+g_osw_stats_tp_chan[OSW_STATS_CHAN_MAX__] = {
+    [OSW_STATS_CHAN_PHY_NAME] = { .type = OSW_TLV_STRING },
+    [OSW_STATS_CHAN_FREQ_MHZ] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_CHAN_ACTIVE_MSEC] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_CHAN_CNT_MSEC] = { .type = OSW_TLV_NESTED,
+                                  .tb_size = OSW_STATS_CHAN_CNT_MAX__,
+                                  .nested = g_osw_stats_tp_chan_cnt },
+    [OSW_STATS_CHAN_CNT_PERCENT] = { .type = OSW_TLV_NESTED,
+                                     .tb_size = OSW_STATS_CHAN_CNT_MAX__,
+                                     .nested = g_osw_stats_tp_chan_cnt },
+    [OSW_STATS_CHAN_NOISE_FLOOR_DBM] = { .type = OSW_TLV_FLOAT },
+};
+
+static const struct osw_tlv_merge_policy
+g_osw_stats_mp_chan_cnt_msec[OSW_STATS_CHAN_MAX__] = {
+    [OSW_STATS_CHAN_CNT_TX] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_CHAN_CNT_RX] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_CHAN_CNT_RX_INBSS] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_CHAN_CNT_BUSY] = { .type = OSW_TLV_OP_ACCUMULATE },
+};
+
+static const struct osw_tlv_merge_policy
+g_osw_stats_mp_chan_cnt_percent[OSW_STATS_CHAN_MAX__] = {
+    [OSW_STATS_CHAN_CNT_TX] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_CHAN_CNT_RX] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_CHAN_CNT_RX_INBSS] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_CHAN_CNT_BUSY] = { .type = OSW_TLV_OP_OVERWRITE },
+};
+
+static const struct osw_tlv_merge_policy
+g_osw_stats_mp_chan[OSW_STATS_CHAN_MAX__] = {
+    [OSW_STATS_CHAN_PHY_NAME] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_CHAN_FREQ_MHZ] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_CHAN_ACTIVE_MSEC] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_CHAN_CNT_MSEC] = { .type = OSW_TLV_OP_MERGE,
+                                  .tb_size = OSW_STATS_CHAN_CNT_MAX__,
+                                  .nested = g_osw_stats_mp_chan_cnt_msec },
+    /* FIXME: This would actually benefit
+     * from an average weighted by ACTIVE_MSEC.
+     */
+    [OSW_STATS_CHAN_CNT_PERCENT] = { .type = OSW_TLV_OP_MERGE,
+                                     .tb_size = OSW_STATS_CHAN_CNT_MAX__,
+                                     .nested = g_osw_stats_mp_chan_cnt_percent },
+    [OSW_STATS_CHAN_NOISE_FLOOR_DBM] = { .type = OSW_TLV_OP_OVERWRITE },
+};
+
+static void
+osw_stats_defs_chan_synthesize_percents(struct osw_tlv *data,
+                                        const struct osw_tlv_hdr **tb)
+{
+    /* Don't do it if it's already there */
+    if (tb[OSW_STATS_CHAN_CNT_PERCENT] != NULL) return;
+
+    /* Don't do it if there's no sufficient data */
+    if (tb[OSW_STATS_CHAN_ACTIVE_MSEC] == NULL) return;
+    if (tb[OSW_STATS_CHAN_CNT_MSEC] == NULL) return;
+
+    const struct osw_tlv_hdr *msecs[OSW_STATS_CHAN_CNT_MAX__] = {0};
+    const uint32_t active = osw_tlv_get_u32(tb[OSW_STATS_CHAN_ACTIVE_MSEC]);
+
+    /* 0 duration means divide by 0. Skip sample. */
+    if (active == 0) return;
+
+    const void *cnts = osw_tlv_get_data(tb[OSW_STATS_CHAN_CNT_MSEC]);
+    const size_t len = tb[OSW_STATS_CHAN_CNT_MSEC]->len;
+    const size_t left = osw_tlv_parse(cnts,
+                                      len,
+                                      g_osw_stats_tp_chan_cnt,
+                                      msecs,
+                                      OSW_STATS_CHAN_CNT_MAX__);
+    (void)left;
+    void *start = osw_tlv_put_nested(data, OSW_STATS_CHAN_CNT_PERCENT);
+    {
+        const int ids[] = {
+            OSW_STATS_CHAN_CNT_TX,
+            OSW_STATS_CHAN_CNT_RX,
+            OSW_STATS_CHAN_CNT_RX_INBSS,
+            OSW_STATS_CHAN_CNT_BUSY,
+        };
+        const size_t n = sizeof(ids) / sizeof(ids[0]);
+        size_t i;
+        for (i = 0; i < n; i++) {
+            const struct osw_tlv_hdr *hdr = msecs[ids[i]];
+            if (hdr == NULL) continue;
+            const uint32_t x = osw_tlv_get_u32(hdr);
+            const uint32_t percent = (x * 100) / active;
+            osw_tlv_put_u32(data, ids[i], percent);
+        }
+    }
+    osw_tlv_end_nested(data, start);
+}
+
+static void
+osw_stats_defs_chan_postprocess_cb(struct osw_tlv *data)
+{
+    const struct osw_tlv_hdr *tb[OSW_STATS_CHAN_MAX__] = {0};
+    const size_t left = osw_tlv_parse(data->data,
+                                      data->used,
+                                      g_osw_stats_tp_chan,
+                                      tb,
+                                      OSW_STATS_CHAN_MAX__);
+    (void)left;
+    osw_stats_defs_chan_synthesize_percents(data, tb);
+}
+
+static const struct osw_stats_defs g_osw_stats_defs_chan = {
+    .postprocess_fn = osw_stats_defs_chan_postprocess_cb,
+    .first = OSW_TLV_TWO_SAMPLES_MINIMUM,
+    .tpolicy = g_osw_stats_tp_chan,
+    .mpolicy = g_osw_stats_mp_chan,
+    .size = OSW_STATS_CHAN_MAX__,
+};
Index: core/src/lib/osw/src/osw_stats_defs_sta.c.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_stats_defs_sta.c.h
@@ -0,0 +1,43 @@
+/* FIXME: Use U64 for some of the stats */
+
+static const struct osw_tlv_policy
+g_osw_stats_tp_sta[OSW_STATS_STA_MAX__] = {
+    [OSW_STATS_STA_PHY_NAME] = { .type = OSW_TLV_STRING },
+    [OSW_STATS_STA_VIF_NAME] = { .type = OSW_TLV_STRING },
+    [OSW_STATS_STA_MAC_ADDRESS] = { .type = OSW_TLV_HWADDR },
+    [OSW_STATS_STA_SNR_DB] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_TX_BYTES] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_TX_FRAMES] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_TX_RETRIES] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_TX_ERRORS] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_TX_RATE_MBPS] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_RX_BYTES] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_RX_FRAMES] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_RX_RETRIES] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_RX_ERRORS] = { .type = OSW_TLV_U32 },
+    [OSW_STATS_STA_RX_RATE_MBPS] = { .type = OSW_TLV_U32 },
+};
+
+static const struct osw_tlv_merge_policy
+g_osw_stats_mp_sta[OSW_STATS_STA_MAX__] = {
+    [OSW_STATS_STA_PHY_NAME] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_STA_VIF_NAME] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_STA_MAC_ADDRESS] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_STA_SNR_DB] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_STA_TX_BYTES] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_TX_FRAMES] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_TX_RETRIES] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_TX_ERRORS] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_TX_RATE_MBPS] = { .type = OSW_TLV_OP_OVERWRITE },
+    [OSW_STATS_STA_RX_BYTES] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_RX_FRAMES] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_RX_RETRIES] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_RX_ERRORS] = { .type = OSW_TLV_OP_ACCUMULATE },
+    [OSW_STATS_STA_RX_RATE_MBPS] = { .type = OSW_TLV_OP_OVERWRITE },
+};
+
+static const struct osw_stats_defs g_osw_stats_defs_sta = {
+    .tpolicy = g_osw_stats_tp_sta,
+    .mpolicy = g_osw_stats_mp_sta,
+    .size = OSW_STATS_STA_MAX__,
+};
Index: core/src/lib/osw/src/osw_stats_i.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_stats_i.h
@@ -0,0 +1,9 @@
+#ifndef OSW_STATS_I_H_INCLUDED
+#define OSW_STATS_I_H_INCLUDED
+
+#include <osw_tlv.h>
+
+void
+osw_stats_put(const struct osw_tlv *src);
+
+#endif /* OSW_STATS_I_H_INCLUDED */
Index: core/src/lib/osw/src/osw_stats_ut.c.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_stats_ut.c.h
@@ -0,0 +1,537 @@
+#include <osw_ut.h>
+
+void
+osw_stats_ut_put_chan_cnt(struct osw_tlv *t,
+                          const enum osw_stats_chan_id id,
+                          const uint32_t tx,
+                          const uint32_t rx,
+                          const uint32_t rx_inbss,
+                          const uint32_t busy)
+{
+    void *s = osw_tlv_put_nested(t, id);
+    osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_TX, tx);
+    osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_RX, rx);
+    osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_RX_INBSS, rx_inbss);
+    osw_tlv_put_u32(t, OSW_STATS_CHAN_CNT_BUSY, busy);
+    osw_tlv_end_nested(t, s);
+}
+
+void
+osw_stats_ut_put_chan(struct osw_tlv *t,
+                      const char *phy_name,
+                      const uint32_t freq,
+                      const enum osw_stats_chan_id id,
+                      const uint32_t active,
+                      const uint32_t tx,
+                      const uint32_t rx,
+                      const uint32_t rx_inbss,
+                      const uint32_t busy)
+{
+    void *s = osw_tlv_put_nested(t, OSW_STATS_CHAN);
+    osw_tlv_put_string(t, OSW_STATS_CHAN_PHY_NAME, phy_name);
+    osw_tlv_put_u32(t, OSW_STATS_CHAN_FREQ_MHZ, freq);
+    osw_tlv_put_u32(t, OSW_STATS_CHAN_ACTIVE_MSEC, active);
+    osw_stats_ut_put_chan_cnt(t, id, tx, rx, rx_inbss, busy);
+    osw_tlv_end_nested(t, s);
+}
+
+void
+osw_stats_ut_report_cb(enum osw_stats_id id,
+                       const struct osw_tlv *data,
+                       const struct osw_tlv *last,
+                       void *priv)
+{
+    struct osw_tlv *ret = priv;
+    void *s = osw_tlv_put_nested(ret, id);
+    memcpy(osw_tlv_reserve(ret, data->used), data->data, data->used);
+    osw_tlv_end_nested(ret, s);
+}
+
+static void
+osw_stats_ut_run_expect(struct osw_stats *s,
+                        const double now,
+                        bool idle,
+                        bool poll)
+{
+    bool r_poll = false;
+    double r_seconds = -1;
+    osw_stats_run_subscribers(s, now, &r_poll, &r_seconds);
+    if (idle == true) assert(r_seconds < 0);
+    if (idle == false) assert(r_seconds >= 0);
+    assert(r_poll == poll);
+}
+
+static bool
+osw_stats_ut_tlv_expect_chan(const struct osw_tlv *src,
+                             const char *phy_name,
+                             const uint32_t freq,
+                             const enum osw_stats_chan_id id,
+                             const uint32_t active,
+                             const uint32_t tx,
+                             const uint32_t rx,
+                             const uint32_t rx_inbss,
+                             const uint32_t busy)
+{
+    const struct osw_stats_defs *defs = osw_stats_defs_lookup(OSW_STATS_CHAN);
+    assert(defs != NULL);
+
+    const struct osw_tlv_hdr *i;
+    const void *data = src->data;
+    size_t len = src->used;
+
+    osw_tlv_for_each(i, data, len) {
+        assert(i->id == OSW_STATS_CHAN);
+
+        const struct osw_tlv_hdr *tb[OSW_STATS_CHAN_MAX__] = {0};
+        const size_t left = osw_tlv_parse(osw_tlv_get_data(i), i->len, defs->tpolicy, tb, OSW_STATS_CHAN_MAX__);
+        assert(left == 0);
+
+        assert(tb[OSW_STATS_CHAN_PHY_NAME] != NULL);
+        assert(tb[OSW_STATS_CHAN_FREQ_MHZ] != NULL);
+
+        if (strcmp(osw_tlv_get_string(tb[OSW_STATS_CHAN_PHY_NAME]), phy_name) != 0) continue;
+        if (osw_tlv_get_u32(tb[OSW_STATS_CHAN_FREQ_MHZ]) != freq) continue;
+
+        if (active > 0) {
+            assert(tb[OSW_STATS_CHAN_ACTIVE_MSEC] != NULL);
+            assert(osw_tlv_get_u32(tb[OSW_STATS_CHAN_ACTIVE_MSEC]) == active);
+        }
+
+        const struct osw_tlv_hdr *cnt = tb[id];
+        assert(cnt != NULL);
+
+        assert(defs->tpolicy[id].tb_size == OSW_STATS_CHAN_CNT_MAX__);
+        const struct osw_tlv_hdr *tb2[OSW_STATS_CHAN_MAX__] = {0};
+        const size_t left2 = osw_tlv_parse(osw_tlv_get_data(cnt), cnt->len, defs->tpolicy[id].nested, tb2, OSW_STATS_CHAN_CNT_MAX__);
+        assert(left2 == 0);
+
+        struct {
+            uint32_t i;
+            int id;
+        } cnts[] = {
+            { .i = tx, OSW_STATS_CHAN_CNT_TX },
+            { .i = rx, OSW_STATS_CHAN_CNT_RX },
+            { .i = rx_inbss, OSW_STATS_CHAN_CNT_RX_INBSS },
+            { .i = busy, OSW_STATS_CHAN_CNT_BUSY },
+        };
+        const size_t n = sizeof(cnts) / sizeof(cnts[0]);
+        size_t j;
+
+        for (j = 0; j < n; j++) {
+            const struct osw_tlv_hdr *hdr = tb2[cnts[j].id];
+            assert(hdr != NULL);
+            const uint32_t x = osw_tlv_get_u32(hdr);
+            assert(x == cnts[j].i);
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+OSW_UT(osw_stats_chan)
+{
+    struct osw_tlv s0 = {0};
+    struct osw_tlv s1 = {0};
+    struct osw_tlv ret = {0};
+    osw_stats_ut_put_chan(&s0, "phy0", 2412, OSW_STATS_CHAN_CNT_MSEC, 0, 0, 0, 0, 0);
+    osw_stats_ut_put_chan(&s0, "phy0", 2422, OSW_STATS_CHAN_CNT_MSEC, 0, 0, 0, 0, 0);
+    osw_stats_ut_put_chan(&s1, "phy0", 2412, OSW_STATS_CHAN_CNT_MSEC, 1000, 50, 100, 50, 500);
+    osw_stats_ut_put_chan(&s1, "phy0", 2422, OSW_STATS_CHAN_CNT_MSEC, 100, 0, 0, 0, 50);
+    const double t0 = 0.0;
+    const double t1 = 1.0;
+    const double t2 = 2.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_chan(sub, true);
+    osw_stats_subscriber_set_poll_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_fn(sub, osw_stats_ut_report_cb, &ret);
+    osw_stats_ut_run_expect(&stats, t0, true, false);
+    osw_stats_register_subscriber__(&stats, sub);
+    osw_stats_ut_run_expect(&stats, t0, false, false);
+    osw_stats_ut_run_expect(&stats, t1, false, true);
+    osw_stats_put_tlv(&stats, &s0);
+    osw_stats_ut_run_expect(&stats, t1, false, false);
+    assert(ret.used == 0);
+    osw_stats_put_tlv(&stats, &s1);
+    osw_stats_ut_run_expect(&stats, t2, false, true);
+    assert(ret.used > 0);
+    assert(osw_stats_ut_tlv_expect_chan(&ret, "phy0", 2412, OSW_STATS_CHAN_CNT_MSEC, 1000, 50, 100, 50, 500) == true);
+    assert(osw_stats_ut_tlv_expect_chan(&ret, "phy0", 2422, OSW_STATS_CHAN_CNT_MSEC, 100, 0, 0, 0, 50) == true);
+    assert(osw_stats_ut_tlv_expect_chan(&ret, "phy0", 2412, OSW_STATS_CHAN_CNT_PERCENT, 1000, 5, 10, 5, 50) == true);
+    assert(osw_stats_ut_tlv_expect_chan(&ret, "phy0", 2422, OSW_STATS_CHAN_CNT_PERCENT, 100, 0, 0, 0, 50) == true);
+    osw_stats_unregister_subscriber(sub);
+    osw_tlv_fini(&s0);
+    osw_tlv_fini(&s1);
+    osw_tlv_fini(&ret);
+}
+
+OSW_UT(osw_stats_chan_percent)
+{
+    struct osw_tlv s0 = {0};
+    struct osw_tlv ret = {0};
+    osw_stats_ut_put_chan(&s0, "phy0", 2412, OSW_STATS_CHAN_CNT_PERCENT, 1000, 10, 40, 30, 60);
+    osw_stats_ut_put_chan(&s0, "phy0", 2422, OSW_STATS_CHAN_CNT_PERCENT, 500, 0, 0, 0, 10);
+    const double t0 = 0.0;
+    const double t1 = 1.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_chan(sub, true);
+    osw_stats_subscriber_set_poll_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_fn(sub, osw_stats_ut_report_cb, &ret);
+    osw_stats_ut_run_expect(&stats, t0, true, false);
+    osw_stats_register_subscriber__(&stats, sub);
+    osw_stats_ut_run_expect(&stats, t0, false, false);
+    osw_stats_put_tlv(&stats, &s0);
+    osw_stats_ut_run_expect(&stats, t1, false, true);
+    assert(ret.used > 0);
+    /* active is expected 0/non-existent because there's only 1 sample of
+     * percentages, but policy is expecting at least 2 samples for first usable
+     * data sample for most fields */
+    assert(osw_stats_ut_tlv_expect_chan(&ret, "phy0", 2412, OSW_STATS_CHAN_CNT_PERCENT, 0, 10, 40, 30, 60) == true);
+    assert(osw_stats_ut_tlv_expect_chan(&ret, "phy0", 2422, OSW_STATS_CHAN_CNT_PERCENT, 0, 0, 0, 0, 10) == true);
+    osw_stats_unregister_subscriber(sub);
+    osw_tlv_fini(&s0);
+    osw_tlv_fini(&ret);
+}
+
+OSW_UT(osw_stats_chan_percent_disabled)
+{
+    struct osw_tlv s0 = {0};
+    struct osw_tlv ret = {0};
+    osw_stats_ut_put_chan(&s0, "phy0", 2412, OSW_STATS_CHAN_CNT_PERCENT, 1000, 10, 40, 30, 60);
+    osw_stats_ut_put_chan(&s0, "phy0", 2422, OSW_STATS_CHAN_CNT_PERCENT, 500, 0, 0, 0, 10);
+    const double t0 = 0.0;
+    const double t1 = 1.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_chan(sub, false);
+    osw_stats_subscriber_set_poll_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_fn(sub, osw_stats_ut_report_cb, &ret);
+    osw_stats_ut_run_expect(&stats, t0, true, false);
+    osw_stats_register_subscriber__(&stats, sub);
+    osw_stats_ut_run_expect(&stats, t0, false, false);
+    osw_stats_put_tlv(&stats, &s0);
+    osw_stats_ut_run_expect(&stats, t1, false, true);
+    assert(ret.used == 0);
+    osw_stats_unregister_subscriber(sub);
+    osw_tlv_fini(&s0);
+    osw_tlv_fini(&ret);
+}
+
+OSW_UT(osw_stats_bucket_expiry)
+{
+    struct osw_tlv s0 = {0};
+    osw_stats_ut_put_chan(&s0, "phy0", 2412, OSW_STATS_CHAN_CNT_MSEC, 0, 0, 0, 0, 0);
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_chan(sub, true);
+    osw_stats_subscriber_set_poll_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_seconds(sub, 1.0);
+    osw_stats_register_subscriber__(&stats, sub);
+    osw_stats_put_tlv(&stats, &s0);
+    assert(ds_tree_is_empty(&sub->buckets[OSW_STATS_CHAN]) == false);
+    osw_stats_subscriber_flush(sub);
+    assert(ds_tree_is_empty(&sub->buckets[OSW_STATS_CHAN]) == false);
+    {
+        /* No more stats will be put into the bucket now. It
+         * should expire after N number of flushes.
+         */
+        size_t n = 0;
+        while (ds_tree_is_empty(&sub->buckets[OSW_STATS_CHAN]) == false) {
+            osw_stats_subscriber_flush(sub);
+            n++;
+        }
+        assert(n == OSW_STATS_BUCKET_EXPIRE_AFTER_N_PERIODS);
+    }
+    osw_stats_unregister_subscriber(sub);
+    osw_tlv_fini(&s0);
+}
+
+static void
+osw_stats_ut_put_bss(struct osw_tlv *t,
+                     const char *phy_name,
+                     const struct osw_hwaddr *bssid,
+                     uint32_t freq,
+                     uint32_t width,
+                     const char *ssid,
+                     const void *ies,
+                     size_t ies_len)
+{
+    void *s = osw_tlv_put_nested(t, OSW_STATS_BSS_SCAN);
+    osw_tlv_put_string(t, OSW_STATS_BSS_SCAN_PHY_NAME, phy_name);
+    osw_tlv_put_hwaddr(t, OSW_STATS_BSS_SCAN_MAC_ADDRESS, bssid);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_FREQ_MHZ, freq);
+    osw_tlv_put_u32(t, OSW_STATS_BSS_SCAN_WIDTH_MHZ, width);
+    osw_tlv_put_buf(t, OSW_STATS_BSS_SCAN_SSID, ssid, strlen(ssid));
+    osw_tlv_put_buf(t, OSW_STATS_BSS_SCAN_IES, ies, ies_len);
+    osw_tlv_end_nested(t, s);
+}
+
+static bool
+osw_stats_ut_tlv_expect_bss(const struct osw_tlv *src,
+                            const char *phy_name,
+                            const struct osw_hwaddr *bssid,
+                            const uint32_t freq,
+                            const uint32_t width,
+                            const char *ssid,
+                            const void *ies,
+                            size_t ies_len)
+{
+    const struct osw_stats_defs *defs = osw_stats_defs_lookup(OSW_STATS_BSS_SCAN);
+    assert(defs != NULL);
+
+    const struct osw_tlv_hdr *i;
+    const void *data = src->data;
+    size_t len = src->used;
+
+    osw_tlv_for_each(i, data, len) {
+        assert(i->id == OSW_STATS_BSS_SCAN);
+
+        const struct osw_tlv_hdr *tb[OSW_STATS_BSS_SCAN_MAX__] = {0};
+        const size_t left = osw_tlv_parse(osw_tlv_get_data(i), i->len, defs->tpolicy, tb, OSW_STATS_BSS_SCAN_MAX__);
+        assert(left == 0);
+
+        assert(tb[OSW_STATS_BSS_SCAN_PHY_NAME] != NULL);
+        assert(tb[OSW_STATS_BSS_SCAN_MAC_ADDRESS] != NULL);
+        assert(tb[OSW_STATS_BSS_SCAN_FREQ_MHZ] != NULL);
+        assert(tb[OSW_STATS_BSS_SCAN_WIDTH_MHZ] != NULL);
+        assert(tb[OSW_STATS_BSS_SCAN_SSID] != NULL);
+        assert(tb[OSW_STATS_BSS_SCAN_IES] != NULL);
+
+        if (strcmp(osw_tlv_get_string(tb[OSW_STATS_CHAN_PHY_NAME]), phy_name) != 0) continue;
+        if (osw_tlv_get_u32(tb[OSW_STATS_BSS_SCAN_FREQ_MHZ]) != freq) continue;
+        if (osw_tlv_get_u32(tb[OSW_STATS_BSS_SCAN_WIDTH_MHZ]) != width) continue;
+        if (memcmp(osw_tlv_get_data(tb[OSW_STATS_BSS_SCAN_MAC_ADDRESS]), bssid, sizeof(bssid->octet)) != 0) continue;
+        if (memcmp(osw_tlv_get_data(tb[OSW_STATS_BSS_SCAN_SSID]), ssid, strlen(ssid)) != 0) continue;
+        if (memcmp(osw_tlv_get_data(tb[OSW_STATS_BSS_SCAN_IES]), ies, ies_len) != 0) continue;
+
+        return true;
+    }
+
+    return false;
+}
+
+OSW_UT(osw_stats_bss_scan)
+{
+    struct osw_tlv s0 = {0};
+    struct osw_tlv ret = {0};
+    const struct osw_hwaddr addr1 = { .octet = {1} };
+    const struct osw_hwaddr addr2 = { .octet = {2} };
+    osw_stats_ut_put_bss(&s0, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4);
+    osw_stats_ut_put_bss(&s0, "phy1", &addr2, 5180, 80, "wutwut", "12", 2);
+    const double t0 = 0.0;
+    const double t1 = 1.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_bss(sub, true);
+    osw_stats_subscriber_set_poll_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_fn(sub, osw_stats_ut_report_cb, &ret);
+    osw_stats_ut_run_expect(&stats, t0, true, false);
+    osw_stats_register_subscriber__(&stats, sub);
+    osw_stats_ut_run_expect(&stats, t0, false, false);
+    osw_stats_put_tlv(&stats, &s0);
+    osw_stats_ut_run_expect(&stats, t1, false, true);
+    assert(ret.used > 0);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4) == true);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy1", &addr2, 5180, 80, "wutwut", "12", 2) == true);
+    osw_stats_unregister_subscriber(sub);
+    osw_tlv_fini(&s0);
+    osw_tlv_fini(&ret);
+}
+
+OSW_UT(osw_stats_bss_scan_report)
+{
+    struct osw_tlv s0 = {0};
+    struct osw_tlv ret = {0};
+    const struct osw_hwaddr addr1 = { .octet = {1} };
+    const struct osw_hwaddr addr2 = { .octet = {2} };
+    osw_stats_ut_put_bss(&s0, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4);
+    osw_stats_ut_put_bss(&s0, "phy1", &addr2, 5180, 80, "wutwut", "12", 2);
+    const double t0 = 0.0;
+    const double t1 = 1.0;
+    const double t2 = 3.0;
+    const double t3 = 5.0;
+    const double t4 = 6.0;
+    const double t5 = 8.0;
+    const double t6 = 10.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_bss(sub, true);
+    osw_stats_subscriber_set_poll_seconds(sub, 1.0);
+    osw_stats_subscriber_set_report_seconds(sub, 5);
+    osw_stats_subscriber_set_report_fn(sub, osw_stats_ut_report_cb, &ret);
+    osw_stats_ut_run_expect(&stats, t0, true, false);
+    osw_stats_register_subscriber__(&stats, sub);
+    osw_stats_ut_run_expect(&stats, t0, false, false);
+    osw_stats_put_tlv(&stats, &s0);
+    osw_stats_ut_run_expect(&stats, t1, false, true);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t2, false, true);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t3, false, true);
+    assert(ret.used > 0);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4) == true);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy1", &addr2, 5180, 80, "wutwut", "12", 2) == true);
+    osw_tlv_fini(&ret);
+    assert(ret.used == 0);
+    osw_stats_put_tlv(&stats, &s0);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t4, false, true);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t5, false, true);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t6, false, true);
+    assert(ret.used > 0);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4) == true);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy1", &addr2, 5180, 80, "wutwut", "12", 2) == true);
+    osw_stats_unregister_subscriber(sub);
+    osw_tlv_fini(&s0);
+    osw_tlv_fini(&ret);
+}
+
+OSW_UT(osw_stats_bss_scan_report_nopoll)
+{
+    struct osw_tlv s0 = {0};
+    struct osw_tlv ret = {0};
+    const struct osw_hwaddr addr1 = { .octet = {1} };
+    const struct osw_hwaddr addr2 = { .octet = {2} };
+    osw_stats_ut_put_bss(&s0, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4);
+    osw_stats_ut_put_bss(&s0, "phy1", &addr2, 5180, 80, "wutwut", "12", 2);
+    const double t0 = 0.0;
+    const double t1 = 1.0;
+    const double t2 = 3.0;
+    const double t3 = 5.0;
+    const double t4 = 6.0;
+    const double t5 = 8.0;
+    const double t6 = 10.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_bss(sub, true);
+    osw_stats_subscriber_set_report_seconds(sub, 5);
+    osw_stats_subscriber_set_report_fn(sub, osw_stats_ut_report_cb, &ret);
+    osw_stats_ut_run_expect(&stats, t0, true, false);
+    osw_stats_register_subscriber__(&stats, sub);
+    osw_stats_ut_run_expect(&stats, t0, false, false);
+    osw_stats_put_tlv(&stats, &s0);
+    osw_stats_ut_run_expect(&stats, t1, false, false);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t2, false, false);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t3, false, false);
+    assert(ret.used > 0);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4) == true);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy1", &addr2, 5180, 80, "wutwut", "12", 2) == true);
+    osw_tlv_fini(&ret);
+    assert(ret.used == 0);
+    osw_stats_put_tlv(&stats, &s0);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t4, false, false);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t5, false, false);
+    assert(ret.used == 0);
+    osw_stats_ut_run_expect(&stats, t6, false, false);
+    assert(ret.used > 0);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy0", &addr1, 2412, 20, "fgsfds", "hell", 4) == true);
+    assert(osw_stats_ut_tlv_expect_bss(&ret, "phy1", &addr2, 5180, 80, "wutwut", "12", 2) == true);
+    osw_stats_unregister_subscriber(sub);
+    osw_tlv_fini(&s0);
+    osw_tlv_fini(&ret);
+}
+
+OSW_UT(osw_stats_poll_coalescing)
+{
+    const double t0 = 0.0;
+    const double t1 = 6.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub1 = osw_stats_subscriber_alloc();
+    struct osw_stats_subscriber *sub2 = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_poll_seconds(sub1, 5);
+    osw_stats_subscriber_set_poll_seconds(sub2, 5);
+    osw_stats_register_subscriber__(&stats, sub1);
+    osw_stats_register_subscriber__(&stats, sub2);
+    {
+        double r = -1;
+        bool poll = false;
+        osw_stats_run_subscribers(&stats, t0, &poll, &r);
+        assert(poll == false);
+        assert(r == 5.0);
+    }
+    assert(sub1->poller != NULL);
+    assert(sub1->poller == sub2->poller);
+    {
+        size_t n = 0;
+        struct osw_stats_poller *p;
+        ds_tree_foreach(&stats.pollers, p) n++;
+        assert(n == 1);
+    }
+    {
+        double r = -1;
+        bool poll = false;
+        osw_stats_run_subscribers(&stats, t1, &poll, &r);
+        assert(poll == true);
+        assert(r == 4.0);
+    }
+    osw_stats_unregister_subscriber(sub1);
+    osw_stats_unregister_subscriber(sub2);
+}
+
+OSW_UT(osw_stats_poll_no_coalescing)
+{
+    const double t0 = 0.0;
+    const double t1 = 5.0;
+    const double t2 = 7.0;
+    struct osw_stats stats = {0};
+    struct osw_stats_subscriber *sub1 = osw_stats_subscriber_alloc();
+    struct osw_stats_subscriber *sub2 = osw_stats_subscriber_alloc();
+    osw_stats_init(&stats);
+    osw_stats_subscriber_set_poll_seconds(sub1, 6);
+    osw_stats_subscriber_set_poll_seconds(sub2, 4);
+    osw_stats_register_subscriber__(&stats, sub1);
+    osw_stats_register_subscriber__(&stats, sub2);
+    {
+        double r = -1;
+        bool poll = false;
+        osw_stats_run_subscribers(&stats, t0, &poll, &r);
+        assert(poll == false);
+        assert(r == 4.0);
+    }
+    assert(sub1->poller != NULL);
+    assert(sub2->poller != NULL);
+    assert(sub1->poller != sub2->poller);
+    {
+        size_t n = 0;
+        struct osw_stats_poller *p;
+        ds_tree_foreach(&stats.pollers, p) n++;
+        assert(n == 2);
+    }
+    {
+        double r = -1;
+        bool poll = false;
+        osw_stats_run_subscribers(&stats, t1, &poll, &r);
+        assert(poll == true);
+        assert(r == 1.0);
+    }
+    {
+        double r = -1;
+        bool poll = false;
+        osw_stats_run_subscribers(&stats, t2, &poll, &r);
+        assert(poll == true);
+        assert(r == 1.0);
+    }
+    osw_stats_unregister_subscriber(sub1);
+    osw_stats_unregister_subscriber(sub2);
+}
Index: core/src/lib/osw/src/osw_throttle.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_throttle.c
@@ -0,0 +1,130 @@
+#include <stdint.h>
+#include <stdbool.h>
+#include <log.h>
+#include <memutil.h>
+#include <osw_time.h>
+#include <osw_throttle.h>
+
+enum osw_throttle_type {
+    OSW_THROTTLE_RATE_LIMIT,
+};
+
+struct osw_throttle_rate_limit {
+    const unsigned int limit;
+    const uint64_t period_nsec;
+
+    unsigned int counter;
+    uint64_t first_tap_nsec;
+    uint64_t next_at_nsec;
+};
+
+struct osw_throttle {
+    enum osw_throttle_type type;
+    union {
+        struct osw_throttle_rate_limit rate_limit;
+    } data;
+};
+
+static bool
+osw_throttle_rate_limit_tap(struct osw_throttle *throttle,
+                            uint64_t now_nsec,
+                            uint64_t *next_at_nsec)
+{
+    ASSERT(throttle != NULL, "");
+
+    struct osw_throttle_rate_limit *rate_limit = &throttle->data.rate_limit;
+    bool result = true;
+
+    if (rate_limit->next_at_nsec > now_nsec) {
+        result = false;
+        goto finish;
+    }
+
+    if ((now_nsec - rate_limit->first_tap_nsec) >= rate_limit->period_nsec) {
+        rate_limit->first_tap_nsec = now_nsec;
+        rate_limit->counter = 0;
+    }
+
+    if (rate_limit->counter >= rate_limit->limit) {
+        result = false;
+        goto finish;
+    }
+
+    rate_limit->counter++;
+    if (rate_limit->counter == rate_limit->limit)
+        rate_limit->next_at_nsec = now_nsec + rate_limit->period_nsec;
+    else
+        rate_limit->next_at_nsec = now_nsec;
+
+    finish:
+        *next_at_nsec = rate_limit->next_at_nsec;
+        return result;
+}
+
+static void
+osw_throttle_rate_limit_reset(struct osw_throttle *throttle)
+{
+    ASSERT(throttle != NULL, "");
+
+    struct osw_throttle_rate_limit *rate_limit = &throttle->data.rate_limit;
+
+    rate_limit->counter = 0;
+    rate_limit->first_tap_nsec = 0;
+    rate_limit->next_at_nsec = 0;
+}
+
+struct osw_throttle*
+osw_throttle_new_rate_limit(unsigned int limit,
+                            uint64_t period_nsec)
+{
+    const struct osw_throttle_rate_limit rate_limit = {
+        .limit = limit,
+        .period_nsec = period_nsec,
+        .counter = 0,
+        .first_tap_nsec = 0,
+        .next_at_nsec = 0,
+    };
+    struct osw_throttle *throttle = CALLOC(1, sizeof(*throttle));
+
+    throttle->type = OSW_THROTTLE_RATE_LIMIT;
+    memcpy(&throttle->data.rate_limit, &rate_limit, sizeof(throttle->data.rate_limit));
+
+    return throttle;
+}
+
+void
+osw_throttle_free(struct osw_throttle *throttle)
+{
+    FREE(throttle);
+}
+
+bool
+osw_throttle_tap(struct osw_throttle *throttle,
+                 uint64_t *next_at_nsec)
+{
+    ASSERT(throttle != NULL, "");
+    ASSERT(next_at_nsec != NULL, "");
+
+    const uint64_t now_nsec = osw_time_mono_clk();
+
+    switch (throttle->type) {
+        case OSW_THROTTLE_RATE_LIMIT:
+            return osw_throttle_rate_limit_tap(throttle, now_nsec, next_at_nsec);
+    };
+
+    ASSERT(false, "osw: throttle: unreachable code");
+    return false;
+}
+
+void
+osw_throttle_reset(struct osw_throttle *throttle)
+{
+    ASSERT(throttle != NULL, "");
+
+    switch (throttle->type) {
+        case OSW_THROTTLE_RATE_LIMIT:
+            return osw_throttle_rate_limit_reset(throttle);
+    };
+}
+
+#include "osw_throttle_ut.c"
Index: core/src/lib/osw/src/osw_throttle_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_throttle_ut.c
@@ -0,0 +1,120 @@
+#include <ev.h>
+#include <osw_ut.h>
+
+OSW_UT(osw_throttle_ut_rate_limit_simple)
+{
+    struct osw_throttle *throttle;
+    uint64_t next_at_nsec;
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(0));
+
+    /*** 1 iteration per 1s ***/
+    throttle = osw_throttle_new_rate_limit(1, OSW_TIME_SEC(1));
+
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(1));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == false);
+    assert(next_at_nsec == OSW_TIME_SEC(1));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(500));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == false);
+    assert(next_at_nsec == OSW_TIME_SEC(1));
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(1));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(2));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == false);
+    assert(next_at_nsec == OSW_TIME_SEC(2));
+
+    osw_throttle_free(throttle);
+}
+
+OSW_UT(osw_throttle_ut_rate_limit_complex)
+{
+    struct osw_throttle *throttle;
+    uint64_t next_at_nsec;
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(0));
+
+    /*** 4 iterations per 2s ***/
+    throttle = osw_throttle_new_rate_limit(4, OSW_TIME_SEC(2));
+
+    /*
+     * Reach limit within 2s
+     */
+    osw_time_set_mono_clk(OSW_TIME_MSEC(0));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(0));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(100));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(100));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(200));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(200));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(300));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(2300));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(400));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == false);
+    assert(next_at_nsec == OSW_TIME_MSEC(2300));
+
+    /*
+     * Reach limit within 2s one more time
+     */
+    osw_time_set_mono_clk(OSW_TIME_MSEC(3000));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(3000));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(3500));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(3500));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(4100));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(4100));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(4800));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_MSEC(6800));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(5000));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == false);
+    assert(next_at_nsec == OSW_TIME_MSEC(6800));
+
+    osw_time_set_mono_clk(OSW_TIME_MSEC(6600));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == false);
+    assert(next_at_nsec == OSW_TIME_MSEC(6800));
+
+    /*
+     * 6 consecutive successful taps with 1s interval
+     */
+    osw_time_set_mono_clk(OSW_TIME_SEC(10));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(10));
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(11));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(11));
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(12));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(12));
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(13));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(13));
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(14));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(14));
+
+    osw_time_set_mono_clk(OSW_TIME_SEC(15));
+    assert(osw_throttle_tap(throttle, &next_at_nsec) == true);
+    assert(next_at_nsec == OSW_TIME_SEC(15));
+
+    osw_throttle_free(throttle);
+}
Index: core/src/lib/osw/src/osw_time.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_time.c
@@ -0,0 +1,44 @@
+#include <time.h>
+#include <stdint.h>
+#include <osw_time.h>
+
+static uint64_t g_mono_clk_nsec = UINT64_MAX;
+static uint64_t g_wall_clk_nsec = UINT64_MAX;
+
+uint64_t
+osw_time_mono_clk(void)
+{
+    struct timespec tstamp;
+
+    if (g_mono_clk_nsec != UINT64_MAX)
+        return g_mono_clk_nsec;
+
+    clock_gettime(CLOCK_MONOTONIC, &tstamp);
+    return (tstamp.tv_sec * 1e9) + tstamp.tv_nsec;
+}
+
+uint64_t
+osw_time_wall_clk(void)
+{
+    struct timespec tstamp;
+
+    if (g_wall_clk_nsec != UINT64_MAX)
+        return g_wall_clk_nsec;
+
+    clock_gettime(CLOCK_REALTIME, &tstamp);
+    return (tstamp.tv_sec * 1e9) + tstamp.tv_nsec;
+}
+
+void
+osw_time_set_mono_clk(uint64_t nsec)
+{
+    g_mono_clk_nsec = nsec;
+}
+
+void
+osw_time_set_wall_clk(uint64_t nsec)
+{
+    g_wall_clk_nsec = nsec;
+}
+
+#include "osw_time_ut.c"
Index: core/src/lib/osw/src/osw_time_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_time_ut.c
@@ -0,0 +1,31 @@
+#include <unistd.h>
+#include <float.h>
+#include <math.h>
+#include <ev.h>
+#include <osw_ut.h>
+
+OSW_UT(osw_time_ut_macros)
+{
+    assert(OSW_TIME_SEC(4) == 4e9);
+    assert(OSW_TIME_MSEC(300) == 0.3e9);
+    assert((OSW_TIME_TO_DBL(13.l - OSW_TIME_TO_DBL(OSW_TIME_SEC(13))) <=  DBL_EPSILON) &&
+           (OSW_TIME_TO_DBL(13.l - OSW_TIME_TO_DBL(OSW_TIME_SEC(13))) >= -DBL_EPSILON));
+}
+
+OSW_UT(osw_time_ut_mono_clk_override)
+{
+    uint64_t tstamp;
+
+    tstamp = osw_time_mono_clk();
+    assert(tstamp > 0);
+
+    osw_time_set_mono_clk(357);
+    tstamp = osw_time_mono_clk();
+    assert(tstamp == 357);
+    tstamp = osw_time_mono_clk();
+    assert(tstamp == 357);
+
+    osw_time_set_mono_clk(654321);
+    tstamp = osw_time_mono_clk();
+    assert(tstamp == 654321);
+}
Index: core/src/lib/osw/src/osw_timer.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_timer.c
@@ -0,0 +1,135 @@
+#include <stdint.h>
+#include <log.h>
+#include <osa_assert.h>
+#include <ds_dlist.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_module.h>
+
+static struct ds_dlist g_active_list = DS_DLIST_INIT(struct osw_timer, node);
+
+void
+osw_timer_core_dispatch(uint64_t now_nsec)
+{
+    struct ds_dlist pending_list = DS_DLIST_INIT(struct osw_timer, node);
+
+    /* Prepare */
+    while (ds_dlist_is_empty(&g_active_list) == false) {
+        struct osw_timer *timer = (struct osw_timer*) ds_dlist_head(&g_active_list);
+
+        if (timer->at_nsec > now_nsec)
+            break;
+
+        WARN_ON(timer->list != &g_active_list);
+        ds_dlist_remove(&g_active_list, timer);
+        timer->list = NULL;
+
+        ds_dlist_insert_tail(&pending_list, timer);
+        timer->list = &pending_list;
+    }
+
+    /* Dispatch */
+    while (ds_dlist_is_empty(&pending_list) == false) {
+        struct osw_timer *timer = (struct osw_timer*) ds_dlist_head(&pending_list);
+
+        WARN_ON(timer->list != &pending_list);
+        ds_dlist_remove(&pending_list, timer);
+        timer->list = NULL;
+
+        ASSERT(timer->cb != NULL, "");
+        timer->cb(timer);
+    }
+}
+
+bool
+osw_timer_core_get_next_at(uint64_t *next_at_nsec)
+{
+    ASSERT(next_at_nsec != NULL, "");
+
+    struct osw_timer *timer;
+
+    if (ds_dlist_is_empty(&g_active_list) == true)
+        return false;
+
+    timer = (struct osw_timer*) ds_dlist_head(&g_active_list);
+    *next_at_nsec = timer->at_nsec;
+    return true;
+}
+
+void
+osw_timer_init(struct osw_timer *timer,
+               osw_timer_fn *cb)
+{
+    ASSERT(timer != NULL, "");
+    ASSERT(cb != NULL, "");
+
+    memset(timer, 0, sizeof(*timer));
+    timer->cb = cb;
+}
+
+void
+osw_timer_arm_at_nsec(struct osw_timer *timer,
+                      uint64_t nsec)
+{
+    ASSERT(timer != NULL, "");
+    ASSERT(timer->cb != NULL, "");
+
+    struct osw_timer *next_timer;
+
+    timer->at_nsec = nsec;
+    if (timer->list) {
+        ds_dlist_remove(timer->list, timer);
+        timer->list = NULL;
+    }
+
+    ds_dlist_foreach(&g_active_list, next_timer)
+        if (next_timer->at_nsec >= timer->at_nsec)
+            break;
+
+    if (next_timer != NULL)
+        ds_dlist_insert_before(&g_active_list, next_timer, timer);
+    else
+        ds_dlist_insert_tail(&g_active_list, timer);
+
+    timer->list = &g_active_list;
+}
+
+void
+osw_timer_disarm(struct osw_timer *timer)
+{
+    ASSERT(timer != NULL, "");
+
+    if (timer->list == NULL)
+        return;
+
+    ds_dlist_remove(timer->list, timer);
+    timer->list = NULL;
+}
+
+bool
+osw_timer_is_armed(const struct osw_timer *timer)
+{
+    ASSERT(timer != NULL, "");
+    return timer->list != NULL;
+}
+
+uint64_t
+osw_timer_get_remaining_nsec(const struct osw_timer *timer,
+                             uint64_t now_nsec)
+{
+    ASSERT(timer != NULL, "");
+    if (osw_timer_is_armed(timer) == true) {
+        assert(timer->at_nsec >= now_nsec);
+        return timer->at_nsec - now_nsec;
+    }
+    else {
+        return UINT64_MAX;
+    }
+}
+
+OSW_MODULE(osw_timer)
+{
+    return NULL;
+}
+
+#include "osw_timer_ut.c"
Index: core/src/lib/osw/src/osw_timer_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_timer_ut.c
@@ -0,0 +1,153 @@
+#include <const.h>
+#include <ev.h>
+#include <osw_ut.h>
+
+struct osw_timer_ut_dummy {
+    bool dispatched;
+    struct osw_timer timer;
+};
+
+static void
+osw_timer_ut_dummy_cb(struct osw_timer *timer)
+{
+    struct osw_timer_ut_dummy* dummy = (struct osw_timer_ut_dummy*) container_of(timer, struct osw_timer_ut_dummy, timer);
+    dummy->dispatched = true;
+}
+
+static void
+osw_timer_ut_nop_cb(struct osw_timer *timer)
+{
+    /* nop */
+}
+
+OSW_UT(osw_timer_ut_lifecycle)
+{
+    struct osw_timer_ut_dummy dummy_a;
+    struct osw_timer_ut_dummy dummy_b;
+    struct osw_timer_ut_dummy dummy_c;
+    uint64_t next_at_nsec = 0;
+
+    memset(&dummy_a, 0, sizeof(dummy_a));
+    memset(&dummy_b, 0, sizeof(dummy_b));
+    memset(&dummy_c, 0, sizeof(dummy_c));
+
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == false);
+
+    /* Initialize all timers */
+    osw_timer_init(&dummy_a.timer, osw_timer_ut_dummy_cb);
+    osw_timer_init(&dummy_b.timer, osw_timer_ut_dummy_cb);
+    osw_timer_init(&dummy_c.timer, osw_timer_ut_dummy_cb);
+    assert(osw_timer_is_armed(&dummy_a.timer) == false);
+    assert(osw_timer_is_armed(&dummy_b.timer) == false);
+    assert(osw_timer_is_armed(&dummy_c.timer) == false);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == false);
+
+    /*
+     * Arm timer in following order (first is the earliest), expected stages:
+     * - A
+     * - B, A
+     * - C, B, A
+     */
+    osw_timer_arm_at_nsec(&dummy_a.timer, 300);
+    assert(osw_timer_is_armed(&dummy_a.timer) == true);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 300);
+
+    osw_timer_arm_at_nsec(&dummy_b.timer, 200);
+    assert(osw_timer_is_armed(&dummy_b.timer) == true);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 200);
+
+    osw_timer_arm_at_nsec(&dummy_c.timer, 100);
+    assert(osw_timer_is_armed(&dummy_c.timer) == true);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 100);
+
+    /*
+     * Disarm timers, expected stages
+     * - C, A (disarm B)
+     * - A (disarm C)
+     */
+    osw_timer_disarm(&dummy_b.timer);
+    assert(osw_timer_is_armed(&dummy_b.timer) == false);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 100);
+
+    osw_timer_disarm(&dummy_c.timer);
+    assert(osw_timer_is_armed(&dummy_c.timer) == false);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 300);
+
+    /* Rearm timers B and C */
+    osw_timer_arm_at_nsec(&dummy_b.timer, 200);
+    osw_timer_arm_at_nsec(&dummy_c.timer, 100);
+    assert(osw_timer_is_armed(&dummy_b.timer) == true);
+    assert(osw_timer_is_armed(&dummy_c.timer) == true);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 100);
+
+    /* Dispatch at 50ns - no timer should fire */
+    osw_timer_core_dispatch(50);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 100);
+    assert(osw_timer_is_armed(&dummy_a.timer) == true);
+    assert(osw_timer_is_armed(&dummy_b.timer) == true);
+    assert(osw_timer_is_armed(&dummy_c.timer) == true);
+    assert(dummy_a.dispatched == false);
+    assert(dummy_b.dispatched == false);
+    assert(dummy_c.dispatched == false);
+
+    /* Dispatch at 75ns - no timer should fire */
+    osw_timer_core_dispatch(75);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 100);
+    assert(osw_timer_is_armed(&dummy_a.timer) == true);
+    assert(osw_timer_is_armed(&dummy_b.timer) == true);
+    assert(osw_timer_is_armed(&dummy_c.timer) == true);
+    assert(dummy_a.dispatched == false);
+    assert(dummy_b.dispatched == false);
+    assert(dummy_c.dispatched == false);
+
+    /* Dispatch at 100ns - C should fire */
+    osw_timer_core_dispatch(100);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == true);
+    assert(next_at_nsec == 200);
+    assert(osw_timer_is_armed(&dummy_a.timer) == true);
+    assert(osw_timer_is_armed(&dummy_b.timer) == true);
+    assert(osw_timer_is_armed(&dummy_c.timer) == false);
+    assert(dummy_a.dispatched == false);
+    assert(dummy_b.dispatched == false);
+    assert(dummy_c.dispatched == true);
+
+    /* Dispatch at 300ns - A & B should fire */
+    dummy_c.dispatched = false;
+    osw_timer_core_dispatch(300);
+    assert(osw_timer_core_get_next_at(&next_at_nsec) == false);
+    assert(osw_timer_is_armed(&dummy_a.timer) == false);
+    assert(osw_timer_is_armed(&dummy_b.timer) == false);
+    assert(osw_timer_is_armed(&dummy_c.timer) == false);
+    assert(dummy_a.dispatched == true);
+    assert(dummy_b.dispatched == true);
+    assert(dummy_c.dispatched == false);
+}
+
+OSW_UT(osw_timer_ut_ordering)
+{
+    struct osw_timer t0 = { .cb = osw_timer_ut_nop_cb };
+    struct osw_timer t5 = { .cb = osw_timer_ut_nop_cb };
+    struct osw_timer t10 = { .cb = osw_timer_ut_nop_cb };
+    struct osw_timer t15 = { .cb = osw_timer_ut_nop_cb };
+    struct osw_timer t20 = { .cb = osw_timer_ut_nop_cb };
+
+    osw_timer_arm_at_nsec(&t5, 5);
+    osw_timer_arm_at_nsec(&t10, 10);
+    osw_timer_arm_at_nsec(&t15, 15);
+    osw_timer_arm_at_nsec(&t0, 0);
+    osw_timer_arm_at_nsec(&t20, 20);
+
+    assert(ds_dlist_remove_head(&g_active_list) == &t0);
+    assert(ds_dlist_remove_head(&g_active_list) == &t5);
+    assert(ds_dlist_remove_head(&g_active_list) == &t10);
+    assert(ds_dlist_remove_head(&g_active_list) == &t15);
+    assert(ds_dlist_remove_head(&g_active_list) == &t20);
+}
Index: core/src/lib/osw/src/osw_tlv.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_tlv.c
@@ -0,0 +1,159 @@
+#include <memutil.h>
+#include <osw_tlv.h>
+
+static size_t
+osw_tlv_len(const struct osw_tlv_hdr *hdr)
+{
+    const size_t hdr_len = osw_tlv_hdr_len();
+    const size_t data_len = hdr->len;
+    return hdr_len + data_len;
+}
+
+bool
+osw_tlv_ok(const struct osw_tlv_hdr *hdr, size_t remaining)
+{
+    if (hdr == NULL) return false;
+    return osw_tlv_len(hdr) <= remaining;
+}
+
+const struct osw_tlv_hdr *
+osw_tlv_next(const struct osw_tlv_hdr *hdr, size_t *remaining)
+{
+    if (hdr == NULL) return NULL;
+    const size_t offset = osw_tlv_len(hdr);
+    const size_t padding = OSW_TLV_ALIGN(offset) - offset;
+    if (offset > *remaining) return NULL;
+    *remaining -= offset;
+    if (padding > *remaining) return NULL;
+    *remaining -= padding;
+    return (const void *)hdr + offset + padding;
+}
+
+static bool
+osw_tlv_policy_ok(const struct osw_tlv_hdr *hdr,
+                  const struct osw_tlv_policy *policy)
+{
+    static const size_t sizes[] = {
+        //[OSW_TLV_S8] = sizeof(int8_t),
+        [OSW_TLV_U32] = sizeof(uint32_t),
+        //[OSW_TLV_U64] = sizeof(uint64_t),
+        [OSW_TLV_FLOAT] = sizeof(float),
+        [OSW_TLV_HWADDR] = 6,
+    };
+
+    if (policy == NULL) return true;
+    policy += hdr->id;
+
+    if (hdr->type != policy->type) return false;
+
+    /* use enum to make compiler verify switch-case exhaustiveness */
+    enum osw_tlv_type type = hdr->type;
+    switch (type) {
+        case OSW_TLV_HWADDR: /* fall-through */
+        case OSW_TLV_U32: /* fall-through */
+        case OSW_TLV_FLOAT:
+            return hdr->len == sizes[type];
+        case OSW_TLV_STRING: /* fall-through */
+        case OSW_TLV_UNSPEC:
+            return ((hdr->len >= policy->min_len) &&
+                    (policy->max_len == 0 ||
+                     policy->max_len >= hdr->len));
+        case OSW_TLV_NESTED:
+            return true;
+    }
+    return false;
+}
+
+static void
+osw_tlv_grow(struct osw_tlv *tlv, size_t needed)
+{
+    const size_t remaining = tlv->size - OSW_TLV_ALIGN(tlv->used);
+    if (needed <= remaining) return;
+
+    const size_t new_size = tlv->size + OSW_TLV_ALIGN(needed + OSW_TLV_TAILROOM);
+    tlv->data = REALLOC(tlv->data, new_size);
+    memset(tlv->data + tlv->size, 0, new_size - tlv->size);
+    tlv->size = new_size;
+}
+
+void *
+osw_tlv_reserve(struct osw_tlv *tlv, size_t len)
+{
+    osw_tlv_grow(tlv, len);
+    const size_t aused = OSW_TLV_ALIGN(tlv->used);
+    void *data = tlv->data + aused;
+    tlv->used = aused + len;
+    return data;
+}
+
+void
+osw_tlv_copy(struct osw_tlv *dst, const struct osw_tlv *src)
+{
+    osw_tlv_fini(dst);
+    memcpy(osw_tlv_reserve(dst, src->used), src->data, src->used);
+}
+
+void *
+osw_tlv_put(struct osw_tlv *tlv, uint32_t id, enum osw_tlv_type type, size_t len)
+{
+    struct osw_tlv_hdr *hdr = osw_tlv_reserve(tlv, osw_tlv_hdr_len() + len);
+    hdr->id = id;
+    hdr->type = type;
+    hdr->len = len;
+    hdr->flags = 0; // fixme: always provide flags?
+    return osw_tlv_get_data(hdr);
+}
+
+struct osw_tlv *
+osw_tlv_new(void)
+{
+    return CALLOC(1, sizeof(struct osw_tlv));
+}
+
+void
+osw_tlv_fini(struct osw_tlv *tlv)
+{
+    if (tlv == NULL) return;
+    if (tlv->data == NULL) return;
+
+    FREE(tlv->data);
+    memset(tlv, 0, sizeof(*tlv));
+}
+
+void
+osw_tlv_free(struct osw_tlv *tlv)
+{
+    osw_tlv_fini(tlv);
+    FREE(tlv);
+}
+
+size_t
+osw_tlv_parse(const void *data,
+              size_t len,
+              const struct osw_tlv_policy *policy,
+              const struct osw_tlv_hdr **tb,
+              size_t size)
+{
+    const struct osw_tlv_hdr *hdr;
+    osw_tlv_for_each(hdr, data, len) {
+        if (hdr->id >= size) continue;
+        if (osw_tlv_policy_ok(hdr, policy) == false) continue;
+        tb[hdr->id] = hdr;
+    }
+    return len;
+}
+
+const struct osw_tlv_hdr *
+osw_tlv_find(const void *data,
+             size_t len,
+             uint32_t id)
+{
+    const struct osw_tlv_hdr *hdr;
+    osw_tlv_for_each(hdr, data, len) {
+        if (hdr->id == id)
+            return hdr;
+    }
+    return NULL;
+}
+
+#include "osw_tlv_ut.c.h"
Index: core/src/lib/osw/src/osw_tlv_merge.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_tlv_merge.c
@@ -0,0 +1,327 @@
+/* libc */
+#include <string.h>
+
+/* opensync */
+#include <log.h>
+
+/* osw */
+#include <osw_tlv_merge.h>
+
+struct osw_tlv_merge_op {
+    struct osw_tlv *dest_tlv;
+    struct osw_tlv *prev_tlv;
+    const struct osw_tlv_hdr **dest;
+    const struct osw_tlv_hdr **prev;
+    const struct osw_tlv_hdr *src;
+    const bool diff_on_first;
+    const struct osw_tlv_policy *tpolicy;
+    const struct osw_tlv_merge_policy *mpolicy;
+};
+
+typedef void osw_tlv_merge_add_fn_t(void *d, const void *s);
+typedef void osw_tlv_merge_sub_fn_t(void *d, const void *s);
+typedef void osw_tlv_merge_op_fn_t(const struct osw_tlv_merge_op *op);
+
+void
+osw_tlv_merge_repack(struct osw_tlv *dst,
+                     const struct osw_tlv_hdr **tb,
+                     size_t tb_size)
+{
+    struct osw_tlv tmp = {0};
+    size_t i;
+    for (i = 0; i < tb_size; i++) {
+        if (tb[i] == NULL) continue;
+        osw_tlv_put_copy(&tmp, tb[i]);
+    }
+    osw_tlv_fini(dst);
+    *dst = tmp;
+}
+
+void
+osw_tlv_merge_clone(struct osw_tlv *dst,
+                    const struct osw_tlv_hdr *src)
+{
+    if (src == NULL) return;
+    assert(dst->used == 0);
+    memcpy(osw_tlv_reserve(dst, src->len), osw_tlv_get_data(src), src->len);
+}
+
+void
+osw_tlv_merge_replace(struct osw_tlv *dst,
+                      const struct osw_tlv_hdr **hdr,
+                      const struct osw_tlv_hdr *ref,
+                      struct osw_tlv *src)
+{
+    if (hdr[0] == NULL) {
+        if (src->used > 0) {
+            hdr[0] = osw_tlv_put_same(dst, ref, src->data, src->used);
+            hdr[0]--;
+        }
+    }
+    else {
+        if (hdr[0]->len != src->used) {
+            hdr[0] = osw_tlv_put_same(dst, ref, src->data, src->used);
+            hdr[0]--;
+        }
+        else {
+            memcpy(osw_tlv_get_data(hdr[0]), src->data, src->used);
+        }
+    }
+    osw_tlv_fini(src);
+}
+
+static void
+osw_tlv_merge_op_none_cb(const struct osw_tlv_merge_op *op)
+{
+    (void)op;
+}
+
+static void
+osw_tlv_merge_op_overwrite_cb(const struct osw_tlv_merge_op *op)
+{
+    if (*op->dest == NULL || (*op->dest)->len != op->src->len) {
+        void *data = osw_tlv_put(op->dest_tlv, op->src->id, op->src->type, op->src->len);
+        *op->dest = osw_tlv_get_hdr(data);
+    }
+    memcpy(osw_tlv_get_data(*op->dest),
+           osw_tlv_get_data(op->src),
+           op->src->len);
+}
+
+static void
+osw_stats_type_u32_add_cb(void *d, const void *s)
+{
+    *(uint32_t *)d = *(uint32_t *)d + *(uint32_t *)s;
+}
+
+static void
+osw_stats_type_u32_sub_cb(void *d, const void *s)
+{
+    *(uint32_t *)d = *(uint32_t *)d - *(uint32_t *)s;
+}
+
+static void
+osw_stats_type_float_add_cb(void *d, const void *s)
+{
+    *(float *)d = *(float *)d + *(float *)s;
+}
+
+static void
+osw_stats_type_float_sub_cb(void *d, const void *s)
+{
+    *(float *)d = *(float *)d - *(float *)s;
+}
+
+static osw_tlv_merge_add_fn_t *
+osw_tlv_merge_add_fn_lookup(const enum osw_tlv_type t)
+{
+    switch (t) {
+        case OSW_TLV_U32: return osw_stats_type_u32_add_cb;
+        case OSW_TLV_FLOAT: return osw_stats_type_float_add_cb;
+        case OSW_TLV_HWADDR: return NULL;
+        case OSW_TLV_STRING: return NULL;
+        case OSW_TLV_UNSPEC: return NULL;
+        case OSW_TLV_NESTED: return NULL;
+    }
+    assert(0);
+    return NULL;
+}
+
+static osw_tlv_merge_sub_fn_t *
+osw_tlv_merge_sub_fn_lookup(const enum osw_tlv_type t)
+{
+    switch (t) {
+        case OSW_TLV_U32: return osw_stats_type_u32_sub_cb;
+        case OSW_TLV_FLOAT: return osw_stats_type_float_sub_cb;
+        case OSW_TLV_HWADDR: return NULL;
+        case OSW_TLV_STRING: return NULL;
+        case OSW_TLV_UNSPEC: return NULL;
+        case OSW_TLV_NESTED: return NULL;
+    }
+    assert(0);
+    return NULL;
+}
+
+static void
+osw_tlv_merge_op_accumulate_cb(const struct osw_tlv_merge_op *op)
+{
+    const bool need_diff = ((op->src->flags & OSW_TLV_F_DELTA) == 0);
+    const bool skip_null = (need_diff == true && op->diff_on_first == false);
+    const enum osw_tlv_type type = op->src->type;
+    osw_tlv_merge_add_fn_t *add_fn = osw_tlv_merge_add_fn_lookup(type);
+    osw_tlv_merge_sub_fn_t *sub_fn = osw_tlv_merge_sub_fn_lookup(type);
+
+    if (WARN_ON(add_fn == NULL)) return;
+    if (WARN_ON(sub_fn == NULL)) return;
+    if (op->prev[0] == NULL && skip_null == true) goto store;
+    if (op->dest[0] == NULL || op->dest[0]->len != op->src->len) {
+        void *data = osw_tlv_put(op->dest_tlv, op->src->id, op->src->type, op->src->len);
+        op->dest[0] = osw_tlv_get_hdr(data);
+        memset(data, 0, op->src->len);
+    }
+    const void *s = osw_tlv_get_data(op->src);
+    const void *p = op->prev[0] ? osw_tlv_get_data(*op->prev) : NULL;
+    void *d = osw_tlv_get_data(op->dest[0]);
+    add_fn(d, s);
+    if (p != NULL) sub_fn(d, p);
+store:
+    if (need_diff == false) return;
+    if (op->prev[0] == NULL) {
+        op->prev[0] = osw_tlv_get_hdr(osw_tlv_put_copy(op->prev_tlv, op->src));
+    }
+    else {
+        memcpy(osw_tlv_get_data(op->prev[0]),
+               osw_tlv_get_data(op->src),
+               op->src->len);
+    }
+}
+
+#if 0
+static void
+osw_tlv_merge_op_average_cb(const struct osw_tlv_merge_op *op)
+{
+}
+#endif
+
+static bool
+osw_tlv_merge_first_to_bool(const bool inherited,
+                            const enum osw_tlv_merge_first_policy f)
+{
+    switch (f) {
+        case OSW_TLV_INHERIT_FIRST: return inherited;
+        case OSW_TLV_DELTA_AGAINST_ZERO: return true;
+        case OSW_TLV_TWO_SAMPLES_MINIMUM: return false;
+    }
+    assert(0);
+    return true;
+}
+
+static void
+osw_tlv_merge_op_merge_cb(const struct osw_tlv_merge_op *op)
+{
+    const uint32_t id = op->src->id;
+    const enum osw_tlv_type type = op->src->type;
+
+    if (op->tpolicy == NULL) return;
+    if (op->mpolicy == NULL) return;
+    if (op->tpolicy[id].tb_size == 0) return;
+    if (op->tpolicy[id].tb_size != op->mpolicy[id].tb_size) return;
+    if (op->mpolicy[id].nested == NULL) return;
+    if (WARN_ON(type != OSW_TLV_NESTED)) return;
+
+    const struct osw_tlv_policy *tpolicy = op->tpolicy[id].nested;
+    const struct osw_tlv_merge_policy *mpolicy = op->mpolicy[id].nested;
+    const size_t tb_size = op->tpolicy[id].tb_size;
+    const bool diff_on_first = osw_tlv_merge_first_to_bool(op->diff_on_first,
+                                                           op->mpolicy[id].first);
+    struct osw_tlv dest_tmp = {0};
+    struct osw_tlv prev_tmp = {0};
+    osw_tlv_merge_clone(&dest_tmp, *op->dest);
+    osw_tlv_merge_clone(&prev_tmp, *op->prev);
+
+    osw_tlv_merge(&dest_tmp,
+                  &prev_tmp,
+                  osw_tlv_get_data(op->src),
+                  op->src->len,
+                  diff_on_first,
+                  tpolicy,
+                  mpolicy,
+                  tb_size);
+
+    osw_tlv_merge_replace(op->dest_tlv, op->dest, op->src, &dest_tmp);
+    osw_tlv_merge_replace(op->prev_tlv, op->prev, op->src, &prev_tmp);
+}
+
+static osw_tlv_merge_op_fn_t *
+osw_tlv_merge_op_fn_lookup(enum osw_tlv_merge_op_type t)
+{
+    switch (t) {
+        case OSW_TLV_OP_NONE: return osw_tlv_merge_op_none_cb;
+        case OSW_TLV_OP_OVERWRITE: return osw_tlv_merge_op_overwrite_cb;
+        case OSW_TLV_OP_ACCUMULATE: return osw_tlv_merge_op_accumulate_cb;
+        case OSW_TLV_OP_MERGE: return osw_tlv_merge_op_merge_cb;
+    }
+    assert(0);
+    return NULL;
+}
+
+void
+osw_tlv_merge(struct osw_tlv *dest_tlv,
+              struct osw_tlv *prev_tlv,
+              const void *data,
+              const size_t len,
+              const bool diff_on_first, // FIXME: invert the logic to skip_first_absolute
+              const struct osw_tlv_policy *tpolicy,
+              const struct osw_tlv_merge_policy *mpolicy,
+              const size_t tb_size)
+{
+    const struct osw_tlv_hdr *dtb[tb_size];
+    const struct osw_tlv_hdr *ntb[tb_size];
+    const struct osw_tlv_hdr *ptb[tb_size];
+    size_t i;
+    bool need_dest_repack = false;
+    bool need_prev_repack = false;
+
+    if (mpolicy == NULL) return;
+
+    memset(dtb, 0, tb_size * sizeof(*dtb));
+    memset(ntb, 0, tb_size * sizeof(*ntb));
+    memset(ptb, 0, tb_size * sizeof(*ptb));
+
+    osw_tlv_parse(dest_tlv->data, dest_tlv->used, tpolicy, dtb, tb_size);
+    osw_tlv_parse(prev_tlv->data, prev_tlv->used, tpolicy, ptb, tb_size);
+    osw_tlv_parse(data, len, tpolicy, ntb, tb_size);
+
+    /* FIXME: This should check if OSW_TLV_OP_ACCUMULATE
+     * tags are overflowing in an unexpected way. IOW if
+     * something seems to have started to report counters
+     * "from zero" then the "last" cache needs to be dropped
+     * and the delta from absolute values needs to be
+     * counted from scratch on _next_ sample. This would
+     * handle things like STA connects gracefully and
+     * automatically in most cases.
+    */
+
+    for (i = 0; i < tb_size; i++) {
+        if (ntb[i] == NULL) continue;
+        if (ptb[i] != NULL && ptb[i]->type != ntb[i]->type) continue;
+
+        if (dtb[i] != NULL &&
+            (dtb[i]->type != ntb[i]->type ||
+             dtb[i]->len != ntb[i]->len)) {
+            dtb[i] = NULL;
+            need_dest_repack = true;
+        }
+
+        const bool first = osw_tlv_merge_first_to_bool(diff_on_first,
+                                                       mpolicy[i].first);
+        const enum osw_tlv_merge_op_type optype = mpolicy[i].type;
+        const struct osw_tlv_hdr *old_dest = dtb[i];
+        const struct osw_tlv_hdr *old_prev = ptb[i];
+        const struct osw_tlv_merge_op op = {
+            .dest_tlv = dest_tlv,
+            .prev_tlv = prev_tlv,
+            .dest = &dtb[i],
+            .diff_on_first = first,
+            .src = ntb[i],
+            .prev = &ptb[i],
+            .tpolicy = tpolicy,
+            .mpolicy = mpolicy,
+        };
+        osw_tlv_merge_op_fn_t *op_fn = osw_tlv_merge_op_fn_lookup(optype);
+
+        if (WARN_ON(op_fn == NULL)) continue;
+        op_fn(&op);
+
+        if (old_dest != dtb[i]) need_dest_repack = true;
+        if (old_prev != ptb[i]) need_prev_repack = true;
+    }
+
+    if (need_dest_repack == true)
+        osw_tlv_merge_repack(dest_tlv, dtb, tb_size);
+
+    if (need_prev_repack == true)
+        osw_tlv_merge_repack(prev_tlv, ptb, tb_size);
+}
+
+#include "osw_tlv_merge_ut.c.h"
Index: core/src/lib/osw/src/osw_tlv_merge_ut.c.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_tlv_merge_ut.c.h
@@ -0,0 +1,589 @@
+#include <osw_ut.h>
+
+OSW_UT(osw_tlv_merge_delta)
+{
+    enum {
+        STATI,
+        STATF,
+        STATS,
+        STATN,
+        STATMAX,
+    };
+    enum {
+        NESTI,
+        NESTF,
+        NESTMAX,
+    };
+    const struct osw_tlv_policy pn[NESTMAX] = {
+        [NESTI] = { .type = OSW_TLV_U32 },
+        [NESTF] = { .type = OSW_TLV_FLOAT },
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_U32 },
+        [STATF] = { .type = OSW_TLV_FLOAT },
+        [STATS] = { .type = OSW_TLV_STRING },
+        [STATN] = { .type = OSW_TLV_NESTED, .nested = pn, .tb_size = NESTMAX },
+    };
+    const struct osw_tlv_merge_policy p2n[NESTMAX] = {
+        [NESTI] = { .type = OSW_TLV_OP_ACCUMULATE },
+        [NESTF] = { .type = OSW_TLV_OP_ACCUMULATE },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_OP_ACCUMULATE },
+        [STATF] = { .type = OSW_TLV_OP_ACCUMULATE },
+        [STATS] = { .type = OSW_TLV_OP_OVERWRITE },
+        [STATN] = { .type = OSW_TLV_OP_MERGE, .nested = p2n, .tb_size = NESTMAX },
+    };
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    osw_tlv_put_u32_delta(&src, STATI, 1);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used > 0);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATF] == NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 1);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(prev.data, prev.used, p, tb, STATMAX);
+        assert(tb[STATI] == NULL);
+    }
+
+    osw_tlv_put_u32_delta(&src, STATI, 2);
+    /* diff_on_first for delta should be no-op */
+    osw_tlv_merge(&dest, &prev, src.data, src.used, true, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 3);
+    }
+
+    {
+        void *start = osw_tlv_put_nested(&src, STATN);
+        osw_tlv_put_float_delta(&src, NESTF, 0.5);
+        osw_tlv_end_nested(&src, start);
+        osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+        osw_tlv_fini(&src);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATN] != NULL);
+        const struct osw_tlv_hdr *n = tb[STATN];
+
+        {
+            const struct osw_tlv_hdr *tb[STATMAX] = {0};
+            osw_tlv_parse(osw_tlv_get_data(n), n->len, pn, tb, STATMAX);
+            assert(tb[NESTI] == NULL);
+            assert(tb[NESTF] != NULL);
+            assert(osw_tlv_get_float(tb[NESTF]) == 0.5);
+        }
+    }
+
+    {
+        void *start = osw_tlv_put_nested(&src, STATN);
+        osw_tlv_put_u32_delta(&src, NESTI, 10);
+        osw_tlv_end_nested(&src, start);
+        osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+        osw_tlv_fini(&src);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATN] != NULL);
+        const struct osw_tlv_hdr *n = tb[STATN];
+
+        {
+            const struct osw_tlv_hdr *tb[STATMAX] = {0};
+            osw_tlv_parse(osw_tlv_get_data(n), n->len, pn, tb, STATMAX);
+            assert(tb[NESTI] != NULL);
+            assert(tb[NESTF] != NULL);
+            assert(osw_tlv_get_u32(tb[NESTI]) == 10);
+            assert(osw_tlv_get_float(tb[NESTF]) == 0.5);
+        }
+    }
+
+    {
+        osw_tlv_put_string(&src, STATS, "hello");
+        osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+        osw_tlv_fini(&src);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATN] != NULL);
+        assert(tb[STATS] != NULL);
+        assert(strcmp(osw_tlv_get_string(tb[STATS]), "hello") == 0);
+    }
+
+    assert(prev.used == 0);
+}
+
+OSW_UT(osw_tlv_merge_absolute)
+{
+    enum {
+        STATI,
+        STATF,
+        STATS,
+        STATN,
+        STATMAX,
+    };
+    enum {
+        NESTI,
+        NESTF,
+        NESTMAX,
+    };
+    const struct osw_tlv_policy pn[NESTMAX] = {
+        [NESTI] = { .type = OSW_TLV_U32 },
+        [NESTF] = { .type = OSW_TLV_FLOAT },
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_U32 },
+        [STATF] = { .type = OSW_TLV_FLOAT },
+        [STATS] = { .type = OSW_TLV_STRING },
+        [STATN] = { .type = OSW_TLV_NESTED, .nested = pn, .tb_size = NESTMAX },
+    };
+    const struct osw_tlv_merge_policy p2n[NESTMAX] = {
+        [NESTI] = { .type = OSW_TLV_OP_ACCUMULATE },
+        [NESTF] = { .type = OSW_TLV_OP_ACCUMULATE },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_OP_ACCUMULATE },
+        [STATF] = { .type = OSW_TLV_OP_ACCUMULATE },
+        [STATS] = { .type = OSW_TLV_OP_OVERWRITE },
+        [STATN] = { .type = OSW_TLV_OP_MERGE, .nested = p2n, .tb_size = NESTMAX },
+    };
+
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    osw_tlv_put_u32(&src, STATI, 1);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used == 0);
+    assert(prev.used > 0);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] == NULL);
+        assert(tb[STATF] == NULL);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(prev.data, prev.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATF] == NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 1);
+    }
+
+    osw_tlv_put_u32(&src, STATI, 3);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used > 0);
+    assert(prev.used > 0);
+
+    /* this should increase delta to "2" (3-1) */
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 2);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(prev.data, prev.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 3);
+    }
+
+    osw_tlv_put_string(&src, STATS, "hello");
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATS] != NULL);
+        assert(strcmp(osw_tlv_get_string(tb[STATS]), "hello") == 0);
+    }
+
+    {
+        void *start = osw_tlv_put_nested(&src, STATN);
+        osw_tlv_put_u32(&src, NESTI, 10);
+        osw_tlv_end_nested(&src, start);
+        osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+        osw_tlv_fini(&src);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(prev.data, prev.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATN] != NULL);
+        const struct osw_tlv_hdr *n = tb[STATN];
+
+        {
+            const struct osw_tlv_hdr *tb[STATMAX] = {0};
+            osw_tlv_parse(osw_tlv_get_data(n), n->len, pn, tb, STATMAX);
+            assert(tb[NESTI] != NULL);
+            assert(osw_tlv_get_u32(tb[NESTI]) == 10);
+        }
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATN] == NULL);
+    }
+
+    {
+        void *start = osw_tlv_put_nested(&src, STATN);
+        osw_tlv_put_u32(&src, NESTI, 13);
+        osw_tlv_end_nested(&src, start);
+        osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+        osw_tlv_fini(&src);
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(prev.data, prev.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATN] != NULL);
+        const struct osw_tlv_hdr *n = tb[STATN];
+
+        {
+            const struct osw_tlv_hdr *tb[STATMAX] = {0};
+            osw_tlv_parse(osw_tlv_get_data(n), n->len, pn, tb, STATMAX);
+            assert(tb[NESTI] != NULL);
+            assert(osw_tlv_get_u32(tb[NESTI]) == 13);
+        }
+    }
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(tb[STATN] != NULL);
+        const struct osw_tlv_hdr *n = tb[STATN];
+
+        {
+            const struct osw_tlv_hdr *tb[STATMAX] = {0};
+            osw_tlv_parse(osw_tlv_get_data(n), n->len, pn, tb, STATMAX);
+            assert(tb[NESTI] != NULL);
+            assert(osw_tlv_get_u32(tb[NESTI]) == 3);
+        }
+    }
+}
+
+OSW_UT(osw_tlv_merge_absolute_first)
+{
+    enum {
+        STATI,
+        STATMAX,
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_U32 },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_OP_ACCUMULATE },
+    };
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    osw_tlv_put_u32(&src, STATI, 10);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, true, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used > 0);
+    assert(prev.used > 0);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 10);
+    }
+}
+
+OSW_UT(osw_tlv_merge_absolute_first_2samples)
+{
+    enum {
+        STATI,
+        STATMAX,
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_U32 },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_OP_ACCUMULATE, .first = OSW_TLV_TWO_SAMPLES_MINIMUM },
+    };
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    osw_tlv_put_u32(&src, STATI, 10);
+    /* `true` here is overridden with merge policy */
+    osw_tlv_merge(&dest, &prev, src.data, src.used, true, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used == 0);
+    assert(prev.used > 0);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] == NULL);
+    }
+
+    osw_tlv_put_u32(&src, STATI, 12);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, true, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used > 0);
+    assert(prev.used > 0);
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 2);
+    }
+}
+
+OSW_UT(osw_tlv_merge_absolute_nested_2samples)
+{
+    enum {
+        STATN,
+        STATMAX,
+    };
+    enum {
+        NESTI,
+        NESTMAX,
+    };
+    const struct osw_tlv_policy pn[NESTMAX] = {
+        [NESTI] = { .type = OSW_TLV_U32 },
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STATN] = { .type = OSW_TLV_NESTED,
+                    .nested = pn,
+                    .tb_size = NESTMAX },
+    };
+    const struct osw_tlv_merge_policy p2n[NESTMAX] = {
+        [NESTI] = { .type = OSW_TLV_OP_ACCUMULATE },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STATN] = { .type = OSW_TLV_OP_MERGE,
+                    .nested = p2n,
+                    .tb_size = NESTMAX,
+                    .first = OSW_TLV_TWO_SAMPLES_MINIMUM },
+    };
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    {
+        void *start = osw_tlv_put_nested(&src, STATN);
+        osw_tlv_put_u32(&src, NESTI, 10);
+        osw_tlv_end_nested(&src, start);
+    }
+    /* `true` here is overridden with merge policy */
+    osw_tlv_merge(&dest, &prev, src.data, src.used, true, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used == 0);
+    assert(prev.used > 0);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATN] == NULL);
+    }
+
+    {
+        void *start = osw_tlv_put_nested(&src, STATN);
+        osw_tlv_put_u32(&src, NESTI, 12);
+        osw_tlv_end_nested(&src, start);
+    }
+    /* `true` here is overridden with merge policy */
+    osw_tlv_merge(&dest, &prev, src.data, src.used, true, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+    assert(dest.used > 0);
+    assert(prev.used > 0);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATN] != NULL);
+
+        const struct osw_tlv_hdr *tb2[NESTMAX] = {0};
+        osw_tlv_parse(osw_tlv_get_data(tb[STATN]), tb[STATN]->len, pn, tb2, NESTMAX);
+        assert(tb2[NESTI] != NULL);
+        assert(osw_tlv_get_u32(tb2[NESTI]) == 2);
+    }
+}
+
+OSW_UT(osw_tlv_merge_overflow)
+{
+    enum {
+        STATI,
+        STATMAX,
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_U32 },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STATI] = { .type = OSW_TLV_OP_ACCUMULATE },
+    };
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    uint32_t i = 0xffffffff;
+    osw_tlv_put_u32(&prev, STATI, i);
+
+    osw_tlv_put_u32(&src, STATI, 2);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI] != NULL);
+        assert(osw_tlv_get_u32(tb[STATI]) == 3);
+    }
+}
+
+OSW_UT(osw_tlv_merge_optype)
+{
+    enum {
+        STATI1,
+        STATI2,
+        STATI3,
+        STATI4,
+        STATMAX,
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STATI1] = { .type = OSW_TLV_U32 },
+        [STATI2] = { .type = OSW_TLV_U32 },
+        [STATI3] = { .type = OSW_TLV_U32 },
+        [STATI4] = { .type = OSW_TLV_U32 },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STATI1] = { .type = OSW_TLV_OP_NONE },
+        [STATI2] = { .type = OSW_TLV_OP_OVERWRITE },
+        [STATI3] = { .type = OSW_TLV_OP_ACCUMULATE },
+        [STATI4] = { .type = OSW_TLV_OP_MERGE },
+    };
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    /* note: STATI4 should generate a WARN_ON(), can't check it here */
+
+    osw_tlv_put_u32_delta(&src, STATI1, 1);
+    osw_tlv_put_u32_delta(&src, STATI2, 2);
+    osw_tlv_put_u32_delta(&src, STATI3, 3);
+    osw_tlv_put_u32_delta(&src, STATI4, 4);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI1] == NULL);
+        assert(tb[STATI2] != NULL);
+        assert(tb[STATI3] != NULL);
+        assert(tb[STATI4] == NULL);
+        assert(osw_tlv_get_u32(tb[STATI2]) == 2);
+        assert(osw_tlv_get_u32(tb[STATI3]) == 3);
+    }
+
+    osw_tlv_put_u32_delta(&src, STATI2, 4);
+    osw_tlv_put_u32_delta(&src, STATI3, 6);
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    {
+        const struct osw_tlv_hdr *tb[STATMAX] = {0};
+        osw_tlv_parse(dest.data, dest.used, p, tb, STATMAX);
+        assert(tb[STATI1] == NULL);
+        assert(tb[STATI2] != NULL);
+        assert(tb[STATI3] != NULL);
+        assert(tb[STATI4] == NULL);
+        assert(osw_tlv_get_u32(tb[STATI2]) == 4);
+        assert(osw_tlv_get_u32(tb[STATI3]) == (3 + 6));
+    }
+}
+
+OSW_UT(osw_tlv_merge_repack_str)
+{
+    enum {
+        STAT1,
+        STATMAX,
+    };
+    const struct osw_tlv_policy p[STATMAX] = {
+        [STAT1] = { .type = OSW_TLV_STRING },
+    };
+    const struct osw_tlv_merge_policy p2[STATMAX] = {
+        [STAT1] = { .type = OSW_TLV_OP_OVERWRITE },
+    };
+
+    struct osw_tlv dest = {0};
+    struct osw_tlv prev = {0};
+    struct osw_tlv src = {0};
+
+    osw_tlv_put_string(&src, STAT1, "1234");
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    assert(dest.used > 0);
+    assert(prev.used == 0);
+
+    const size_t len1 = dest.used;
+
+    osw_tlv_put_string(&src, STAT1, "12345678");
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    assert(dest.used > 0);
+    assert(prev.used == 0);
+    assert(dest.used != len1);
+
+    const size_t len2 = dest.used;
+
+    osw_tlv_put_string(&src, STAT1, "1234");
+    osw_tlv_merge(&dest, &prev, src.data, src.used, false, p, p2, STATMAX);
+    osw_tlv_fini(&src);
+
+    assert(dest.used > 0);
+    assert(prev.used == 0);
+    assert(dest.used != len2);
+    assert(dest.used == len1);
+}
Index: core/src/lib/osw/src/osw_tlv_ut.c.h
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_tlv_ut.c.h
@@ -0,0 +1,226 @@
+#include <ev.h>
+#include <osw_ut.h>
+
+OSW_UT(osw_tlv_simple)
+{
+    struct osw_tlv t = {0};
+    const uint32_t ival = 1337;
+    const float fval = 0.5;
+    const char *sval = "hello";
+
+    /* out of order */
+    osw_tlv_put_string(&t, 2, sval);
+    osw_tlv_put_u32(&t, 0, ival);
+    osw_tlv_put_float(&t, 1, fval);
+    osw_tlv_put_buf(&t, 3, sval, 2); /* "he" */
+
+    const struct osw_tlv_hdr *tb[4] = {0};
+    const size_t n_tb = 4;
+    assert(OSW_TLV_PARSE(&t, NULL, tb, n_tb) == 0);
+    assert(tb[0] != NULL);
+    assert(tb[1] != NULL);
+    assert(tb[2] != NULL);
+    assert(tb[3] != NULL);
+    assert(tb[0]->type == OSW_TLV_U32);
+    assert(tb[1]->type == OSW_TLV_FLOAT);
+    assert(tb[2]->type == OSW_TLV_STRING);
+    assert(tb[3]->type == OSW_TLV_UNSPEC);
+    assert(osw_tlv_get_u32(tb[0]) == ival);
+    assert(osw_tlv_get_float(tb[1]) == fval);
+    assert(strcmp(osw_tlv_get_data(tb[2]), sval) == 0);
+    assert(strncmp(osw_tlv_get_data(tb[3]), sval, 2) == 0);
+    assert(tb[2]->len == (strlen(sval) + 1));
+    assert(tb[3]->len == 2);
+    assert(OSW_TLV_FIND(&t, 0) == tb[0]);
+    assert(OSW_TLV_FIND(&t, 1) == tb[1]);
+    assert(OSW_TLV_FIND(&t, 2) == tb[2]);
+    assert(OSW_TLV_FIND(&t, 3) == tb[3]);
+}
+
+OSW_UT(osw_tlv_overlap)
+{
+    struct osw_tlv t = {0};
+    const uint32_t i1 = 0xdead;
+    const uint32_t i2 = 0xbeef;
+
+    /* out of order */
+    osw_tlv_put_u32(&t, 0, i1);
+    osw_tlv_put_u32(&t, 0, i2);
+
+    const struct osw_tlv_hdr *tb[2] = {0};
+    const size_t n_tb = 2;
+    assert(OSW_TLV_PARSE(&t, NULL, tb, n_tb) == 0);
+    assert(tb[0] != NULL);
+    assert(tb[1] == NULL);
+
+    /* the value at tail should shadow previous ones */
+    assert(osw_tlv_get_u32(tb[0]) != i1);
+    assert(osw_tlv_get_u32(tb[0]) == i2);
+}
+
+OSW_UT(osw_tlv_out_of_bounds)
+{
+    struct osw_tlv t = {0};
+    //const size_t hdr_len = sizeof(struct osw_tlv_hdr);
+    const uint32_t i1 = 0xdead;
+    const uint32_t i2 = 0xdead;
+    struct {
+        struct osw_tlv_hdr t1; uint32_t i1;
+        struct osw_tlv_hdr t2; uint32_t i2;
+    } __attribute__((packed)) buf = {
+        .t1 = {
+            .id = 0,
+            .type = OSW_TLV_U32,
+            .len = sizeof(i1),
+        },
+        .i1 = i1,
+        .t2 = {
+            .id = 1,
+            .type = OSW_TLV_U32,
+            .len = sizeof(i2),
+        },
+        .i2 = i2,
+    };
+
+    t.data = &buf;
+
+    /* sanity check */
+    t.used = sizeof(buf);
+    {
+        const struct osw_tlv_hdr *tb[2] = {0};
+        const size_t n_tb = 2;
+        assert(OSW_TLV_PARSE(&t, NULL, tb, n_tb) == 0);
+        assert(tb[0] != NULL);
+        assert(tb[1] != NULL);
+        assert(osw_tlv_get_u32(tb[0]) == i1);
+        assert(osw_tlv_get_u32(tb[1]) == i2);
+    }
+
+    /* intentional corruption, out of bounds on payload */
+    t.used = sizeof(buf) - 1;
+
+    {
+        const struct osw_tlv_hdr *tb[2] = {0};
+        const size_t n_tb = 2;
+        //assert(OSW_TLV_PARSE(&t, NULL, 0, tb, n_tb) == (hdr_len + 3));
+        assert(OSW_TLV_PARSE(&t, NULL, tb, n_tb) != 0);
+        assert(tb[0] != NULL);
+        assert(tb[1] == NULL);
+        assert(osw_tlv_get_u32(tb[0]) == i1);
+    }
+
+    /* intentional corruption, out of bounds on header */
+    t.used = sizeof(buf) - sizeof(i1) - 1;
+
+    {
+        const struct osw_tlv_hdr *tb[2] = {0};
+        const size_t n_tb = 2;
+        //assert(OSW_TLV_PARSE(&t, NULL, 0, tb, n_tb) == (hdr_len - 1));
+        assert(OSW_TLV_PARSE(&t, NULL, tb, n_tb) != 0);
+        assert(tb[0] != NULL);
+        assert(tb[1] == NULL);
+        assert(osw_tlv_get_u32(tb[0]) == i1);
+    }
+}
+
+OSW_UT(osw_tlv_mem)
+{
+    struct osw_tlv t = {0};
+    osw_tlv_put_u32(&t, 0, 1);
+    osw_tlv_fini(&t);
+    assert(t.data == NULL);
+    assert(t.size == 0);
+    assert(t.used == 0);
+}
+
+OSW_UT(osw_tlv_nested)
+{
+    struct osw_tlv t = {0};
+    const uint32_t i1 = 1337;
+
+    osw_tlv_put_u32(&t, 0, i1);
+    {
+        void *start = osw_tlv_put_nested(&t, 1);
+        osw_tlv_put_u32(&t, 0, 10);
+        osw_tlv_put_u32(&t, 1, 20);
+        osw_tlv_put_u32(&t, 2, 30);
+        osw_tlv_end_nested(&t, start);
+    }
+
+    const struct osw_tlv_hdr *t0 = OSW_TLV_FIND(&t, 0);
+    const struct osw_tlv_hdr *t1 = OSW_TLV_FIND(&t, 1);
+    assert(t0 != NULL);
+    assert(t1 != NULL);
+    assert(osw_tlv_get_u32(t0) == i1);
+
+    const void *nested = osw_tlv_get_data(t1);
+    assert(nested != NULL);
+    const size_t len = t1->len;
+    const struct osw_tlv_hdr *a0 = osw_tlv_find(nested, len, 0);
+    const struct osw_tlv_hdr *a1 = osw_tlv_find(nested, len, 1);
+    const struct osw_tlv_hdr *a2 = osw_tlv_find(nested, len, 2);
+    const struct osw_tlv_hdr *a3 = osw_tlv_find(nested, len, 3);
+    assert(a0 != NULL);
+    assert(a1 != NULL);
+    assert(a2 != NULL);
+    assert(a3 == NULL);
+    assert(osw_tlv_get_u32(a0) == 10);
+    assert(osw_tlv_get_u32(a1) == 20);
+    assert(osw_tlv_get_u32(a2) == 30);
+}
+
+OSW_UT(osw_tlv_policy)
+{
+    struct osw_tlv t = {0};
+
+    osw_tlv_put_u32(&t, 0, 0);
+    osw_tlv_put_float(&t, 1, 0.0f);
+    osw_tlv_put_string(&t, 2, "hello");
+    osw_tlv_put_float(&t, 3, 0.0f);
+
+    {
+        const struct osw_tlv_policy p[] = {
+            [0] = { .type = OSW_TLV_U32 },
+            [1] = { .type = OSW_TLV_FLOAT },
+            [2] = { .type = OSW_TLV_STRING },
+            [3] = { .type = OSW_TLV_U32 },
+        };
+        const struct osw_tlv_hdr *tb[4] = {0};
+        const size_t n_tb = 4;
+        assert(OSW_TLV_PARSE(&t, p, tb, n_tb) == 0);
+        assert(tb[0] != NULL);
+        assert(tb[1] != NULL);
+        assert(tb[2] != NULL);
+        assert(tb[3] == NULL);
+    }
+
+    {
+        const struct osw_tlv_policy p[4] = {
+            [2] = { .type = OSW_TLV_STRING, .min_len = 10, .max_len = 20 },
+        };
+        const struct osw_tlv_hdr *tb[4] = {0};
+        const size_t n_tb = 4;
+        assert(OSW_TLV_PARSE(&t, p, tb, n_tb) == 0);
+        assert(tb[2] == NULL);
+    }
+
+    {
+        const struct osw_tlv_policy p[4] = {
+            [2] = { .type = OSW_TLV_STRING, .min_len = 1, .max_len = 20 },
+        };
+        const struct osw_tlv_hdr *tb[4] = {0};
+        const size_t n_tb = 4;
+        assert(OSW_TLV_PARSE(&t, p, tb, n_tb) == 0);
+        assert(tb[2] != NULL);
+    }
+
+    {
+        const struct osw_tlv_policy p[4] = {
+            [2] = { .type = OSW_TLV_STRING, .min_len = 1, .max_len = 2 },
+        };
+        const struct osw_tlv_hdr *tb[4] = {0};
+        const size_t n_tb = 4;
+        assert(OSW_TLV_PARSE(&t, p, tb, n_tb) == 0);
+        assert(tb[2] == NULL);
+    }
+}
Index: core/src/lib/osw/src/osw_types.c
===================================================================
--- core.orig/src/lib/osw/src/osw_types.c
+++ core/src/lib/osw/src/osw_types.c
@@ -1,8 +1,100 @@
+#include <ev.h>
 #include <osw_types.h>
 #include <osw_ut.h>
-#include <module.h>
 #include <const.h>
 #include <util.h>
+#include <log.h>
+
+struct osw_op_class_matrix {
+    int op_class;
+    int start_freq_mhz;
+    enum osw_channel_width width;
+    int ctrl_chan[64];
+    int center_chan_idx[32];
+};
+
+#define OSW_OP_CLASS_END -1
+#define OSW_CHANNEL_END -2
+/*
+ * FIXME
+ * The OSW_CHANNEL_WILDCARD is a temporary hack because I don't know how verify
+ * channel for Operating Classes that don't have Channel Set defined in spec.
+ */
+#define OSW_CHANNEL_WILDCARD -3
+
+/*
+ * Combines "Table E-4Global operating classes" from:
+ * - IEEE Std 802.11-2020
+ * - IEEE Std 802.11ax-2021
+ */
+static const struct osw_op_class_matrix g_op_class_matrix[] = {
+    /* 2.4 GHz */
+    { 81, 2407, OSW_CHANNEL_20MHZ, { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, OSW_CHANNEL_END },
+                                   { OSW_CHANNEL_END }, },
+    { 82, 2414, OSW_CHANNEL_20MHZ, { 14, OSW_CHANNEL_END },
+                                   { OSW_CHANNEL_END }, },
+    { 83, 2407, OSW_CHANNEL_40MHZ, { 1, 2, 3, 4, 5, 6, 7, 8, 9, OSW_CHANNEL_END },
+                                   { OSW_CHANNEL_END }, },
+    { 84, 2407, OSW_CHANNEL_40MHZ, { 5, 6, 7, 8, 9, 10, 11, 12, 13, OSW_CHANNEL_END },
+                                   { OSW_CHANNEL_END }, },
+    /* 5 GHz */
+    { 115, 5000, OSW_CHANNEL_20MHZ, { 36, 40, 44, 48, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 116, 5000, OSW_CHANNEL_40MHZ, { 36, 44, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 117, 5000, OSW_CHANNEL_40MHZ, { 40, 48, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 118, 5000, OSW_CHANNEL_20MHZ, { 52, 56, 60, 64, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 119, 5000, OSW_CHANNEL_40MHZ, { 52, 60, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 120, 5000, OSW_CHANNEL_40MHZ, { 56, 64, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 121, 5000, OSW_CHANNEL_20MHZ, { 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 122, 5000, OSW_CHANNEL_40MHZ, { 100, 108, 116, 124, 132, 140, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 123, 5000, OSW_CHANNEL_40MHZ, { 104, 112, 120, 128, 136, 144, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 124, 5000, OSW_CHANNEL_20MHZ, { 149, 153, 157, 161, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 125, 5000, OSW_CHANNEL_20MHZ, { 149, 153, 157, 161, 165, 169, 173, 177, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 126, 5000, OSW_CHANNEL_40MHZ, { 149, 157, 165, 173, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 127, 5000, OSW_CHANNEL_40MHZ, { 153, 161, 169, 177, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 128, 5000, OSW_CHANNEL_80MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                    { 42, 58, 106, 122, 138, 155, 171, OSW_CHANNEL_END }, },
+    { 129, 5000, OSW_CHANNEL_160MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                     { 50, 114, 163, OSW_CHANNEL_END }, },
+    { 130, 5000, OSW_CHANNEL_80P80MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                       { 42, 58, 106, 122, 138, 155, 171, OSW_CHANNEL_END }, },
+    /* 6 GHz */
+    { 131, 5950, OSW_CHANNEL_20MHZ, { 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45,
+                                      49, 53, 57, 61, 65, 69, 73, 77, 81, 85, 89, 93,
+                                      97, 101, 105, 109, 113, 117, 121, 125, 129, 133,
+                                      137, 141, 145, 149, 153, 157, 161, 165, 169, 173,
+                                      177, 181, 185, 189, 193, 197, 201, 205, 209, 213,
+                                      217, 221, 225, 229, 233, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    { 132, 5950, OSW_CHANNEL_40MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                    { 3, 11, 19, 27, 35, 43, 51, 59, 67, 75, 83, 91, 99,
+                                      107, 115, 123, 131, 139, 147, 155, 163, 171, 179,
+                                      187, 195, 203, 211, 219, 227, OSW_CHANNEL_END }, },
+    { 133, 5950, OSW_CHANNEL_80MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                    { 7, 23, 39, 55, 71, 87, 103, 119, 135, 151, 167, 83,
+                                      199, 215, OSW_CHANNEL_END }, },
+    { 134, 5950, OSW_CHANNEL_160MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                     { 15, 47, 79, 111, 143, 175, 207, OSW_CHANNEL_END }, },
+    { 135, 5950, OSW_CHANNEL_80P80MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                       { 7, 23, 39, 55, 71, 87, 103, 119, 135, 151, 167, 83,
+                                         199, 215, OSW_CHANNEL_END }, },
+    { 136, 5925, OSW_CHANNEL_20MHZ, { OSW_CHANNEL_WILDCARD, OSW_CHANNEL_END },
+                                    { OSW_CHANNEL_END }, },
+    /* End */
+    { OSW_OP_CLASS_END, 0, 0, { OSW_CHANNEL_END, }, { OSW_CHANNEL_END } },
+};
 
 static void
 strip_trailing_whitespace(char *str)
@@ -12,6 +104,19 @@ strip_trailing_whitespace(char *str)
         *p = '\0';
 }
 
+int
+osw_ifname_cmp(const struct osw_ifname *a,
+               const struct osw_ifname *b)
+{
+    assert(a != NULL);
+    assert(b != NULL);
+
+    const size_t max_len = sizeof(a->buf);
+    WARN_ON(strnlen(a->buf, max_len) == max_len);
+    WARN_ON(strnlen(b->buf, max_len) == max_len);
+    return strncmp(a->buf, b->buf, max_len);
+}
+
 const char *
 osw_pmf_to_str(enum osw_pmf pmf)
 {
@@ -59,6 +164,19 @@ osw_channel_width_to_str(enum osw_channe
 }
 
 const char *
+osw_channel_dfs_state_to_str(enum osw_channel_state_dfs s)
+{
+    switch (s) {
+        case OSW_CHANNEL_NON_DFS: return "non_dfs";
+        case OSW_CHANNEL_DFS_CAC_POSSIBLE: return "cac_possible";
+        case OSW_CHANNEL_DFS_CAC_IN_PROGRESS: return "cac_in_progress";
+        case OSW_CHANNEL_DFS_CAC_COMPLETED: return "cac_completed";
+        case OSW_CHANNEL_DFS_NOL: return "nol";
+    }
+    return "";
+}
+
+const char *
 osw_radar_to_str(enum osw_radar_detect r)
 {
     switch (r) {
@@ -69,6 +187,18 @@ osw_radar_to_str(enum osw_radar_detect r
     return "";
 }
 
+const char *
+osw_band_to_str(enum osw_band b)
+{
+    switch (b) {
+        case OSW_BAND_UNDEFINED: return "undefined";
+        case OSW_BAND_2GHZ: return "2ghz";
+        case OSW_BAND_5GHZ: return "5ghz";
+        case OSW_BAND_6GHZ: return "6ghz";
+    }
+    return "";
+}
+
 void
 osw_wpa_to_str(char *out, size_t len, const struct osw_wpa *wpa)
 {
@@ -276,79 +406,73 @@ osw_hwaddr_cmp(const struct osw_hwaddr *
     return memcmp(addr_a, addr_b, sizeof(struct osw_hwaddr));
 }
 
-static void
-osw_types_ut_2g_chan_list_cb(void *data)
-{
-    const int *list;
+bool
+osw_channel_from_op_class(int op_class,
+                          int channel_num,
+                          struct osw_channel *channel)
+{
+    assert(channel != NULL);
+
+    const struct osw_op_class_matrix* entry;
+    for (entry = g_op_class_matrix; entry->op_class != OSW_OP_CLASS_END; entry++)
+        if (entry->op_class == op_class)
+            break;
+
+    if (entry->op_class == OSW_OP_CLASS_END)
+        return false;
+
+    const int *ctrl_chan;
+    for (ctrl_chan = entry->ctrl_chan; *ctrl_chan != OSW_CHANNEL_END; ctrl_chan++) {
+        if (*ctrl_chan == channel_num)
+            break;
+        if (*ctrl_chan == OSW_CHANNEL_WILDCARD)
+            break;
+    }
 
-    list = osw_2g_chan_list(1, 20, 11);
-    assert(list != NULL);
-    assert(list[0] == 1);
-    assert(list[1] == 0);
-
-    list = osw_2g_chan_list(11, 20, 11);
-    assert(list != NULL);
-    assert(list[0] == 11);
-    assert(list[1] == 0);
-
-    list = osw_2g_chan_list(13, 20, 13);
-    assert(list != NULL);
-    assert(list[0] == 13);
-    assert(list[1] == 0);
-
-    list = osw_2g_chan_list(13, 20, 11);
-    assert(list == NULL);
-
-    list = osw_2g_chan_list(1, 40, 11);
-    assert(list != NULL);
-    assert(list[0] == 1);
-    assert(list[1] == 5);
-    assert(list[2] == 0);
-
-    /* Current expectation is that HT40+ is always preferred
-     * until it is not possible to do, at which point HT40-
-     * should be returned.
-     */
-    list = osw_2g_chan_list(6, 40, 11);
-    assert(list != NULL);
-    assert(list[0] == 6);
-    assert(list[1] == 10);
-    assert(list[2] == 0);
-
-    list = osw_2g_chan_list(11, 40, 11);
-    assert(list != NULL);
-    assert(list[0] == 7);
-    assert(list[1] == 11);
-    assert(list[2] == 0);
-
-    list = osw_2g_chan_list(13, 40, 11);
-    assert(list == NULL);
-
-    list = osw_2g_chan_list(9, 40, 11);
-    assert(list != NULL);
-    assert(list[0] == 5);
-    assert(list[1] == 9);
-    assert(list[2] == 0);
-
-    list = osw_2g_chan_list(9, 40, 13);
-    assert(list != NULL);
-    assert(list[0] == 9);
-    assert(list[1] == 13);
-    assert(list[2] == 0);
+    if (*ctrl_chan == OSW_CHANNEL_END)
+        return false;
+
+    memset(channel, 0, sizeof(*channel));
+    channel->width = entry->width;
+    channel->control_freq_mhz = entry->start_freq_mhz + (channel_num * 5);
 
+    return true;
 }
 
-static void
-osw_types_ut_module_init_cb(void *data)
+bool
+osw_freq_is_dfs(int freq_mhz)
 {
-    osw_ut_register("osw_types_ut_2g_chan_list", osw_types_ut_2g_chan_list_cb, NULL);
+    static const int dfs_freqs[] = {
+        5260, 5280, 5300, 5320, /* 52-64 */
+        5500, 5520, 5540, 5560, /* 100-112 */
+        5580, 5600, 5620, 5640, /* 116-128 */
+        5660, 5680, 5700, 5720, /* 132-144 */
+    };
+    size_t i;
+    for (i = 0; i < ARRAY_SIZE(dfs_freqs); i++) {
+        if (dfs_freqs[i] == freq_mhz)
+            return true;
+    }
+    return false;
 }
 
-static void
-osw_types_ut_module_fini_cb(void *data)
+bool
+osw_channel_overlaps_dfs(const struct osw_channel *c)
 {
+    /* max 2GHz channel doesn't matter for this check so any
+     * value, including 11, is perfectly fine.
+     */
+    const int max_2g_chan = 11;
+    const enum osw_band b = osw_freq_to_band(c->control_freq_mhz);
+    const int w = osw_channel_width_to_mhz(c->width);
+    const int cn = osw_freq_to_chan(c->control_freq_mhz);
+    const int *chans = osw_channel_sidebands(b, cn, w, max_2g_chan);
+    while (chans != NULL && *chans != 0) {
+        const int freq = osw_chan_to_freq(b, *chans);
+        if (osw_freq_is_dfs(freq) == true) return true;
+        chans++;
+    }
+    return false;
 }
 
-MODULE(osw_types_ut_module,
-       osw_types_ut_module_init_cb,
-       osw_types_ut_module_fini_cb);
+#include "osw_types_ut.c"
Index: core/src/lib/osw/src/osw_types_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_types_ut.c
@@ -0,0 +1,120 @@
+#include <osw_ut.h>
+
+static void
+osw_channel_ut_init(struct osw_channel *channel,
+                    enum osw_channel_width width,
+                    int control_freq_mhz)
+{
+    assert(channel != NULL);
+
+    memset(channel, 0, sizeof(*channel));
+    channel->width = width;
+    channel->control_freq_mhz = control_freq_mhz;
+}
+
+OSW_UT(osw_channel_ut_from_op_class) {
+    struct osw_channel ref_channel;
+    struct osw_channel channel;
+    bool result;
+
+    /* op_class: 81, channel: 2 */
+    osw_channel_ut_init(&ref_channel, OSW_CHANNEL_20MHZ, 2417);
+    result = osw_channel_from_op_class(81, 2, &channel);
+    OSW_UT_EVAL(result == true);
+    OSW_UT_EVAL(memcmp(&ref_channel, &channel, sizeof(ref_channel)) == 0);
+
+    /* op_class: 82, channel: 5 (invalid)*/
+    result = osw_channel_from_op_class(82, 5, &channel);
+    OSW_UT_EVAL(result == false);
+
+    /* op_class: 128, channel: 36 (best effort) FIXME is it "good enough" */
+    osw_channel_ut_init(&ref_channel, OSW_CHANNEL_80MHZ, 5180);
+    result = osw_channel_from_op_class(128, 36, &channel);
+    OSW_UT_EVAL(result == true);
+    OSW_UT_EVAL(memcmp(&ref_channel, &channel, sizeof(ref_channel)) == 0);
+
+    /* op_class: 131, channel: 9 */
+    osw_channel_ut_init(&ref_channel, OSW_CHANNEL_20MHZ, 5995);
+    result = osw_channel_from_op_class(131, 9, &channel);
+    OSW_UT_EVAL(result == true);
+    OSW_UT_EVAL(memcmp(&ref_channel, &channel, sizeof(ref_channel)) == 0);
+}
+
+OSW_UT(osw_types_ut_2g_chan_list)
+{
+    const int *list;
+
+    list = osw_2g_chan_list(1, 20, 11);
+    assert(list != NULL);
+    assert(list[0] == 1);
+    assert(list[1] == 0);
+
+    list = osw_2g_chan_list(11, 20, 11);
+    assert(list != NULL);
+    assert(list[0] == 11);
+    assert(list[1] == 0);
+
+    list = osw_2g_chan_list(13, 20, 13);
+    assert(list != NULL);
+    assert(list[0] == 13);
+    assert(list[1] == 0);
+
+    list = osw_2g_chan_list(13, 20, 11);
+    assert(list == NULL);
+
+    list = osw_2g_chan_list(1, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 1);
+    assert(list[1] == 5);
+    assert(list[2] == 0);
+
+    /* Current expectation is that HT40+ is always preferred
+     * until it is not possible to do, at which point HT40-
+     * should be returned.
+     */
+    list = osw_2g_chan_list(6, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 6);
+    assert(list[1] == 10);
+    assert(list[2] == 0);
+
+    list = osw_2g_chan_list(11, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 7);
+    assert(list[1] == 11);
+    assert(list[2] == 0);
+
+    list = osw_2g_chan_list(13, 40, 11);
+    assert(list == NULL);
+
+    list = osw_2g_chan_list(9, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 5);
+    assert(list[1] == 9);
+    assert(list[2] == 0);
+
+    list = osw_2g_chan_list(9, 40, 13);
+    assert(list != NULL);
+    assert(list[0] == 9);
+    assert(list[1] == 13);
+    assert(list[2] == 0);
+}
+
+OSW_UT(osw_types_dfs_overlap)
+{
+    struct osw_channel non_dfs = {
+        .control_freq_mhz = 5180, /* ch36 */
+    };
+    struct osw_channel pri_dfs = {
+        .control_freq_mhz = 5300, /* ch60 */
+    };
+    struct osw_channel sb_dfs = {
+        .control_freq_mhz = 5180, /* ch36 @ 160MHz */
+        .width = OSW_CHANNEL_160MHZ,
+        .center_freq0_mhz = 5250, /* ch50 */
+    };
+
+    assert(osw_channel_overlaps_dfs(&non_dfs) == false);
+    assert(osw_channel_overlaps_dfs(&pri_dfs) == true);
+    assert(osw_channel_overlaps_dfs(&sb_dfs) == true);
+}
Index: core/src/lib/osw/src/osw_ut.c
===================================================================
--- core.orig/src/lib/osw/src/osw_ut.c
+++ core/src/lib/osw/src/osw_ut.c
@@ -3,11 +3,13 @@
 #include <sys/wait.h>
 #include <sys/types.h>
 #include <unistd.h>
-#include <ev.h>
 
 #include <util.h>
 #include <module.h>
 #include <const.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_drv_common.h>
 
 #include "osw_ut.h"
 #include "osw_drv_i.h"
@@ -17,6 +19,9 @@ struct osw_ut_module {
     char *file_name;
     char *fun_name;
     void *data;
+    char *output;
+    bool tested;
+    bool passed;
     osw_ut_module_run_f fun;
 
     struct osw_ut_module *next;
@@ -119,39 +124,132 @@ osw_ut_run_proc(struct osw_ut_proc *p, s
 }
 
 static void
-osw_ut_run_one(struct osw_ut_module *m, bool verbose)
-{
-    struct osw_ut_proc proc = {0};
-
-    proc.verbose = verbose;
-    if (verbose)
+osw_ut_run_one(struct osw_ut_module *m,
+               bool dont_fork,
+               bool verbose)
+{
+    m->tested = true;
+    if (dont_fork == true) {
+        m->passed = false;
         fprintf(stderr, "    RUN: %s: %s\n", m->file_name, m->fun_name);
-
-    osw_ut_run_proc(&proc, m);
-
-    if (WIFEXITED(proc.child.rstatus)) {
+        m->fun(m->data);
         fprintf(stderr, "   PASS: %s: %s\n", m->file_name, m->fun_name);
-    } else {
-        if (proc.output != NULL) fprintf(stderr, "%s", proc.output);
-        fprintf(stderr, "!!!FAIL: %s: %s (logs above)\n", m->file_name, m->fun_name);
+        m->passed = true;
     }
+    else {
+        struct osw_ut_proc proc = {0};
 
-    free(proc.output);
+        proc.verbose = verbose;
+        if (verbose)
+            fprintf(stderr, "    RUN: %s: %s\n", m->file_name, m->fun_name);
+
+        osw_ut_run_proc(&proc, m);
+
+        if (WIFEXITED(proc.child.rstatus)) {
+            if (verbose)
+                fprintf(stderr, "   PASS: %s: %s\n", m->file_name, m->fun_name);
+            m->passed = true;
+            free(proc.output);
+        } else {
+            if (verbose)
+                fprintf(stderr, "!!!FAIL: %s: %s (logs below)\n", m->file_name, m->fun_name);
+            m->passed = false;
+            m->output = proc.output;
+        }
+    }
 }
 
 void
-osw_ut_run_by_prefix(const char *prefix, bool verbose)
+osw_ut_run_by_prefix(const char *prefix,
+                     bool dont_fork,
+                     bool verbose)
 {
     struct osw_ut_module *m;
     for (m = g_modules; m != NULL; m = m->next)
-        if (strstr(m->fun_name, prefix) == m->fun_name)
-            osw_ut_run_one(m, verbose);
+        if (prefix == NULL || strstr(m->fun_name, prefix) == m->fun_name)
+            osw_ut_run_one(m, dont_fork, verbose);
+
+    int tested = 0;
+    int passed = 0;
+    for (m = g_modules; m != NULL; m = m->next) {
+        if (prefix == NULL || strstr(m->fun_name, prefix) == m->fun_name) {
+            if (m->tested) {
+                tested++;
+            }
+
+            if (m->passed == true) {
+               passed++;
+            }
+            else if (m->passed == false) {
+                fprintf(stderr, "LOGS: %s: %s:\n%s\n", m->file_name, m->fun_name, m->output ?: "");
+                free(m->output);
+            }
+        }
+    }
+
+    fprintf(stderr, "\n\n");
+
+    for (m = g_modules; m != NULL; m = m->next) {
+        if (prefix == NULL || strstr(m->fun_name, prefix) == m->fun_name) {
+            if (m->passed == false) {
+                fprintf(stderr, "FAIL: %s: %s (logs above)\n", m->file_name, m->fun_name);
+            }
+        }
+    }
+
+    fprintf(stderr, "UT: passed %d/%d, failed %d\n", passed, tested, (tested - passed));
 }
 
 void
-osw_ut_run_all(bool verbose)
+osw_ut_run_all(bool dont_fork,
+               bool verbose)
 {
+    osw_ut_run_by_prefix(NULL, dont_fork, verbose);
+}
+
+void
+osw_ut_print_test_names(void)
+{
+    unsigned int cnt = 0;
     struct osw_ut_module *m;
-    for (m = g_modules; m != NULL; m = m->next)
-        osw_ut_run_one(m, verbose);
+
+    printf("Test cases:\n");
+    for (m = g_modules; m != NULL; m = m->next) {
+        printf("    %s\n", m->fun_name);
+        cnt++;
+    }
+    printf("Number of test cases: %u\n", cnt);
+}
+
+
+void
+osw_ut_time_init(void)
+{
+    osw_time_set_mono_clk(0);
+    osw_time_set_wall_clk(0);
+}
+
+void
+osw_ut_time_advance(uint64_t delta_nsec)
+{
+    const uint64_t new_now_nsec = osw_time_mono_clk() + delta_nsec;
+    bool keep_running;
+
+    while (true) {
+        uint64_t next_at_nsec;
+
+        osw_timer_core_dispatch(osw_time_mono_clk());
+        keep_running = osw_timer_core_get_next_at(&next_at_nsec);
+        if (keep_running == false)
+            break;
+
+        if (next_at_nsec > new_now_nsec)
+            break;
+
+        osw_time_set_mono_clk(next_at_nsec);
+        osw_time_set_wall_clk(next_at_nsec);
+    }
+
+    osw_time_set_mono_clk(new_now_nsec);
+    osw_time_set_wall_clk(new_now_nsec);
 }
Index: core/src/lib/osw/src/osw_util.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_util.c
@@ -0,0 +1,53 @@
+#include <assert.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <string.h>
+#include <stdio.h>
+#include <endian.h>
+#include <osw_util.h>
+
+#define DOT11_EXTENDED_CAPS_TAG 0x7f
+#define DOT11_EXTENDED_CAPS_BTM 0x08
+
+#define DOT11_RM_ENABLED_CAPS_TAG 0x46
+#define DOT11_RM_ENABLED_CAPS_NEIGH_REPORT 0x02
+
+bool
+osw_parse_assoc_req_ies(const void *assoc_req_ies,
+                        size_t assoc_req_ies_len,
+                        struct osw_assoc_req_info *info)
+{
+    const struct element *elem;
+    const uint8_t *ies;
+    size_t len;
+
+    memset(info, 0, sizeof(*info));
+    ies = assoc_req_ies;
+    len = assoc_req_ies_len;
+
+    /* Capabilities Information (skip) */
+    if (len < sizeof(uint16_t)) return false;
+    ies += sizeof(uint16_t);
+    len -= sizeof(uint16_t);
+
+    /* Listen Interval (skip) */
+    if (len < sizeof(uint16_t)) return false;
+    ies += sizeof(uint16_t);
+    len -= sizeof(uint16_t);
+
+    for_each_ie(elem, ies, len) {
+        switch(elem->id) {
+            case DOT11_EXTENDED_CAPS_TAG:
+                info->wnm_bss_trans = (elem->data[2] & DOT11_EXTENDED_CAPS_BTM) != 0;
+                break;
+            case DOT11_RM_ENABLED_CAPS_TAG:
+                info->rrm_neighbor_report = (elem->data[0] & DOT11_RM_ENABLED_CAPS_NEIGH_REPORT) != 0;
+                break;
+        }
+    }
+
+    return true;
+}
+
+#include "osw_util_ut.c"
Index: core/src/lib/osw/src/osw_util_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/osw/src/osw_util_ut.c
@@ -0,0 +1,253 @@
+#include <log.h>
+#include <osw_ut.h>
+
+/*
+ * Frame 1 (this hexdump can be imported in WireShark)
+ * - no RRM Neighbor Report
+ * - no BSS Transition
+ * 0000   00 00 3a 01 02 00 00 00 03 00 02 00 00 00 00 00
+ * 0010   02 00 00 00 03 00 30 00 31 04 05 00 00 08 74 65
+ * 0020   73 74 2d 73 61 65 01 08 02 04 0b 16 0c 12 18 24
+ * 0030   32 04 30 48 60 6c 30 14 01 00 00 0f ac 04 01 00
+ * 0040   00 0f ac 04 01 00 00 0f ac 08 00 00 2d 1a 3c 10
+ * 0050   1b ff ff 00 00 00 00 00 00 00 00 00 00 01 00 00
+ * 0060   00 00 00 00 00 00 00 00 7f 0a 04 00 02 02 01 40
+ * 0070   00 40 00 01 3b 15 51 51 52 53 54 73 74 75 76 77
+ * 0080   78 79 7a 7b 7c 7d 7e 7f 80 81 82 dd 07 00 50 f2
+ * 0090   02 00 01 00
+ */
+const uint8_t osw_util_ut_non_11kv_assoc_ies[] = {
+    0x31, 0x04, 0x05, 0x00, 0x00, 0x08, 0x74, 0x65, 0x73, 0x74, 0x2d, 0x73, 0x61, 0x65, 0x01, 0x08,
+    0x02, 0x04, 0x0b, 0x16, 0x0c, 0x12, 0x18, 0x24, 0x32, 0x04, 0x30, 0x48, 0x60, 0x6c, 0x30, 0x14,
+    0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f,
+    0xac, 0x08, 0x00, 0x00, 0x2d, 0x1a, 0x3c, 0x10, 0x1b, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x7f, 0x0a, 0x04, 0x00, 0x02, 0x02, 0x01, 0x40, 0x00, 0x40, 0x00, 0x01, 0x3b, 0x15, 0x51, 0x51,
+    0x52, 0x53, 0x54, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+    0x80, 0x81, 0x82, 0xdd, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00
+};
+const size_t osw_util_ut_non_11kv_assoc_ies_len = sizeof(osw_util_ut_non_11kv_assoc_ies);
+
+/*
+ * Frame 2 (this hexdump can be imported in WireShark)
+ * - support RRM Neighbor Report
+ * - support BTM
+ * 0000   00 00 3c 00 fe 9f 07 00 dd 92 b6 2a 26 94 6a cf
+ * 0010   fe 9f 07 00 dd 92 70 86 11 11 14 00 00 05 43 78
+ * 0020   54 48 32 01 08 8c 12 98 24 b0 48 60 6c 21 02 f9
+ * 0030   15 24 0a 24 04 34 04 64 0c 95 04 a5 01 30 26 01
+ * 0040   00 00 0f ac 04 01 00 00 0f ac 04 01 00 00 0f ac
+ * 0050   08 cc 00 01 00 12 3c 42 86 4d 1d 68 a9 21 fe d9
+ * 0060   ef e7 59 91 7e 46 05 33 08 01 00 00 2d 1a 6f 00
+ * 0070   1b ff ff 00 00 00 00 00 00 00 00 00 00 00 00 00
+ * 0080   00 00 00 00 00 00 00 00 7f 08 00 00 08 00 00 00
+ * 0090   00 40 bf 0c 32 70 81 0f fa ff 00 00 fa ff 00 00
+ * 00a0   ff 1c 23 01 08 08 00 00 80 44 30 02 00 1d 00 9f
+ * 00b0   08 00 0c 00 fa ff fa ff 39 1c c7 71 1c 07 dd 0b
+ * 00c0   00 17 f2 0a 00 01 04 00 00 00 00 dd 05 00 90 4c
+ * 00d0   04 07 dd 0a 00 10 18 02 00 00 10 00 00 02 dd 07
+ * 00e0   00 50 f2 02 00 01 00
+ */
+const uint8_t osw_util_ut_11kv_assoc_ies[] = {
+    0x11, 0x11, 0x14, 0x00, 0x00, 0x05, 0x43, 0x78, 0x54, 0x48, 0x32, 0x01, 0x08, 0x8c, 0x12, 0x98,
+    0x24, 0xb0, 0x48, 0x60, 0x6c, 0x21, 0x02, 0xf9, 0x15, 0x24, 0x0a, 0x24, 0x04, 0x34, 0x04, 0x64,
+    0x0c, 0x95, 0x04, 0xa5, 0x01, 0x30, 0x26, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00,
+    0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x08, 0xcc, 0x00, 0x01, 0x00, 0x12, 0x3c, 0x42,
+    0x86, 0x4d, 0x1d, 0x68, 0xa9, 0x21, 0xfe, 0xd9, 0xef, 0xe7, 0x59, 0x91, 0x7e, 0x46, 0x05, 0x33,
+    0x08, 0x01, 0x00, 0x00, 0x2d, 0x1a, 0x6f, 0x00, 0x1b, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x7f, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x40, 0xbf, 0x0c, 0x32, 0x70, 0x81, 0x0f,
+    0xfa, 0xff, 0x00, 0x00, 0xfa, 0xff, 0x00, 0x00, 0xff, 0x1c, 0x23, 0x01, 0x08, 0x08, 0x00, 0x00,
+    0x80, 0x44, 0x30, 0x02, 0x00, 0x1d, 0x00, 0x9f, 0x08, 0x00, 0x0c, 0x00, 0xfa, 0xff, 0xfa, 0xff,
+    0x39, 0x1c, 0xc7, 0x71, 0x1c, 0x07, 0xdd, 0x0b, 0x00, 0x17, 0xf2, 0x0a, 0x00, 0x01, 0x04, 0x00,
+    0x00, 0x00, 0x00, 0xdd, 0x05, 0x00, 0x90, 0x4c, 0x04, 0x07, 0xdd, 0x0a, 0x00, 0x10, 0x18, 0x02,
+    0x00, 0x00, 0x10, 0x00, 0x00, 0x02, 0xdd, 0x07,  0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00
+};
+const size_t osw_util_ut_11kv_assoc_ies_len = sizeof(osw_util_ut_11kv_assoc_ies);
+
+OSW_UT(osw_util_ut_parse_assoc_req_ies) {
+    struct osw_assoc_req_info info;
+
+    /* Frame 1 */
+    OSW_UT_EVAL(osw_parse_assoc_req_ies(&osw_util_ut_non_11kv_assoc_ies, sizeof(osw_util_ut_non_11kv_assoc_ies), &info) == true);
+    OSW_UT_EVAL(info.wnm_bss_trans == false);
+    OSW_UT_EVAL(info.rrm_neighbor_report == false);
+
+    /* Frame 2 */
+    OSW_UT_EVAL(osw_parse_assoc_req_ies(&osw_util_ut_11kv_assoc_ies, sizeof(osw_util_ut_11kv_assoc_ies), &info) == true);
+    OSW_UT_EVAL(info.wnm_bss_trans == true);
+    OSW_UT_EVAL(info.rrm_neighbor_report == true);
+}
+
+OSW_UT(osw_util_ut_circ_buf_basic_usage) {
+    const size_t buf_size = 4;
+    int buf[buf_size];
+    size_t i;
+    bool result;
+    struct osw_circ_buf circ_buf;
+
+    /* Empty buffer */
+    osw_circ_buf_init(&circ_buf, buf_size);
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == true);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) == osw_circ_buf_tail(&circ_buf));
+
+    /* Push first element */
+    result = osw_circ_buf_push(&circ_buf, &i);
+    OSW_UT_EVAL(result == true);
+    buf[i] = 10;
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) != osw_circ_buf_tail(&circ_buf));
+
+    i = osw_circ_buf_head(&circ_buf);
+    OSW_UT_EVAL(buf[i] == 10);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(i == osw_circ_buf_tail(&circ_buf));
+
+    /* Push second element */
+    result = osw_circ_buf_push(&circ_buf, &i);
+    OSW_UT_EVAL(result == true);
+    buf[i] = 11;
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) != osw_circ_buf_tail(&circ_buf));
+
+    i = osw_circ_buf_head(&circ_buf);
+    OSW_UT_EVAL(buf[i] == 10);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 11);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(i == osw_circ_buf_tail(&circ_buf));
+
+    /* Push third element filling the buffer */
+    result = osw_circ_buf_push(&circ_buf, &i);
+    OSW_UT_EVAL(result == true);
+    buf[i] = 12;
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == true);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) != osw_circ_buf_tail(&circ_buf));
+
+    i = osw_circ_buf_head(&circ_buf);
+    OSW_UT_EVAL(buf[i] == 10);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 11);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 12);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(i == osw_circ_buf_tail(&circ_buf));
+
+    /* Push next value */
+    result = osw_circ_buf_push(&circ_buf, &i);
+    OSW_UT_EVAL(result == false);
+
+    i = osw_circ_buf_push_rotate(&circ_buf);
+    buf[i] = 13;
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == true);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) != osw_circ_buf_tail(&circ_buf));
+
+    i = osw_circ_buf_head(&circ_buf);
+    OSW_UT_EVAL(buf[i] == 11);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 12);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 13);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(i == osw_circ_buf_tail(&circ_buf));
+
+    /* Push one more value */
+    result = osw_circ_buf_push(&circ_buf, &i);
+    OSW_UT_EVAL(result == false);
+
+    i = osw_circ_buf_push_rotate(&circ_buf);
+    buf[i] = 14;
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == true);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) != osw_circ_buf_tail(&circ_buf));
+
+    i = osw_circ_buf_head(&circ_buf);
+    OSW_UT_EVAL(buf[i] == 12);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 13);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 14);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(i == osw_circ_buf_tail(&circ_buf));
+
+    /* Pop first value */
+    result = osw_circ_buf_pop(&circ_buf, &i);
+    OSW_UT_EVAL(result == true);
+    OSW_UT_EVAL(buf[i] == 12);
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) != osw_circ_buf_tail(&circ_buf));
+
+    i = osw_circ_buf_head(&circ_buf);
+    OSW_UT_EVAL(buf[i] == 13);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(buf[i] == 14);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(i == osw_circ_buf_tail(&circ_buf));
+
+    /* Pop second value */
+    result = osw_circ_buf_pop(&circ_buf, &i);
+    OSW_UT_EVAL(result == true);
+    OSW_UT_EVAL(buf[i] == 13);
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) != osw_circ_buf_tail(&circ_buf));
+
+    i = osw_circ_buf_head(&circ_buf);
+    OSW_UT_EVAL(buf[i] == 14);
+    i = osw_circ_buf_next(&circ_buf, i);
+    OSW_UT_EVAL(i == osw_circ_buf_tail(&circ_buf));
+
+    /* Pop last values */
+    result = osw_circ_buf_pop(&circ_buf, &i);
+    OSW_UT_EVAL(result == true);
+    OSW_UT_EVAL(buf[i] == 14);
+
+    OSW_UT_EVAL(osw_circ_buf_is_empty(&circ_buf) == true);
+    OSW_UT_EVAL(osw_circ_buf_is_full(&circ_buf) == false);
+    OSW_UT_EVAL(osw_circ_buf_head(&circ_buf) == osw_circ_buf_tail(&circ_buf));
+}
+
+OSW_UT(osw_util_ut_circ_buf_foreach_macro) {
+    const size_t buf_size = 4;
+    const int ref_buf[] = { 12, 13, 14, };
+    bool cmp_buf[] = { false, false, false, };
+    int buf[buf_size];
+    size_t ref_i;
+    size_t i;
+    struct osw_circ_buf circ_buf;
+
+    /* Init & fill buffer */
+    osw_circ_buf_init(&circ_buf, buf_size);
+
+    i = osw_circ_buf_push_rotate(&circ_buf);
+    buf[i] = 12;
+    i = osw_circ_buf_push_rotate(&circ_buf);
+    buf[i] = 13;
+    i = osw_circ_buf_push_rotate(&circ_buf);
+    buf[i] = 14;
+
+    /* Check macro */
+    ref_i = 0;
+    OSW_CIRC_BUF_FOREACH(&circ_buf, i) {
+        cmp_buf[ref_i] = buf[i] == ref_buf[ref_i];
+        ref_i++;
+    }
+
+    OSW_UT_EVAL(ref_i == 3);
+    OSW_UT_EVAL(cmp_buf[0] == true);
+    OSW_UT_EVAL(cmp_buf[1] == true);
+    OSW_UT_EVAL(cmp_buf[2] == true);
+}
Index: core/src/lib/osw/unit.mk
===================================================================
--- core.orig/src/lib/osw/unit.mk
+++ core/src/lib/osw/unit.mk
@@ -1,6 +1,6 @@
 ###############################################################################
 #
-# One Wi-Fi
+# Opensync Wireless API
 #
 ###############################################################################
 UNIT_NAME := osw
@@ -15,15 +15,29 @@ UNIT_SRC := src/osw_thread.c
 UNIT_SRC += src/osw_ut.c
 UNIT_SRC += src/osw_drv.c
 UNIT_SRC += src/osw_drv_dummy.c
-UNIT_SRC += src/osw_drv_target.c
+#UNIT_SRC += src/osw_drv_target.c
 UNIT_SRC += $(if $(wildcard $(PKG_CONFIG_SYSROOT_DIR)/usr/include/ccsp)$(wildcard $(UNIT_PATH)/inc/ccsp),src/osw_drv_wifihal_3_0.c,)
-UNIT_SRC += src/osw_req.c
 UNIT_SRC += src/osw_state.c
 UNIT_SRC += src/osw_conf.c
 UNIT_SRC += src/osw_confsync.c
 UNIT_SRC += src/osw_types.c
+UNIT_SRC += src/osw_bss_map.c
 UNIT_SRC += src/osw_mux.c
-UNIT_SRC += src/osw.c
+UNIT_SRC += src/osw_tlv.c
+UNIT_SRC += src/osw_tlv_merge.c
+UNIT_SRC += src/osw_module.c
+UNIT_SRC += src/osw_sampler.c
+UNIT_SRC += src/osw_stats_defs.c
+UNIT_SRC += src/osw_stats.c
+UNIT_SRC += src/osw_sta_cache.c
+UNIT_SRC += src/osw_btm.c
+UNIT_SRC += src/osw_rrm_meas.c
+UNIT_SRC += src/osw_throttle.c
+UNIT_SRC += src/osw_time.c
+UNIT_SRC += src/osw_timer.c
+UNIT_SRC += src/osw_util.c
+UNIT_SRC += src/osw_ev.c
+UNIT_SRC += src/osw_cqm.c
 
 UNIT_CFLAGS := -I$(UNIT_PATH)/inc
 
@@ -37,6 +51,8 @@ UNIT_CFLAGS += -DWIFI_HAL_VERSION_3
 
 UNIT_LDFLAGS := -lpthread
 UNIT_LDFLAGS += -lev
+UNIT_LDFLAGS += -lm
+
 
 UNIT_EXPORT_CFLAGS := $(UNIT_CFLAGS)
 UNIT_EXPORT_LDFLAGS := $(UNIT_LDFLAGS)
Index: core/src/lib/ow/inc/ow_conf_barrier.h
===================================================================
--- core.orig/src/lib/ow/inc/ow_conf_barrier.h
+++ core/src/lib/ow/inc/ow_conf_barrier.h
@@ -1,5 +1,5 @@
-#ifndef OW_CONF_BARRIER_H
-#define OW_CONF_BARRIER_H
+#ifndef OW_CONF_BARRIER_H_INCLUDED
+#define OW_CONF_BARRIER_H_INCLUDED
 
 /**
  * This function waits for configurations to be applied.
@@ -21,4 +21,4 @@
 int
 ow_conf_barrier_wait(int timeout_msec);
 
-#endif /* OW_CONF_BARRIER_H */
+#endif /* OW_CONF_BARRIER_H_INCLUDED */
Index: core/src/lib/ow/inc/ow_core.h
===================================================================
--- core.orig/src/lib/ow/inc/ow_core.h
+++ core/src/lib/ow/inc/ow_core.h
@@ -1,5 +1,5 @@
-#ifndef OW_CORE_H
-#define OW_CORE_H
+#ifndef OW_CORE_H_INCLUDED
+#define OW_CORE_H_INCLUDED
 
 #include <ev.h>
 
@@ -29,4 +29,4 @@ ow_core_init(EV_P);
 void
 ow_core_run(EV_P);
 
-#endif /* OW_CORE_H */
+#endif /* OW_CORE_H_INCLUDED */
Index: core/src/lib/ow/inc/ow_core_thread.h
===================================================================
--- core.orig/src/lib/ow/inc/ow_core_thread.h
+++ core/src/lib/ow/inc/ow_core_thread.h
@@ -1,5 +1,5 @@
-#ifndef OW_CORE_THREAD_H
-#define OW_CORE_THREAD_H
+#ifndef OW_CORE_THREAD_H_INCLUDED
+#define OW_CORE_THREAD_H_INCLUDED
 
 typedef void *ow_core_thread_call_fn_t(void *priv);
 
@@ -31,4 +31,4 @@ ow_core_thread_start(void);
 void *
 ow_core_thread_call(ow_core_thread_call_fn_t *fn, void *fn_priv);
 
-#endif /* OW_CORE_THREAD_H */
+#endif /* OW_CORE_THREAD_H_INCLUDED */
Index: core/src/lib/ow/inc/ow_stats_conf.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/inc/ow_stats_conf.h
@@ -0,0 +1,86 @@
+#ifndef OW_STATS_CONF_H_INCLUDED
+#define OW_STATS_CONF_H_INCLUDED
+
+struct ow_stats_conf;
+struct ow_stats_conf_entry;
+
+enum ow_stats_conf_scan_type {
+    OW_STATS_CONF_SCAN_TYPE_UNSPEC,
+    OW_STATS_CONF_SCAN_TYPE_ON_CHAN,
+    OW_STATS_CONF_SCAN_TYPE_OFF_CHAN,
+    OW_STATS_CONF_SCAN_TYPE_FULL,
+};
+
+enum ow_stats_conf_stats_type {
+    OW_STATS_CONF_STATS_TYPE_UNSPEC,
+    OW_STATS_CONF_STATS_TYPE_SURVEY,
+    OW_STATS_CONF_STATS_TYPE_NEIGHBOR,
+    OW_STATS_CONF_STATS_TYPE_CLIENT,
+};
+
+enum ow_stats_conf_radio_type {
+    OW_STATS_CONF_RADIO_TYPE_UNSPEC,
+    OW_STATS_CONF_RADIO_TYPE_2G,
+    OW_STATS_CONF_RADIO_TYPE_5G,
+    OW_STATS_CONF_RADIO_TYPE_5GL,
+    OW_STATS_CONF_RADIO_TYPE_5GU,
+    OW_STATS_CONF_RADIO_TYPE_6G,
+};
+
+struct ow_stats_conf *
+ow_stats_conf_get(void);
+
+struct ow_stats_conf_entry *
+ow_stats_conf_get_entry(struct ow_stats_conf *conf,
+                        const char *id);
+
+/**
+ * Marks all entries for a clean up in a same way
+ * ow_stats_conf_entry_reset() does.
+ *
+ *.Possible use case is for data models that do
+ * not signal removals and provide complete
+ * configurration sets every time they get
+ * updated.
+ */
+void
+ow_stats_conf_entry_reset_all(struct ow_stats_conf *conf);
+
+/**
+ * Marks an entry for removal. If any
+ * ow_stats_conf_entry_set_*() is called
+ * afterwards the entry will not be removed and if
+ * it gets set with identical parameters prior to
+ * reset it will amount to no-op as far as
+ * underlying work and internal states are
+ * concerned
+ */
+void
+ow_stats_conf_entry_reset(struct ow_stats_conf_entry *e);
+
+void
+ow_stats_conf_entry_set_sampling(struct ow_stats_conf_entry *e,
+                                 int seconds);
+
+void
+ow_stats_conf_entry_set_reporting(struct ow_stats_conf_entry *e,
+                                  int seconds);
+
+void
+ow_stats_conf_entry_set_radio_type(struct ow_stats_conf_entry *e,
+                                   enum ow_stats_conf_radio_type radio_type);
+
+void
+ow_stats_conf_entry_set_scan_type(struct ow_stats_conf_entry *e,
+                                   enum ow_stats_conf_scan_type scan_type);
+
+void
+ow_stats_conf_entry_set_stats_type(struct ow_stats_conf_entry *e,
+                                   enum ow_stats_conf_stats_type stats_type);
+
+void
+ow_stats_conf_entry_set_channels(struct ow_stats_conf_entry *e,
+                                 const int *channels,
+                                 size_t n_channels);
+
+#endif /* OW_STATS_CONF_H_INCLUDED */
Index: core/src/lib/ow/inc/ow_steer_bm.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/inc/ow_steer_bm.h
@@ -0,0 +1,141 @@
+#ifndef OW_STEER_BM_H
+#define OW_STEER_BM_H
+
+enum ow_steer_bm_client_pref_5g {
+    OW_STEER_BM_CLIENT_PREF_5G_NEVER,
+    OW_STEER_BM_CLIENT_PREF_5G_ALWAYS,
+};
+
+enum ow_steer_bm_client_kick_type {
+    OW_STEER_BM_CLIENT_KICK_TYPE_DEAUTH,
+    OW_STEER_BM_CLIENT_KICK_TYPE_BTM_DEAUTH,
+};
+
+struct ow_steer_bm_group;
+struct ow_steer_bm_vif;
+struct ow_steer_bm_client;
+struct ow_steer_bm_neighbor;
+struct ow_steer_bm_btm_params;
+
+struct ow_steer_bm_group*
+ow_steer_bm_get_group(const char *id);
+
+void
+ow_steer_bm_group_unset(struct ow_steer_bm_group *group);
+
+void
+ow_steer_bm_group_reset(struct ow_steer_bm_group *group);
+
+struct ow_steer_bm_vif*
+ow_steer_bm_group_get_vif(struct ow_steer_bm_group *group,
+                          const char *vif_name);
+
+void
+ow_steer_bm_vif_unset(struct ow_steer_bm_vif *vif);
+
+void
+ow_steer_bm_vif_reset(struct ow_steer_bm_vif *vif);
+
+struct ow_steer_bm_neighbor*
+ow_steer_bm_get_neighbor(const uint8_t *bssid);
+
+void
+ow_steer_bm_neighbor_unset(struct ow_steer_bm_neighbor *neighbor);
+
+void
+ow_steer_bm_neighbor_reset(struct ow_steer_bm_neighbor *neighbor);
+
+void
+ow_steer_bm_neighbor_set_vif_name(struct ow_steer_bm_neighbor *neighbor,
+                                  const char *vif_name);
+
+void
+ow_steer_bm_neighbor_set_channel_number(struct ow_steer_bm_neighbor *neighbor,
+                                        const uint8_t *channel_number);
+
+void
+ow_steer_bm_neighbor_set_op_class(struct ow_steer_bm_neighbor *neighbor,
+                                  const uint8_t *op_class);
+
+struct ow_steer_bm_client*
+ow_steer_bm_get_client(const uint8_t *addr);
+
+void
+ow_steer_bm_client_unset(struct ow_steer_bm_client *client);
+
+void
+ow_steer_bm_client_reset(struct ow_steer_bm_client *client);
+
+void
+ow_steer_bm_client_set_hwm(struct ow_steer_bm_client *client,
+                           const unsigned int *hwm);
+
+void
+ow_steer_bm_client_set_lwm(struct ow_steer_bm_client *client,
+                           const unsigned int *lwm);
+
+void
+ow_steer_bm_client_set_pref_5g(struct ow_steer_bm_client *client,
+                               const enum ow_steer_bm_client_pref_5g *pref_5g);
+
+void
+ow_steer_bm_client_set_kick_type(struct ow_steer_bm_client *client,
+                                 const enum ow_steer_bm_client_kick_type *kick_type);
+
+void
+ow_steer_bm_client_set_kick_upon_idle(struct ow_steer_bm_client *client,
+                                      const bool *kick_upon_idle);
+
+struct ow_steer_bm_btm_params*
+ow_steer_bm_client_get_sc_btm_params(struct ow_steer_bm_client *client);
+
+void
+ow_steer_bm_client_unset_sc_btm_params(struct ow_steer_bm_client *client);
+
+void
+ow_steer_bm_btm_params_reset(struct ow_steer_bm_btm_params *btm_params);
+
+void
+ow_steer_bm_btm_params_abridged(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *abridged);
+void
+ow_steer_bm_btm_params_bss_term(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *bss_term);
+void
+ow_steer_bm_btm_params_btm_max_retries(struct ow_steer_bm_btm_params *btm_params,
+                                       const uint8_t *btm_max_retries);
+void
+ow_steer_bm_btm_params_btm_retry_interval(struct ow_steer_bm_btm_params *btm_params,
+                                          const uint8_t *btm_retry_interval);
+void
+ow_steer_bm_btm_params_disassoc_imminent(struct ow_steer_bm_btm_params *btm_params,
+                                         const uint8_t *disassoc_imminent);
+void
+ow_steer_bm_btm_params_inc_neigh(struct ow_steer_bm_btm_params *btm_params,
+                                 const bool *inc_neigh);
+void
+ow_steer_bm_btm_params_pref(struct ow_steer_bm_btm_params *btm_params,
+                            const uint8_t *pref);
+void
+ow_steer_bm_btm_params_valid_interval(struct ow_steer_bm_btm_params *btm_params,
+                                      const uint8_t *valid_interval);
+void
+ow_steer_bm_btm_params_inc_self(struct ow_steer_bm_btm_params *btm_params,
+                                const bool *inc_self);
+void
+ow_steer_bm_btm_params_bssid(struct ow_steer_bm_btm_params *btm_params,
+                             const struct osw_hwaddr *bssid);
+void
+ow_steer_bm_btm_params_bssid_info(struct ow_steer_bm_btm_params *btm_params,
+                                  const uint32_t *bssid_info);
+void
+ow_steer_bm_btm_params_phy_type(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *phy_type);
+void
+ow_steer_bm_btm_params_channel(struct ow_steer_bm_btm_params *btm_params,
+                               const uint8_t *channel);
+void
+ow_steer_bm_btm_params_op_class(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *op_class);
+
+#endif /* OW_STEER_BM_H */
Index: core/src/lib/ow/inc/ow_webconfig.h
===================================================================
--- core.orig/src/lib/ow/inc/ow_webconfig.h
+++ core/src/lib/ow/inc/ow_webconfig.h
@@ -1,5 +1,5 @@
-#ifndef OW_WEBCONFIG_H
-#define OW_WEBCONFIG_H
+#ifndef OW_WEBCONFIG_H_INCLUDED
+#define OW_WEBCONFIG_H_INCLUDED
 
 #include <ccsp/wifi_hal.h>
 
Index: core/src/lib/ow/kconfig/Kconfig.libs
===================================================================
--- core.orig/src/lib/ow/kconfig/Kconfig.libs
+++ core/src/lib/ow/kconfig/Kconfig.libs
@@ -1,7 +1,14 @@
 menuconfig OW
-    bool "OneWifi Library (OW)"
+    bool "Opensync Wireless / One Wifi Library (OW)"
     default y
     help
-        This provides the bulk of OneWifi logic. It can be
-        used either in a single process via ow_core, or as a
-        thread via ow_core_thread.
+        This provides business logic for wireless related
+        operations in opensync.
+
+        This can be used by 3rd parties by linking to
+        libopensync.so, although care must be taken.
+
+        The library can be embedded into an existing libev
+        mainloop, or it can be used as a separate thread.
+        The later requires careful API accesses because most
+        calls are not thread safe.
Index: core/src/lib/ow/src/ow_acl_kick.c
===================================================================
--- core.orig/src/lib/ow/src/ow_acl_kick.c
+++ core/src/lib/ow/src/ow_acl_kick.c
@@ -6,6 +6,7 @@
 #include <osw_ut.h>
 #include <osw_state.h>
 #include <osw_mux.h>
+#include <osw_module.h>
 #include "ow_conf.h"
 
 /*
@@ -171,8 +172,7 @@ ow_acl_kick_init(struct ow_acl_kick *oak
     osw_state_register_observer(&oak->state_obs);
 }
 
-static void
-ow_acl_kick_ut_cb(void *data)
+OSW_UT(ow_acl_kick_ut)
 {
     const char *vif_name = "vif1";
     const struct osw_hwaddr addr1 = { .octet = {0,1,2,3,4,5} };
@@ -181,7 +181,7 @@ ow_acl_kick_ut_cb(void *data)
     const enum osw_acl_policy allow = OSW_ACL_ALLOW_LIST;
     const enum osw_acl_policy deny = OSW_ACL_DENY_LIST;
 
-    ow_conf_init();
+    osw_module_load_name("ow_conf");
 
     ow_conf_vif_set_ap_acl_policy(vif_name, &deny);
     ow_conf_vif_flush_ap_acl(vif_name);
@@ -214,18 +214,11 @@ ow_acl_kick_ut_cb(void *data)
     assert(ow_acl_kick_addr_is_allowed(vif_name, &addr2) == true);
 }
 
-static void
-ow_acl_kick_module_init_cb(void *data)
+OSW_MODULE(ow_acl_kick)
 {
+    OSW_MODULE_LOAD(ow_conf);
+    OSW_MODULE_LOAD(osw_state);
+    OSW_MODULE_LOAD(osw_mux);
     ow_acl_kick_init(&g_ow_acl_kick);
-    osw_ut_register("ow_acl_kick_ut", ow_acl_kick_ut_cb, NULL);
+    return NULL;
 }
-
-static void
-ow_acl_kick_module_fini_cb(void *data)
-{
-}
-
-MODULE(ow_acl_kick_module,
-       ow_acl_kick_module_init_cb,
-       ow_acl_kick_module_fini_cb);
Index: core/src/lib/ow/src/ow_conf.c
===================================================================
--- core.orig/src/lib/ow/src/ow_conf.c
+++ core/src/lib/ow/src/ow_conf.c
@@ -1,11 +1,11 @@
 #include <osw_thread.h>
 #include <osw_state.h>
+#include <osw_drv_common.h>
 #include <osw_conf.h>
 #include <osw_confsync.h>
-#include <osw_req.h>
+#include <osw_module.h>
 #include <osw_ut.h>
 #include <osw_drv_dummy.h>
-#include <osw.h>
 #include "ow_conf.h"
 #include <module.h>
 #include <memutil.h>
@@ -64,6 +64,15 @@ struct ow_conf_vif {
     int *ap_beacon_interval_tu;
     enum osw_pmf *ap_pmf;
     enum osw_acl_policy *ap_acl_policy;
+    struct ds_tree sta_net_tree;
+};
+
+struct ow_conf_net {
+    struct ds_tree_node node;
+    struct osw_ssid ssid;
+    struct osw_psk psk;
+    struct osw_hwaddr bssid;
+    struct osw_wpa wpa;
 };
 
 struct ow_conf_acl {
@@ -79,17 +88,9 @@ struct ow_conf_psk {
 
 struct ow_conf {
     struct osw_conf_mutator conf_mutator;
-    struct osw_conf_observer conf_observer;
-    struct osw_state_observer state_observer;
-    struct osw_confsync confsync;
-    ev_timer work;
     struct ds_tree phy_tree;
     struct ds_tree vif_tree;
     struct ds_dlist obs_list;
-    bool force;
-    bool cs_settled;
-    bool cs_idle;
-    bool settled;
 };
 
 static int
@@ -100,52 +101,6 @@ ow_conf_acl_cmp(const void *a, const voi
     return memcmp(x, y, sizeof(*x));
 }
 
-static void
-ow_conf_notify_agitated(struct ow_conf *c)
-{
-    struct ow_conf_observer *obs;
-    ds_dlist_foreach(&c->obs_list, obs)
-        if (obs->agitated_fn != NULL)
-            obs->agitated_fn(obs);
-}
-
-static void
-ow_conf_notify_settled(struct ow_conf *c)
-{
-    struct ow_conf_observer *obs;
-    ds_dlist_foreach(&c->obs_list, obs)
-        if (obs->settled_fn != NULL)
-            obs->settled_fn(obs);
-}
-
-static void
-ow_conf_notify(struct ow_conf *c, const bool settled)
-{
-    if (c->settled == settled) {
-        LOGD("ow: conf: settled not changed");
-        return;
-    }
-
-    if (settled == true) {
-        LOGI("ow: conf: settled");
-        ow_conf_notify_settled(c);
-    }
-
-    if (settled == false) {
-        LOGI("ow: conf: agitated");
-        ow_conf_notify_agitated(c);
-    }
-
-    c->settled = settled;
-}
-
-static void
-ow_conf_update_settled(struct ow_conf *c)
-{
-    const bool work_settled = !ev_is_active(&c->work);
-    ow_conf_notify(c, c->cs_settled && c->cs_idle && work_settled);
-}
-
 static struct ow_conf_phy *
 ow_conf_phy_alloc(struct ow_conf *self, const char *phy_name)
 {
@@ -175,6 +130,7 @@ ow_conf_vif_alloc(struct ow_conf *self,
     ds_tree_insert(&self->vif_tree, vif, vif->vif_name);
     ds_tree_init(&vif->ap_psk_tree, ds_int_cmp, struct ow_conf_psk, node);
     ds_tree_init(&vif->ap_acl_tree, ow_conf_acl_cmp, struct ow_conf_acl, node);
+    ds_tree_init(&vif->sta_net_tree, (ds_key_cmp_t *)osw_ssid_cmp, struct ow_conf_net, node);
     return vif;
 }
 
@@ -191,39 +147,6 @@ ow_conf_vif_get_ro(struct ow_conf *self,
 }
 
 static void
-ow_conf_work(struct ow_conf *self)
-{
-    struct osw_conf *conf = osw_conf_build();
-    struct osw_conf *state = osw_conf_build_from_state();
-    const bool force = self->force;
-    self->force = false;
-    osw_confsync_set(&self->confsync, conf, state, force);
-}
-
-static void
-ow_conf_work_cb(EV_P_ ev_timer *arg, int event)
-{
-    struct ow_conf *self = container_of(arg, struct ow_conf, work);
-    ow_conf_work(self);
-    ow_conf_update_settled(self);
-}
-
-static void
-ow_conf_work_schedule(struct ow_conf *self)
-{
-    ev_timer_start(EV_DEFAULT_ &self->work);
-    ow_conf_update_settled(self);
-}
-
-static void
-ow_conf_conf_mutated_cb(struct osw_conf_observer *observer)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, conf_observer);
-    self->force = true;
-    ow_conf_work_schedule(self);
-}
-
-static void
 ow_conf_conf_mutate_phy(struct ow_conf *self,
                         struct osw_conf_phy *osw_phy)
 {
@@ -244,9 +167,9 @@ ow_conf_conf_mutate_acl(struct ds_tree *
     struct ow_conf_acl *i;
 
     /* FIXME: differentiate between overwrite and append */
-    while ((i = ds_tree_head(out)) != NULL) {
-        ds_tree_remove(out, i);
-        FREE(i);
+    while ((p = ds_tree_head(out)) != NULL) {
+        ds_tree_remove(out, p);
+        FREE(p);
     }
 
     ds_tree_foreach(in, i) {
@@ -264,9 +187,9 @@ ow_conf_conf_mutate_psk(struct ds_tree *
     struct ow_conf_psk *i;
 
     /* FIXME: differentiate between overwrite and append */
-    while ((i = ds_tree_head(out)) != NULL) {
-        ds_tree_remove(out, i);
-        FREE(i);
+    while ((p = ds_tree_head(out)) != NULL) {
+        ds_tree_remove(out, p);
+        FREE(p);
     }
 
     ds_tree_foreach(in, i) {
@@ -321,6 +244,34 @@ ow_conf_conf_mutate_vif_ap(struct ow_con
 }
 
 static void
+ow_conf_conf_mutate_vif_sta(struct ow_conf_phy *ow_phy,
+                            struct ow_conf_vif *ow_vif,
+                            struct osw_conf_vif *osw_vif)
+{
+    struct ds_dlist *list = &osw_vif->u.sta.net_list;
+    struct osw_conf_net *osw_net;
+    struct ow_conf_net *net;
+
+    /* FIXME: It might be convenient to be able to declare
+     * whether the list is exhaustive or additive. If it
+     * additive it would only append to the list. Currently
+     * it's exhaustive and replaces the found  list.
+     */
+    while ((osw_net = ds_dlist_remove_head(list)) != NULL) {
+        FREE(osw_net);
+    }
+
+    ds_tree_foreach(&ow_vif->sta_net_tree, net) {
+        struct osw_conf_net *n = CALLOC(1, sizeof(*n));
+        memcpy(&n->ssid, &net->ssid, sizeof(n->ssid));
+        memcpy(&n->bssid, &net->bssid, sizeof(n->bssid));
+        memcpy(&n->psk, &net->psk, sizeof(n->psk));
+        memcpy(&n->wpa, &net->wpa, sizeof(n->wpa));
+        ds_dlist_insert_tail(list, n);
+    }
+}
+
+static void
 ow_conf_conf_mutate_vif(struct ow_conf *self,
                         struct osw_conf_vif *osw_vif)
 {
@@ -349,13 +300,14 @@ ow_conf_conf_mutate_vif(struct ow_conf *
         case OSW_VIF_AP_VLAN:
             break;
         case OSW_VIF_STA:
+            ow_conf_conf_mutate_vif_sta(ow_phy, ow_vif, osw_vif);
             break;
     }
 }
 
 static void
 ow_conf_conf_mutate_cb(struct osw_conf_mutator *mutator,
-                       struct osw_conf *conf)
+                       struct ds_tree *phy_tree)
 {
     struct ow_conf *self = container_of(mutator, struct ow_conf, conf_mutator);
     struct osw_conf_phy *osw_phy;
@@ -369,7 +321,7 @@ ow_conf_conf_mutate_cb(struct osw_conf_m
      * pre-allocated at the system integration level and
      * exposed by osw_drv implementation(s).
      */
-    ds_tree_foreach(&conf->phy_tree, osw_phy) {
+    ds_tree_foreach(phy_tree, osw_phy) {
         ow_conf_conf_mutate_phy(self, osw_phy);
 
         ds_tree_foreach(&osw_phy->vif_tree, osw_vif) {
@@ -378,115 +330,6 @@ ow_conf_conf_mutate_cb(struct osw_conf_m
     }
 }
 
-static void
-ow_conf_state_busy_cb(struct osw_state_observer *observer)
-{
-    LOGI("ow: conf: state: busy");
-}
-
-static void
-ow_conf_state_idle_cb(struct osw_state_observer *observer)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
-    struct osw_conf *conf = osw_conf_build();
-    struct osw_conf *state = osw_conf_build_from_state();
-    LOGI("ow: conf: state: idle");
-    osw_confsync_set(&self->confsync, conf, state, false);
-}
-
-static void
-ow_conf_state_phy_added_cb(struct osw_state_observer *observer,
-                           const struct osw_state_phy_info *phy)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
-    LOGI("ow: conf: state: %s: added", phy->phy_name);
-    ow_conf_work_schedule(self);
-}
-
-static void
-ow_conf_state_phy_changed_cb(struct osw_state_observer *observer,
-                             const struct osw_state_phy_info *phy)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
-    LOGI("ow: conf: state: %s: changed", phy->phy_name);
-    ow_conf_work_schedule(self);
-}
-
-static void
-ow_conf_state_phy_removed_cb(struct osw_state_observer *observer,
-                             const struct osw_state_phy_info *phy)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
-    LOGI("ow: conf: state: %s: removed", phy->phy_name);
-    ow_conf_work_schedule(self);
-}
-
-static void
-ow_conf_state_vif_added_cb(struct osw_state_observer *observer,
-                           const struct osw_state_vif_info *vif)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
-    LOGI("ow: conf: state: %s/%s: added", vif->phy->phy_name, vif->vif_name);
-    ow_conf_work_schedule(self);
-}
-
-static void
-ow_conf_state_vif_changed_cb(struct osw_state_observer *observer,
-                             const struct osw_state_vif_info *vif)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
-    LOGI("ow: conf: state: %s/%s: changed", vif->phy->phy_name, vif->vif_name);
-    ow_conf_work_schedule(self);
-}
-
-static void
-ow_conf_state_vif_removed_cb(struct osw_state_observer *observer,
-                             const struct osw_state_vif_info *vif)
-{
-    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
-    LOGI("ow: conf: state: %s/%s: removed", vif->phy->phy_name, vif->vif_name);
-    ow_conf_work_schedule(self);
-}
-
-static void
-ow_conf_agitated_cb(struct osw_confsync *cs)
-{
-    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
-    LOGD("ow: conf: confsync: agitated");
-    c->cs_settled = false;
-    ow_conf_update_settled(c);
-    /* FIXME: This could arm a watchdog to detect reconfig
-     * that is failing for too long. Maybe 5 minutes is a
-     * good limit. */
-}
-
-static void
-ow_conf_settled_cb(struct osw_confsync *cs)
-{
-    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
-    LOGD("ow: conf: confsync: settled");
-    c->cs_settled = true;
-    ow_conf_update_settled(c);
-}
-
-static void
-ow_conf_confsync_idle_cb(struct osw_confsync *cs)
-{
-    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
-    LOGD("ow: conf: confsync: idle");
-    c->cs_idle = true;
-    ow_conf_update_settled(c);
-}
-
-static void
-ow_conf_confsync_busy_cb(struct osw_confsync *cs)
-{
-    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
-    LOGD("ow: conf: confsync: busy");
-    c->cs_idle = false;
-    ow_conf_update_settled(c);
-}
-
 static struct ow_conf g_ow_conf = {
     .phy_tree = DS_TREE_INIT(ds_str_cmp, struct ow_conf_phy, node),
     .vif_tree = DS_TREE_INIT(ds_str_cmp, struct ow_conf_vif, node),
@@ -495,27 +338,6 @@ static struct ow_conf g_ow_conf = {
         .name ="ow_conf",
         .mutate_fn = ow_conf_conf_mutate_cb,
     },
-    .conf_observer = {
-        .name = "ow_conf",
-        .mutated_fn = ow_conf_conf_mutated_cb,
-    },
-    .state_observer = {
-        .name = "ow_conf",
-        .idle_fn = ow_conf_state_idle_cb,
-        .busy_fn = ow_conf_state_busy_cb,
-        .phy_added_fn = ow_conf_state_phy_added_cb,
-        .phy_changed_fn = ow_conf_state_phy_changed_cb,
-        .phy_removed_fn = ow_conf_state_phy_removed_cb,
-        .vif_added_fn = ow_conf_state_vif_added_cb,
-        .vif_changed_fn = ow_conf_state_vif_changed_cb,
-        .vif_removed_fn = ow_conf_state_vif_removed_cb,
-    },
-    .confsync = {
-        .agitated_fn = ow_conf_agitated_cb,
-        .settled_fn = ow_conf_settled_cb,
-        .idle_fn = ow_conf_confsync_idle_cb,
-        .busy_fn = ow_conf_confsync_busy_cb,
-    },
 };
 
 void
@@ -716,6 +538,55 @@ ow_conf_vif_flush_ap_acl(const char *vif
         ow_conf_vif_del_ap_acl(vif_name, &acl->mac_addr);
 }
 
+void
+ow_conf_vif_set_sta_net(const char *vif_name,
+                        const struct osw_ssid *ssid,
+                        const struct osw_hwaddr *bssid,
+                        const struct osw_psk *psk,
+                        const struct osw_wpa *wpa)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_net *net = ds_tree_find(&vif->sta_net_tree, ssid);
+
+    if (net == NULL) {
+        net = CALLOC(1, sizeof(*net));
+        memcpy(&net->ssid, ssid, sizeof(*ssid));
+        ds_tree_insert(&vif->sta_net_tree, net, &net->ssid);
+        LOGI("ow: conf: %s: net: adding: ssid=" OSW_SSID_FMT, vif_name, OSW_SSID_ARG(&net->ssid));
+    }
+
+    if (wpa != NULL) {
+        memset(&net->bssid, 0, sizeof(net->bssid));
+        memset(&net->psk, 0, sizeof(net->psk));
+        if (bssid != NULL) memcpy(&net->bssid, bssid, sizeof(*bssid));
+        if (psk != NULL) memcpy(&net->psk, psk, sizeof(*psk));
+        memcpy(&net->wpa, wpa, sizeof(*wpa));
+    }
+
+    if (wpa == NULL) {
+        LOGI("ow: conf: %s: net: removing: ssid=" OSW_SSID_FMT, vif_name, OSW_SSID_ARG(&net->ssid));
+        ds_tree_remove(&vif->sta_net_tree, net);
+        FREE(net);
+        net = NULL;
+    }
+
+    osw_conf_invalidate(&self->conf_mutator);
+    ow_conf_vif_notify_changed(vif_name);
+}
+
+void
+ow_conf_vif_flush_sta_net(const char *vif_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_net *net;
+
+    while ((net = ds_tree_head(&vif->sta_net_tree)) != NULL)
+        ow_conf_vif_set_sta_net(vif_name, &net->ssid, NULL, NULL, NULL);
+}
+
+
 #define DEFINE_FIELD(member, type, lookup_type, lookup, fn_set, fn_get, fn_notify, fmt, arg) \
     void fn_set(const char *key, const type *v) { \
         osw_thread_sanity_check(); \
@@ -897,6 +768,7 @@ ow_conf_vif_unset(const char *vif_name)
 
     ow_conf_vif_flush_ap_psk(vif_name);
     ow_conf_vif_flush_ap_acl(vif_name);
+    ow_conf_vif_flush_sta_net(vif_name);
 
     FREE(vif->phy_name);
     FREE(vif->vif_name);
@@ -939,7 +811,7 @@ bool
 ow_conf_is_settled(void)
 {
     if (osw_drv_work_is_settled() == false) return false;
-    if (osw_confsync_is_settled(&g_ow_conf.confsync) == false) return false;
+    if (osw_confsync_get_state(osw_confsync_get()) != OSW_CONFSYNC_IDLE) return false;
     return true;
 }
 
@@ -947,13 +819,9 @@ static void
 ow_conf_init_priv(struct ow_conf *self)
 {
     osw_conf_register_mutator(&self->conf_mutator);
-    osw_conf_register_observer(&self->conf_observer);
-    osw_state_register_observer(&self->state_observer);
-    osw_confsync_init(&self->confsync);
-    ev_timer_init(&self->work, ow_conf_work_cb, 0, 0);
 }
 
-void
+static void
 ow_conf_init(void)
 {
     static bool initialized;
@@ -1004,8 +872,7 @@ ow_conf_ut_phy_enabled_op_request_config
     osw_drv_conf_free(conf);
 }
 
-static void
-ow_conf_ut_phy_enabled_cb(void *data)
+OSW_UT(ow_conf_ut_phy_enabled)
 {
     struct osw_drv_dummy dummy = {
         .name = "phy_enabled",
@@ -1014,7 +881,7 @@ ow_conf_ut_phy_enabled_cb(void *data)
     bool enabled = true;
     const char *phy_name = "phy1";
 
-    osw_init();
+    osw_module_load_name("osw_drv");
     osw_drv_dummy_init(&dummy);
     ow_conf_init();
     ow_conf_ut_run();
@@ -1125,8 +992,7 @@ ow_conf_ut_vif_enabled_op_request_config
     osw_drv_conf_free(conf);
 }
 
-static void
-ow_conf_ut_vif_enabled_cb(void *data)
+OSW_UT(ow_conf_ut_vif_enabled)
 {
     struct osw_drv_dummy dummy = {
         .name = "vif_enabled",
@@ -1136,7 +1002,7 @@ ow_conf_ut_vif_enabled_cb(void *data)
     const char *phy_name = "phy1";
     const char *vif_name = "vif1";
 
-    osw_init();
+    osw_module_load_name("osw_drv");
     osw_drv_dummy_init(&dummy);
     ow_conf_init();
     ow_conf_ut_run();
@@ -1155,6 +1021,7 @@ ow_conf_ut_vif_enabled_cb(void *data)
     ow_conf_ut_run();
     assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == true);
 
+    LOGI("%s: disabling vif %s, expect disablement", __func__, vif_name);
     ow_conf_vif_set_phy_name(vif_name, phy_name);
     enabled = false; ow_conf_vif_set_enabled(vif_name, &enabled);
     ow_conf_ut_run();
@@ -1163,6 +1030,7 @@ ow_conf_ut_vif_enabled_cb(void *data)
     assert(*ow_conf_vif_get(&g_ow_conf, vif_name)->enabled == enabled);
     assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == enabled);
 
+    LOGI("%s: enabling vif %s, expect enablement", __func__, vif_name);
     enabled = true; ow_conf_vif_set_enabled(vif_name, &enabled);
     ow_conf_ut_run();
     assert(ow_conf_vif_get(&g_ow_conf, vif_name) != NULL);
@@ -1170,6 +1038,7 @@ ow_conf_ut_vif_enabled_cb(void *data)
     assert(*ow_conf_vif_get(&g_ow_conf, vif_name)->enabled == enabled);
     assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == enabled);
 
+    LOGI("%s: re-enabling vif %s, expect no-op", __func__, vif_name);
     enabled = false; ow_conf_vif_set_enabled(vif_name, &enabled);
     enabled = true; ow_conf_vif_set_enabled(vif_name, &enabled);
     ow_conf_ut_run();
@@ -1179,8 +1048,7 @@ ow_conf_ut_vif_enabled_cb(void *data)
     assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == enabled);
 }
 
-static void
-ow_conf_ut_is_set_cb(void *arg)
+OSW_UT(ow_conf_ut_is_set)
 {
     const char *phy_name = "phy1";
 
@@ -1189,88 +1057,17 @@ ow_conf_ut_is_set_cb(void *arg)
     assert(ow_conf_phy_is_set(phy_name) == false);
 }
 
-struct ow_conf_ut_obs_arg {
-    struct ow_conf_observer obs;
-    int n_agitated;
-    int n_settled;
-};
-
-static void
-ow_conf_ut_obs_agitated_cb(struct ow_conf_observer *obs)
-{
-    struct ow_conf_ut_obs_arg *arg = container_of(obs, struct ow_conf_ut_obs_arg, obs);
-    arg->n_agitated++;
-}
-
-static void
-ow_conf_ut_obs_settled_cb(struct ow_conf_observer *obs)
-{
-    struct ow_conf_ut_obs_arg *arg = container_of(obs, struct ow_conf_ut_obs_arg, obs);
-    arg->n_settled++;
-}
-
-static void
-ow_conf_ut_obs_cb(void *arg)
-{
-    struct ow_conf *c = &g_ow_conf;
-    struct ow_conf_ut_obs_arg ctx = {
-        .obs = {
-            .agitated_fn = ow_conf_ut_obs_agitated_cb,
-            .settled_fn = ow_conf_ut_obs_settled_cb,
-        },
-    };
-
-    ow_conf_register_observer(&ctx.obs);
-
-    LOGI("settled");
-    assert(ctx.n_settled == 0);
-    ow_conf_settled_cb(&c->confsync);
-    assert(ctx.n_settled == 0);
-    ow_conf_confsync_idle_cb(&c->confsync);
-    assert(ctx.n_settled == 1);
-
-    LOGI("agitated");
-    assert(ctx.n_agitated == 0);
-    ow_conf_agitated_cb(&c->confsync);
-    assert(ctx.n_agitated == 1);
-    ow_conf_settled_cb(&c->confsync);
-    ow_conf_confsync_busy_cb(&c->confsync);
-    assert(ctx.n_settled == 2);
-    assert(ctx.n_agitated == 2);
-
-    LOGI("null deref");
-    memset(&ctx.obs, 0, sizeof(ctx.obs));
-    ow_conf_agitated_cb(&c->confsync);
-    ow_conf_settled_cb(&c->confsync);
-
-    /* FIXME: Test other callbacks. Before that can be done
-     * ow_conf_init() needs to be split into _init and
-     * _start, where _start actually attaches to modules to
-     * one another and sets up resources like linked lists
-     * between them, opens sockets, schedules libev objects,
-     * etc.
-     */
-}
-
-static void
-ow_conf_ut_module_init(void *data)
-{
-    osw_ut_register("ow_conf_ut_phy_enabled", ow_conf_ut_phy_enabled_cb, NULL);
-    osw_ut_register("ow_conf_ut_vif_enabled", ow_conf_ut_vif_enabled_cb, NULL);
-    osw_ut_register("ow_conf_ut_is_set", ow_conf_ut_is_set_cb, NULL);
-    osw_ut_register("ow_conf_ut_obs", ow_conf_ut_obs_cb, NULL);
-}
-
-static void
-ow_conf_ut_module_fini(void *data)
+OSW_MODULE(ow_conf)
 {
+    OSW_MODULE_LOAD(osw_conf);
+    ow_conf_init();
+    return NULL;
 }
 
-MODULE(ow_conf_ut_module, ow_conf_ut_module_init, ow_conf_ut_module_fini);
-
 #define DEFINE_PHY_FIELD_UT(field, type, eq, ...) \
     static void \
     ow_conf_ut_field_phy_##field##_cb(void *data) { \
+        ow_conf_init(); \
         assert(ow_conf_phy_get_##field("phy1") == NULL); \
         \
         const type values[] = { __VA_ARGS__ }; \
Index: core/src/lib/ow/src/ow_conf.h
===================================================================
--- core.orig/src/lib/ow/src/ow_conf.h
+++ core/src/lib/ow/src/ow_conf.h
@@ -1,5 +1,5 @@
-#ifndef OW_CONF_H
-#define OW_CONF_H
+#ifndef OW_CONF_H_INCLUDED
+#define OW_CONF_H_INCLUDED
 
 /**
  * @file ow_conf.h
@@ -28,8 +28,6 @@
 
 struct ow_conf_observer;
 
-typedef void ow_conf_agitated_fn_t(struct ow_conf_observer *obs);
-typedef void ow_conf_settled_fn_t(struct ow_conf_observer *obs);
 typedef void ow_conf_phy_changed_fn_t(struct ow_conf_observer *obs,
                                       const char *phy_name);
 typedef void ow_conf_vif_changed_fn_t(struct ow_conf_observer *obs,
@@ -38,10 +36,8 @@ typedef void ow_conf_vif_changed_fn_t(st
 struct ow_conf_observer {
     /* public */
     const char *name;
-    ow_conf_agitated_fn_t *const agitated_fn;
-    ow_conf_settled_fn_t *const settled_fn;
-    ow_conf_phy_changed_fn_t *const phy_changed_fn;
-    ow_conf_vif_changed_fn_t *const vif_changed_fn;
+    ow_conf_phy_changed_fn_t *phy_changed_fn;
+    ow_conf_vif_changed_fn_t *vif_changed_fn;
 
     /* private */
     struct ds_dlist_node node;
@@ -49,7 +45,6 @@ struct ow_conf_observer {
 
 void ow_conf_register_observer(struct ow_conf_observer *obs);
 
-void ow_conf_init(void);
 bool ow_conf_is_settled(void);
 
 void ow_conf_phy_unset(const char *phy_name);
@@ -98,10 +93,16 @@ void ow_conf_vif_set_ap_rrm_neighbor_rep
 void ow_conf_vif_set_ap_mcast2ucast(const char *vif_name, const bool *mcast2ucast_enabled);
 
 void ow_conf_vif_set_ap_psk(const char *vif_name, int key_id, const char *str);
+void ow_conf_vif_set_sta_net(const char *vif_name,
+                             const struct osw_ssid *ssid,
+                             const struct osw_hwaddr *bssid,
+                             const struct osw_psk *psk,
+                             const struct osw_wpa *wpa);
 void ow_conf_vif_add_ap_acl(const char *vif_name, const struct osw_hwaddr *addr);
 void ow_conf_vif_del_ap_acl(const char *vif_name, const struct osw_hwaddr *addr);
 void ow_conf_vif_flush_ap_psk(const char *vif_name);
 void ow_conf_vif_flush_ap_acl(const char *vif_name);
+void ow_conf_vif_flush_sta_net(const char *vif_name);
 
 bool ow_conf_vif_is_set(const char *vif_name);
 const char *ow_conf_vif_get_phy_name(const char *vif_name);
@@ -120,4 +121,4 @@ const enum osw_pmf *ow_conf_vif_get_ap_p
 const char *ow_conf_vif_get_ap_psk(const char *vif_name, int key_id);
 bool ow_conf_vif_has_ap_acl(const char *vif_name, const struct osw_hwaddr *addr);
 
-#endif /* OW_CONF_H */
+#endif /* OW_CONF_H_INCLUDED */
Index: core/src/lib/ow/src/ow_conf_barrier.c
===================================================================
--- core.orig/src/lib/ow/src/ow_conf_barrier.c
+++ core/src/lib/ow/src/ow_conf_barrier.c
@@ -8,14 +8,12 @@
 #include <ev.h> /* ev_* */
 
 /* opensync */
-#include <module.h> /* MODULE() */
 #include <ds_dlist.h> /* ds_dlist_* */
 #include <log.h> /* LOG*() */
 #include <const.h> /* container_of() */
 #include <osw_ut.h> /* osw_ut_register() */
-
-/* onewifi */
-#include "ow_conf.h" /* ow_conf_register_observer() */
+#include <osw_module.h> /* OSW_MODULE()() */
+#include <osw_confsync.h>
 
 struct ow_conf_barrier_waiter {
     struct ds_dlist_node node;
@@ -25,7 +23,8 @@ struct ow_conf_barrier_waiter {
 };
 
 struct ow_conf_barrier {
-    struct ow_conf_observer conf_obs;
+    struct osw_confsync *cs;
+    struct osw_confsync_changed *csc;
     struct ds_dlist waiters;
     ev_idle idle;
     ev_async work;
@@ -62,18 +61,27 @@ ow_conf_barrier_waiters_notify(struct ow
 }
 
 static void
-ow_conf_barrier_agitated_cb(struct ow_conf_observer *obs)
+ow_conf_barrier_confsync_changed(struct ow_conf_barrier *b,
+                                 enum osw_confsync_state s)
 {
-    struct ow_conf_barrier *b = container_of(obs, struct ow_conf_barrier, conf_obs);
-    b->settled = false;
+    switch (s) {
+    case OSW_CONFSYNC_IDLE:
+        b->settled = true;
+        ow_conf_barrier_waiters_notify(b);
+        break;
+    case OSW_CONFSYNC_REQUESTING:
+    case OSW_CONFSYNC_WAITING:
+    case OSW_CONFSYNC_VERIFYING:
+        b->settled = false;
+        break;
+    }
 }
-
 static void
-ow_conf_barrier_settled_cb(struct ow_conf_observer *obs)
+ow_conf_barrier_confsync_changed_cb(struct osw_confsync *cs, void *priv)
 {
-    struct ow_conf_barrier *b = container_of(obs, struct ow_conf_barrier, conf_obs);
-    b->settled = true;
-    ow_conf_barrier_waiters_notify(b);
+    struct ow_conf_barrier *b = priv;
+    enum osw_confsync_state s = osw_confsync_get_state(cs);
+    ow_conf_barrier_confsync_changed(b, s);
 }
 
 static void
@@ -102,7 +110,10 @@ ow_conf_barrier_init(struct ow_conf_barr
 static void
 ow_conf_barrier_start(struct ow_conf_barrier *b)
 {
-    ow_conf_register_observer(&b->conf_obs);
+    b->csc = osw_confsync_register_changed_fn(b->cs,
+                                              __FILE__,
+                                              ow_conf_barrier_confsync_changed_cb,
+                                              b);
     ev_async_start(EV_DEFAULT_ &b->work);
     ev_unref(EV_DEFAULT);
 }
@@ -162,11 +173,6 @@ out:
 }
 
 static struct ow_conf_barrier g_ow_conf_barrier = {
-    .conf_obs = {
-        .name = __FILE__,
-        .agitated_fn = ow_conf_barrier_agitated_cb,
-        .settled_fn = ow_conf_barrier_settled_cb,
-    },
     .waiters = DS_DLIST_INIT(struct ow_conf_barrier_waiter, node),
     .lock = PTHREAD_MUTEX_INITIALIZER,
     .settled = false,
@@ -196,8 +202,7 @@ ow_conf_barrier_ut_t_cb(void *data)
     return NULL;
 }
 
-static void
-ow_conf_barrier_ut_cb(void *data)
+OSW_UT(ow_conf_barrier)
 {
     struct ow_conf_barrier *b = &g_ow_conf_barrier;
     struct ow_conf_barrier_ut_t_arg a1 = { 0, 100, 0 };
@@ -217,13 +222,13 @@ ow_conf_barrier_ut_cb(void *data)
     while (ow_conf_barrier_waiters_count(b) != 2) {}
     ev_run(EV_DEFAULT_ 0);
     assert(b->settled == false);
-    ow_conf_barrier_settled_cb(&b->conf_obs);
+    ow_conf_barrier_confsync_changed(b, OSW_CONFSYNC_IDLE);
     while (ow_conf_barrier_waiters_count(b) != 0) {}
     pthread_join(t1, NULL);
     pthread_join(t2, NULL);
 
     /* should timeout */
-    ow_conf_barrier_agitated_cb(&b->conf_obs);
+    ow_conf_barrier_confsync_changed(b, OSW_CONFSYNC_REQUESTING);
     pthread_create(&t1, NULL, ow_conf_barrier_ut_t_cb, &a3);
     while (ow_conf_barrier_waiters_count(b) != 1) {}
     ev_run(EV_DEFAULT_ 0);
@@ -233,7 +238,7 @@ ow_conf_barrier_ut_cb(void *data)
     pthread_join(t1, NULL);
 
     /* a4 timeout, a5 no timeout */
-    ow_conf_barrier_agitated_cb(&b->conf_obs);
+    ow_conf_barrier_confsync_changed(b, OSW_CONFSYNC_REQUESTING);
     pthread_create(&t1, NULL, ow_conf_barrier_ut_t_cb, &a4);
     pthread_create(&t2, NULL, ow_conf_barrier_ut_t_cb, &a5);
     while (ow_conf_barrier_waiters_count(b) != 2) {}
@@ -241,26 +246,18 @@ ow_conf_barrier_ut_cb(void *data)
     assert(b->settled == false);
     usleep(a4.barrier_wait * 1.5 * 1000);
     assert(ow_conf_barrier_waiters_count(b) == 1);
-    ow_conf_barrier_settled_cb(&b->conf_obs);
+    ow_conf_barrier_confsync_changed(b, OSW_CONFSYNC_IDLE);
     while (ow_conf_barrier_waiters_count(b) != 0) {}
     pthread_join(t1, NULL);
     pthread_join(t2, NULL);
 }
 
-static void
-ow_conf_barrier_module_init_cb(void *data)
+OSW_MODULE(ow_conf_barrier)
 {
+    OSW_MODULE_LOAD(osw_confsync);
     struct ow_conf_barrier *b = &g_ow_conf_barrier;
+    b->cs = osw_confsync_get();
     ow_conf_barrier_init(b);
     ow_conf_barrier_start(b);
-    osw_ut_register("ow_conf_barrier_ut", ow_conf_barrier_ut_cb, NULL);
-}
-
-static void
-ow_conf_barrier_module_fini_cb(void *data)
-{
+    return NULL;
 }
-
-MODULE(ow_conf_barrier_module,
-       ow_conf_barrier_module_init_cb,
-       ow_conf_barrier_module_fini_cb);
Index: core/src/lib/ow/src/ow_core.c
===================================================================
--- core.orig/src/lib/ow/src/ow_core.c
+++ core/src/lib/ow/src/ow_core.c
@@ -11,15 +11,16 @@
 #include <target.h>
 #include <module.h>
 #include <log.h>
+#include <ds_tree.h>
+#include <ds_list.h>
 #include <os_backtrace.h>
 
 /* osw */
 #include <osw_ut.h>
 #include <osw_thread.h>
-#include <osw.h>
+#include <osw_module.h>
 
 /* onewifi */
-#include "ow_bus.h"
 #include "ow_conf.h"
 
 static log_severity_t
@@ -51,6 +52,15 @@ ow_core_init(EV_P)
 void
 ow_core_run(EV_P)
 {
+    osw_module_load();
+
+    /* FIXME: This is a little clunky. osw_ev is supposed to
+     * be _the_ ev loop provider. However with the current
+     * state of affiars it needs a bit more work to clean
+     * this up.
+    */
+    assert(OSW_MODULE_LOAD(osw_ev) == EV_A);
+
     /* FIXME: This is necessary to avoid mainloop exiting if
      * there are no apparent action watchers. In some corner
      * cases (depending on the type of buses) this can yield
@@ -58,9 +68,5 @@ ow_core_run(EV_P)
      * the mainloop keeps running.
      */
     ev_ref(EV_A);
-
-    osw_init();
-    ow_bus_init();
-    ow_conf_init();
     ev_run(EV_A_ 0);
 }
Index: core/src/lib/ow/src/ow_core_thread.c
===================================================================
--- core.orig/src/lib/ow/src/ow_core_thread.c
+++ core/src/lib/ow/src/ow_core_thread.c
@@ -5,7 +5,6 @@
 /* opensync */
 #include <ds_dlist.h>
 #include <memutil.h>
-#include <module.h>
 #include <log.h>
 #include <const.h>
 #include <osw_ut.h>
@@ -178,32 +177,16 @@ ow_core_thread_ut_call_1_cb(void *arg)
     return arg;
 }
 
-static void
-ow_core_thread_ut_cb(void *data)
+OSW_UT(ow_core_thread_ut)
 {
-    unsigned int arg = 0x1337;
+    unsigned int num = 0x1337;
     LOGI("%s: starting\n", __func__);
     ow_core_thread_start();
     LOGI("%s: calling\n", __func__);
-    unsigned int *ret = ow_core_thread_call(ow_core_thread_ut_call_1_cb, &arg);
-    assert(ret == &arg);
-    assert(arg == 0xbeef);
+    unsigned int *ret = ow_core_thread_call(ow_core_thread_ut_call_1_cb, &num);
+    assert(ret == &num);
+    assert(num == 0xbeef);
     LOGI("%s: canceling\n", __func__);
     ow_core_thread_cancel();
     LOGI("%s: done\n", __func__);
 }
-
-static void
-ow_core_thread_module_init_cb(void *data)
-{
-    osw_ut_register("ow_core_thread_ut", ow_core_thread_ut_cb, NULL);
-}
-
-static void
-ow_core_thread_module_fini_cb(void *data)
-{
-}
-
-MODULE(ow_core_thread_module,
-       ow_core_thread_module_init_cb,
-       ow_core_thread_module_fini_cb);
Index: core/src/lib/ow/src/ow_demo_stats.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_demo_stats.c
@@ -0,0 +1,185 @@
+#include <util.h>
+#include <log.h>
+#include <osw_stats.h>
+#include <osw_stats_defs.h>
+#include <osw_stats_subscriber.h>
+#include <osw_module.h>
+
+#define NOTE(fmt, ...) LOGI("%s:%d:%s(): " fmt, __FILE__, __LINE__, __func__, ##__VA_ARGS__)
+
+static bool
+ow_demo_stats_is_enabled(void)
+{
+    return atoi(getenv("OW_DEMO_STATS_ENABLED") ?: "0") == 1;
+}
+
+static void
+ow_demo_stats_report_chan(const struct osw_tlv *data,
+                          const struct osw_tlv *last,
+                          void *priv)
+{
+    const struct osw_stats_defs *defs = osw_stats_defs_lookup(OSW_STATS_CHAN);
+
+    assert(defs != NULL);
+
+    const struct osw_tlv_policy *p = defs->tpolicy;
+    const size_t size = defs->size;
+    const struct osw_tlv_hdr *tb[size];
+
+    memset(tb, 0, size * sizeof(*tb));
+    osw_tlv_parse(data->data, data->used, p, tb, size);
+
+    if (tb[OSW_STATS_CHAN_ACTIVE_MSEC] &&
+        osw_tlv_get_u32(tb[OSW_STATS_CHAN_ACTIVE_MSEC]) == 0) {
+        return;
+    }
+
+    char *line = NULL;
+    strgrow(&line, "chan: report:");
+
+    if (tb[OSW_STATS_CHAN_PHY_NAME])
+        strgrow(&line, " phy=%s", osw_tlv_get_string(tb[OSW_STATS_CHAN_PHY_NAME]));
+    if (tb[OSW_STATS_CHAN_FREQ_MHZ])
+        strgrow(&line, " freq=%uMHz", osw_tlv_get_u32(tb[OSW_STATS_CHAN_FREQ_MHZ]));
+    if (tb[OSW_STATS_CHAN_ACTIVE_MSEC])
+        strgrow(&line, " active=%umsec", osw_tlv_get_u32(tb[OSW_STATS_CHAN_ACTIVE_MSEC]));
+    if (tb[OSW_STATS_CHAN_NOISE_FLOOR_DBM])
+        strgrow(&line, " nf=%ddBm", (int)osw_tlv_get_float(tb[OSW_STATS_CHAN_NOISE_FLOOR_DBM]));
+
+    if (tb[OSW_STATS_CHAN_CNT_MSEC]) {
+        const struct osw_tlv_hdr *msec = tb[OSW_STATS_CHAN_CNT_MSEC];
+        const struct osw_tlv_policy *p2 = p[OSW_STATS_CHAN_CNT_MSEC].nested;
+        const size_t size2 = defs->size;
+        const struct osw_tlv_hdr *tb2[size2];
+        const void *data = osw_tlv_get_data(msec);
+        const size_t len = msec->len;
+
+        strgrow(&line, " msec:");
+        memset(tb2, 0, size * sizeof(*tb2));
+        osw_tlv_parse(data, len, p2, tb2, size2);
+
+        if (tb2[OSW_STATS_CHAN_CNT_TX])
+            strgrow(&line, " tx=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_TX]));
+        if (tb2[OSW_STATS_CHAN_CNT_RX])
+            strgrow(&line, " rx=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_RX]));
+        if (tb2[OSW_STATS_CHAN_CNT_RX_INBSS])
+            strgrow(&line, " inbss=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_RX_INBSS]));
+        if (tb2[OSW_STATS_CHAN_CNT_BUSY])
+            strgrow(&line, " busy=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_BUSY]));
+    }
+
+    if (tb[OSW_STATS_CHAN_CNT_PERCENT]) {
+        const struct osw_tlv_hdr *percent = tb[OSW_STATS_CHAN_CNT_PERCENT];
+        const struct osw_tlv_policy *p2 = p[OSW_STATS_CHAN_CNT_PERCENT].nested;
+        const size_t size2 = defs->size;
+        const struct osw_tlv_hdr *tb2[size2];
+        const void *data = osw_tlv_get_data(percent);
+        const size_t len = percent->len;
+
+        strgrow(&line, " percent:");
+        memset(tb2, 0, size * sizeof(*tb2));
+        osw_tlv_parse(data, len, p2, tb2, size2);
+
+        if (tb2[OSW_STATS_CHAN_CNT_TX])
+            strgrow(&line, " tx=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_TX]));
+        if (tb2[OSW_STATS_CHAN_CNT_RX])
+            strgrow(&line, " rx=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_RX]));
+        if (tb2[OSW_STATS_CHAN_CNT_RX_INBSS])
+            strgrow(&line, " inbss=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_RX_INBSS]));
+        if (tb2[OSW_STATS_CHAN_CNT_BUSY])
+            strgrow(&line, " busy=%u", osw_tlv_get_u32(tb2[OSW_STATS_CHAN_CNT_BUSY]));
+    }
+
+    NOTE("%s", line);
+    free(line);
+}
+
+static void
+ow_demo_stats_report_bss_scan(const struct osw_tlv *data,
+                              const struct osw_tlv *last,
+                              void *priv)
+{
+    const struct osw_stats_defs *defs = osw_stats_defs_lookup(OSW_STATS_BSS_SCAN);
+
+    assert(defs != NULL);
+
+    const struct osw_tlv_policy *p = defs->tpolicy;
+    const size_t size = defs->size;
+    const struct osw_tlv_hdr *tb[size];
+
+    memset(tb, 0, size * sizeof(*tb));
+    osw_tlv_parse(data->data, data->used, p, tb, size);
+
+    char *line = NULL;
+    strgrow(&line, "bss: report:");
+
+    if (tb[OSW_STATS_BSS_SCAN_PHY_NAME]) {
+        strgrow(&line, " phy=%s", osw_tlv_get_string(tb[OSW_STATS_BSS_SCAN_PHY_NAME]));
+    }
+
+    if (tb[OSW_STATS_BSS_SCAN_MAC_ADDRESS]) {
+        const struct osw_hwaddr *bssid = osw_tlv_get_data(tb[OSW_STATS_BSS_SCAN_MAC_ADDRESS]);
+        strgrow(&line, " bssid=" OSW_HWADDR_FMT, OSW_HWADDR_ARG(bssid));
+    }
+
+    if (tb[OSW_STATS_BSS_SCAN_SSID]) {
+        const struct osw_tlv_hdr *h = tb[OSW_STATS_BSS_SCAN_SSID];
+        struct osw_ssid ssid;
+        memcpy(ssid.buf, osw_tlv_get_data(h), h->len);
+        ssid.len = h->len;
+        strgrow(&line, " ssid=" OSW_SSID_FMT, OSW_SSID_ARG(&ssid));
+    }
+
+    if (tb[OSW_STATS_BSS_SCAN_FREQ_MHZ]) {
+        strgrow(&line, " freq=%uMHz", osw_tlv_get_u32(tb[OSW_STATS_BSS_SCAN_FREQ_MHZ]));
+    }
+
+    if (tb[OSW_STATS_BSS_SCAN_WIDTH_MHZ]) {
+        strgrow(&line, " width=%uMHz", osw_tlv_get_u32(tb[OSW_STATS_BSS_SCAN_WIDTH_MHZ]));
+    }
+
+    if (tb[OSW_STATS_BSS_SCAN_SNR_DB]) {
+        strgrow(&line, " snr=%udB", osw_tlv_get_u32(tb[OSW_STATS_BSS_SCAN_SNR_DB]));
+    }
+
+    NOTE("%s", line);
+    free(line);
+}
+
+static void
+ow_demo_stats_report_cb(enum osw_stats_id id,
+                        const struct osw_tlv *data,
+                        const struct osw_tlv *last,
+                        void *priv)
+{
+    switch (id) {
+        case OSW_STATS_PHY: break;
+        case OSW_STATS_VIF: break;
+        case OSW_STATS_STA: break;
+        case OSW_STATS_CHAN: return ow_demo_stats_report_chan(data, last, priv);
+        case OSW_STATS_BSS_SCAN: return ow_demo_stats_report_bss_scan(data, last, priv);
+        case OSW_STATS_MAX__: break;
+    }
+}
+
+static void
+ow_demo_stats_start(void)
+{
+    NOTE("starting");
+    struct osw_stats_subscriber *sub = osw_stats_subscriber_alloc();
+    osw_stats_subscriber_set_report_seconds(sub, 10);
+    osw_stats_subscriber_set_poll_seconds(sub, 10);
+    osw_stats_subscriber_set_chan(sub, true);
+    osw_stats_subscriber_set_bss(sub, true);
+    osw_stats_subscriber_set_report_fn(sub, ow_demo_stats_report_cb, sub);
+    NOTE("registering");
+    osw_stats_register_subscriber(sub);
+    NOTE("started");
+}
+
+OSW_MODULE(ow_demo_stats)
+{
+    if (ow_demo_stats_is_enabled() == false) return NULL;
+    ow_demo_stats_start();
+    return NULL;
+}
Index: core/src/lib/ow/src/ow_dfs_backup.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_dfs_backup.c
@@ -0,0 +1,584 @@
+#include <memutil.h>
+#include <log.h>
+#include <const.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+
+#include "ow_dfs_backup.h"
+#include <osw_module.h>
+#include <osw_timer.h>
+#include <osw_cqm.h>
+#include <osw_ut.h>
+
+#define LOG_PREFIX "ow: dfs backup: "
+
+/* FIXME: This might need some adjusting depending on how
+ * well the current system in its entirety can recover from
+ * a connection loss.
+ */
+#define OW_DFS_BACKUP_TIMEOUT_SEC 10.
+
+/*
+ * DFS Backup
+ *
+ * Purpose:
+ *
+ * Provide input: fallback configurations
+ * Provide observable: recovery request
+ *
+ * Description:
+ *
+ * The module is providing a configuration storage for data
+ * model adapter(s).
+ *
+ * It then uses that data against link cqm reports and, when
+ * the need arises, it generates an event that observer(s)
+ * can listen for and act upon.
+ */
+
+enum ow_dfs_backup_phy_op {
+    OW_DFS_BACKUP_PHY_NOP,
+    OW_DFS_BACKUP_PHY_NOTIFY_START,
+    OW_DFS_BACKUP_PHY_NOTIFY_STOP,
+};
+
+struct ow_dfs_backup_phy_conf {
+    struct osw_hwaddr bssid;
+    struct osw_channel channel;
+};
+
+struct ow_dfs_backup_phy_sm {
+    struct ow_dfs_backup_phy_conf conf_prev;
+    struct ow_dfs_backup_phy_conf conf_set;
+    struct ow_dfs_backup_phy_conf conf_used;
+    enum ow_dfs_backup_phy_state state;
+    char *link_vif_name;
+};
+
+struct ow_dfs_backup_phy {
+    struct ow_dfs_backup *b;
+    struct ds_tree_node node_phy;
+    struct ds_tree_node node_link;
+    char *phy_name;
+    struct ow_dfs_backup_phy_sm sm;
+    struct osw_cqm_notify *notify;
+    struct osw_timer work;
+};
+
+struct ow_dfs_backup_notify {
+    struct ds_dlist_node node;
+    struct ow_dfs_backup *b;
+    char *name;
+    ow_dfs_backup_notify_fn_t *fn;
+    void *fn_priv;
+};
+
+struct ow_dfs_backup {
+    struct ds_tree phys;
+    struct ds_tree links;
+    struct ds_dlist notify_fns;
+    struct osw_cqm_ops *cqm_ops;
+    struct osw_cqm *cqm;
+};
+
+static const char *
+phy_state_to_str(enum ow_dfs_backup_phy_state s)
+{
+    switch (s) {
+        case OW_DFS_BACKUP_PHY_REMOVED: return "removed";
+        case OW_DFS_BACKUP_PHY_CONFIGURED: return "configured";
+        case OW_DFS_BACKUP_PHY_LATCHED: return "latched";
+    }
+    return "";
+}
+
+static const char *
+phy_op_to_str(enum ow_dfs_backup_phy_op op)
+{
+    switch (op) {
+        case OW_DFS_BACKUP_PHY_NOP: return "nop";
+        case OW_DFS_BACKUP_PHY_NOTIFY_START: return "notify_start";
+        case OW_DFS_BACKUP_PHY_NOTIFY_STOP: return "notify_stop";
+    }
+    return "";
+}
+
+static bool
+phy_is_configured(struct ow_dfs_backup_phy_sm *sm)
+{
+    const struct osw_channel chan0 = {0};
+    const struct osw_hwaddr bssid0 = {0};
+    if (memcmp(&sm->conf_set.channel, &chan0, sizeof(chan0)) == 0) return false;
+    if (memcmp(&sm->conf_set.bssid, &bssid0, sizeof(bssid0)) == 0) return false;
+    return true;
+}
+
+static bool
+phy_is_changed(struct ow_dfs_backup_phy_sm *sm)
+{
+    const size_t size = sizeof(sm->conf_set);
+    return memcmp(&sm->conf_set, &sm->conf_used, size) != 0;
+}
+
+static void
+phy_arm(struct ow_dfs_backup_phy *phy)
+{
+    osw_timer_arm_at_nsec(&phy->work, 0);
+}
+
+static const char *
+phy_filter_link(const char *vif_name,
+                enum osw_cqm_link_state state,
+                bool is_dfs)
+{
+    switch (state) {
+        case OSW_CQM_LINK_DECONFIGURED: return NULL;
+        case OSW_CQM_LINK_DISCONNECTED: return NULL;
+        case OSW_CQM_LINK_CONNECTED: return NULL;
+        case OSW_CQM_LINK_TIMING_OUT: return NULL;
+        case OSW_CQM_LINK_RECOVERING: return NULL;
+        case OSW_CQM_LINK_TIMED_OUT: return is_dfs ? vif_name : NULL;
+    }
+
+    return NULL;
+}
+
+static void
+phy_set_link(struct ow_dfs_backup_phy *phy,
+             const char *vif_name,
+             enum osw_cqm_link_state state,
+             const struct osw_channel *c)
+{
+    const struct osw_channel chan0 = {0};
+    const struct osw_channel *chan = c ?: &chan0;
+    const bool always = getenv("OW_DFS_BACKUP_ALWAYS") ? true : false;
+    const bool is_dfs = osw_channel_overlaps_dfs(chan) || always;
+
+    LOGT(LOG_PREFIX"phy: %s: set link: %s state: %d chan: "OSW_CHANNEL_FMT,
+         phy ? phy->phy_name : "",
+         vif_name ?: "",
+         state,
+         OSW_CHANNEL_ARG(chan));
+
+    if (is_dfs == true &&
+        state == OSW_CQM_LINK_RECOVERING) {
+        LOGN(LOG_PREFIX"link: %s: recovered before timeout", vif_name ?: "");
+    }
+
+    vif_name = phy_filter_link(vif_name, state, is_dfs);
+    if (vif_name != NULL && phy == NULL) {
+        LOGN(LOG_PREFIX"link: %s: cannot recover, no backup phy bound",
+             vif_name);
+        return;
+    }
+    if (phy == NULL) {
+        return;
+    }
+    if (phy->sm.link_vif_name != NULL) {
+        LOGD(LOG_PREFIX"phy: %s: link: %s: unlatching",
+             phy->phy_name, phy->sm.link_vif_name);
+        ds_tree_remove(&phy->b->links, phy);
+        FREE(phy->sm.link_vif_name);
+        phy->sm.link_vif_name = NULL;
+    }
+    if (vif_name != NULL) {
+        LOGD(LOG_PREFIX"phy: %s: link: %s: latching",
+             phy->phy_name, vif_name);
+        phy->sm.link_vif_name = STRDUP(vif_name);
+        ds_tree_insert(&phy->b->links, phy, phy->sm.link_vif_name);
+    }
+    phy_arm(phy);
+}
+
+static void
+cqm_cb(const char *vif_name,
+       enum osw_cqm_link_state state,
+       const struct osw_channel *c,
+       void *priv)
+{
+    struct ow_dfs_backup_phy *phy = priv;
+    phy_set_link(phy, vif_name, state, c);
+}
+
+static enum ow_dfs_backup_phy_state
+phy_sm_next(struct ow_dfs_backup_phy_sm *sm)
+{
+    switch (sm->state) {
+        case OW_DFS_BACKUP_PHY_REMOVED:
+            if (phy_is_configured(sm) == true) return OW_DFS_BACKUP_PHY_CONFIGURED;
+            break;
+        case OW_DFS_BACKUP_PHY_CONFIGURED:
+            if (phy_is_configured(sm) == false) return OW_DFS_BACKUP_PHY_REMOVED;
+            if (sm->link_vif_name != NULL) return OW_DFS_BACKUP_PHY_LATCHED;
+            break;
+        case OW_DFS_BACKUP_PHY_LATCHED:
+            if (phy_is_configured(sm) == false) return OW_DFS_BACKUP_PHY_CONFIGURED;
+            if (phy_is_changed(sm) == true) return OW_DFS_BACKUP_PHY_CONFIGURED;
+            if (sm->link_vif_name == NULL) return OW_DFS_BACKUP_PHY_CONFIGURED;
+            break;
+    }
+    return sm->state;
+}
+
+static void
+phy_notify_one(const struct ow_dfs_backup_phy *phy,
+               const struct ow_dfs_backup_phy_sm *sm,
+               const struct ow_dfs_backup_notify *n)
+{
+    const char *to = phy_state_to_str(sm->state);
+    LOGD(LOG_PREFIX"phy: %s: notify: %s: %s", phy->phy_name, n->name, to);
+    n->fn(phy->phy_name,
+          sm->link_vif_name,
+          sm->state,
+          &sm->conf_used.bssid,
+          &sm->conf_used.channel,
+          n->fn_priv);
+}
+
+static void
+phy_notify(struct ow_dfs_backup_phy *phy)
+{
+    struct ow_dfs_backup_notify *n;
+    ds_dlist_foreach(&phy->b->notify_fns, n) {
+        phy_notify_one(phy, &phy->sm, n);
+    }
+}
+
+static enum ow_dfs_backup_phy_op
+phy_sm_leave(struct ow_dfs_backup_phy_sm *sm,
+             enum ow_dfs_backup_phy_state state)
+{
+    switch (state) {
+        case OW_DFS_BACKUP_PHY_REMOVED: return OW_DFS_BACKUP_PHY_NOTIFY_START;
+        case OW_DFS_BACKUP_PHY_CONFIGURED: return OW_DFS_BACKUP_PHY_NOP;
+        case OW_DFS_BACKUP_PHY_LATCHED:
+            memset(&sm->conf_used, 0, sizeof(sm->conf_used));
+            return OW_DFS_BACKUP_PHY_NOP;
+    }
+    return OW_DFS_BACKUP_PHY_NOP;
+}
+
+static enum ow_dfs_backup_phy_op
+phy_sm_enter(struct ow_dfs_backup_phy_sm *sm,
+             enum ow_dfs_backup_phy_state state)
+{
+    switch (state) {
+        case OW_DFS_BACKUP_PHY_REMOVED: return OW_DFS_BACKUP_PHY_NOTIFY_STOP;
+        case OW_DFS_BACKUP_PHY_CONFIGURED: return OW_DFS_BACKUP_PHY_NOP;
+        case OW_DFS_BACKUP_PHY_LATCHED:
+            sm->conf_used = sm->conf_set;
+            return OW_DFS_BACKUP_PHY_NOP;
+    }
+    return OW_DFS_BACKUP_PHY_NOP;
+}
+
+static void
+phy_sm_walk(struct ow_dfs_backup_phy *phy,
+            const struct ow_dfs_backup_phy_sm *base,
+            struct ow_dfs_backup_notify *n,
+            enum ow_dfs_backup_phy_state from)
+{
+    struct ow_dfs_backup_phy_sm sm = {0};
+    if (base != NULL) sm = *base;
+    sm.state = from;
+
+    for (;;) {
+            enum ow_dfs_backup_phy_state prev_state = sm.state;
+            enum ow_dfs_backup_phy_state next_state = phy_sm_next(&sm);
+            if (prev_state == next_state) break;
+            const char *from = phy_state_to_str(prev_state);
+            const char *to = phy_state_to_str(next_state);
+            LOGD(LOG_PREFIX"walk: %s: state: %s -> %s", phy->phy_name, from, to);
+            sm.state = next_state;
+            phy_sm_leave(&sm, prev_state);
+            phy_sm_enter(&sm, next_state);
+            phy_notify_one(phy, &sm, n);
+    }
+}
+
+static void
+phy_sm_op(struct ow_dfs_backup_phy *phy,
+          enum ow_dfs_backup_phy_op op)
+{
+    LOGD(LOG_PREFIX"phy: %s: op: %s", phy->phy_name, phy_op_to_str(op));
+    switch (op) {
+        case OW_DFS_BACKUP_PHY_NOP:
+            break;
+        case OW_DFS_BACKUP_PHY_NOTIFY_START:
+            assert(phy->notify == NULL);
+            phy->notify = phy->b->cqm_ops->add_notify_fn(phy->b->cqm, __FILE__, cqm_cb, phy);
+            break;
+        case OW_DFS_BACKUP_PHY_NOTIFY_STOP:
+            assert(phy->notify != NULL);
+            phy->b->cqm_ops->del_notify_fn(phy->notify);
+            phy->notify = NULL;
+            break;
+    }
+}
+
+static void
+phy_free(struct ow_dfs_backup_phy *phy)
+{
+    LOGD(LOG_PREFIX"phy: %s: freeing", phy->phy_name);
+    osw_timer_disarm(&phy->work);
+    assert(phy->sm.link_vif_name == NULL);
+    ds_tree_remove(&phy->b->phys, phy);
+    FREE(phy->phy_name);
+    FREE(phy);
+}
+
+static void
+phy_work(struct ow_dfs_backup_phy *phy)
+{
+    for (;;) {
+        const enum ow_dfs_backup_phy_state prev_state = phy->sm.state;
+        const enum ow_dfs_backup_phy_state next_state = phy_sm_next(&phy->sm);
+        if (prev_state == next_state) break;
+        const char *from = phy_state_to_str(prev_state);
+        const char *to = phy_state_to_str(next_state);
+        LOGD(LOG_PREFIX"phy: %s: state: %s -> %s", phy->phy_name, from, to);
+        phy->sm.state = next_state;
+        phy_sm_op(phy, phy_sm_leave(&phy->sm, prev_state));
+        phy_sm_op(phy, phy_sm_enter(&phy->sm, next_state));
+        phy_notify(phy);
+    }
+
+    if (phy->sm.state == OW_DFS_BACKUP_PHY_REMOVED) {
+        phy_free(phy);
+    }
+}
+
+static void
+phy_work_cb(struct osw_timer *t)
+{
+    struct ow_dfs_backup_phy *phy = container_of(t, struct ow_dfs_backup_phy, work);
+    phy_work(phy);
+}
+
+struct ow_dfs_backup_phy *
+ow_dfs_backup_get_phy(struct ow_dfs_backup *b,
+                      const char *phy_name)
+{
+    struct ow_dfs_backup_phy *phy = ds_tree_find(&b->phys, phy_name);
+    if (phy == NULL) {
+        LOGD(LOG_PREFIX"phy: %s: allocating", phy_name);
+        phy = CALLOC(1, sizeof(*phy));
+        phy->b = b;
+        phy->phy_name = STRDUP(phy_name);
+        phy->work.cb = phy_work_cb;
+        ds_tree_insert(&b->phys, phy, phy->phy_name);
+    }
+    return phy;
+}
+
+void
+ow_dfs_backup_phy_set_bssid(struct ow_dfs_backup_phy *phy,
+                            const struct osw_hwaddr *bssid)
+{
+    const struct osw_hwaddr *prev = &phy->sm.conf_prev.bssid;
+    if (osw_hwaddr_cmp(prev, bssid) != 0) {
+        LOGI(LOG_PREFIX"phy: %s: setting bssid: "OSW_HWADDR_FMT" -> "OSW_HWADDR_FMT,
+             phy->phy_name,
+             OSW_HWADDR_ARG(prev),
+             OSW_HWADDR_ARG(bssid));
+        phy_arm(phy);
+    }
+    phy->sm.conf_prev.bssid = *bssid;
+    phy->sm.conf_set.bssid = *bssid;
+}
+
+void
+ow_dfs_backup_phy_set_channel(struct ow_dfs_backup_phy *phy,
+                              const struct osw_channel *channel)
+{
+    const size_t size = sizeof(*channel);
+    const struct osw_channel *prev = &phy->sm.conf_prev.channel;
+    if (memcmp(prev, channel, size) != 0) {
+        LOGI(LOG_PREFIX"phy: %s: setting channel: "OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+             phy->phy_name,
+             OSW_CHANNEL_ARG(prev),
+             OSW_CHANNEL_ARG(channel));
+        phy_arm(phy);
+    }
+    phy->sm.conf_prev.channel = *channel;
+    phy->sm.conf_set.channel = *channel;
+}
+
+void
+ow_dfs_backup_phy_reset(struct ow_dfs_backup_phy *phy)
+{
+    memset(&phy->sm.conf_set, 0, sizeof(phy->sm.conf_set));
+    phy_arm(phy);
+}
+
+static void
+ow_dfs_backup_phy_unlatch(struct ow_dfs_backup_phy *phy)
+{
+    const char *vif_name = phy->sm.link_vif_name;
+
+    if (vif_name == NULL) return;
+
+    LOGD(LOG_PREFIX"phy: %s: unlatching from link: %s",
+         phy->phy_name,
+         vif_name);
+    phy_set_link(phy, NULL, OSW_CQM_LINK_DECONFIGURED, 0);
+}
+
+void
+ow_dfs_backup_unlatch_vif(struct ow_dfs_backup *b,
+                          const char *vif_name)
+{
+    struct ow_dfs_backup_phy *phy;
+
+    ds_tree_foreach(&b->phys, phy) {
+        if (phy->sm.link_vif_name != NULL) {
+            if (strcmp(phy->sm.link_vif_name, vif_name) == 0) {
+                ow_dfs_backup_phy_unlatch(phy);
+            }
+        }
+    }
+}
+
+struct ow_dfs_backup_notify *
+ow_dfs_backup_add_notify(struct ow_dfs_backup *b,
+                         const char *name,
+                         ow_dfs_backup_notify_fn_t *fn,
+                         void *fn_priv)
+{
+    assert(b != NULL);
+    assert(name != NULL);
+
+    LOGD(LOG_PREFIX"notify: %s: allocating", name);
+    struct ow_dfs_backup_notify *n = CALLOC(1, sizeof(*n));
+    n->b = b;
+    n->fn = fn;
+    n->fn_priv = fn_priv;
+    n->name = STRDUP(name);
+    ds_dlist_insert_tail(&b->notify_fns, n);
+
+    struct ow_dfs_backup_phy *phy;
+    ds_tree_foreach(&b->phys, phy) {
+        phy_sm_walk(phy, &phy->sm, n, OW_DFS_BACKUP_PHY_REMOVED);
+    }
+
+    return n;
+}
+
+void
+ow_dfs_backup_del_notify(struct ow_dfs_backup_notify *n)
+{
+    if (n == NULL) return;
+
+    LOGD(LOG_PREFIX"notify: %s: freeing", n->name);
+    ds_dlist_remove(&n->b->notify_fns, n);
+
+    struct ow_dfs_backup_phy *phy;
+    ds_tree_foreach(&n->b->phys, phy) {
+        phy_sm_walk(phy, NULL, n, phy->sm.state);
+    }
+
+    FREE(n);
+}
+
+static void
+mod_init(struct ow_dfs_backup *b)
+{
+    ds_tree_init(&b->phys, ds_str_cmp, struct ow_dfs_backup_phy, node_phy);
+    ds_tree_init(&b->links, ds_str_cmp, struct ow_dfs_backup_phy, node_link);
+    ds_dlist_init(&b->notify_fns, struct ow_dfs_backup_notify, node);
+}
+
+static void
+mod_attach(struct ow_dfs_backup *b)
+{
+    assert(b->cqm_ops != NULL);
+    if (b->cqm_ops != NULL) {
+        b->cqm = b->cqm_ops->alloc_fn(b->cqm_ops);
+        b->cqm_ops->set_timeout_sec_fn(b->cqm, OW_DFS_BACKUP_TIMEOUT_SEC);
+    }
+}
+
+OSW_MODULE(ow_dfs_backup)
+{
+    static struct ow_dfs_backup m;
+    m.cqm_ops = OSW_MODULE_LOAD(osw_cqm);
+    mod_init(&m);
+    mod_attach(&m);
+    return &m;
+}
+
+static void
+walk_ut_cb(const char *phy_name,
+           const char *link_vif_name,
+           enum ow_dfs_backup_phy_state state,
+           const struct osw_hwaddr *bssid,
+           const struct osw_channel *channel,
+           void *priv)
+{
+    size_t *cnt = priv;
+    (*cnt)++;
+}
+
+OSW_UT(ow_dfs_backup_walk)
+{
+    struct ow_dfs_backup m = {0};
+    const struct osw_hwaddr bssid1 = { .octet = { 1 } };
+    const struct osw_channel c1 = { .control_freq_mhz = 2412 };
+    const struct osw_channel c60 = { .control_freq_mhz = 5300 };
+    mod_init(&m);
+
+    assert(ds_tree_is_empty(&m.phys) == true);
+    struct ow_dfs_backup_phy *phy = ow_dfs_backup_get_phy(&m, "phy1");
+    assert(ds_tree_is_empty(&m.phys) == false);
+    ow_dfs_backup_phy_set_bssid(phy, &bssid1);
+    ow_dfs_backup_phy_set_channel(phy, &c1);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_CONFIGURED);
+    cqm_cb("vif1", OSW_CQM_LINK_CONNECTED, &c60, phy);
+    assert(ds_tree_is_empty(&m.links) == true);
+    cqm_cb("vif1", OSW_CQM_LINK_TIMED_OUT, &c60, phy);
+    assert(ds_tree_is_empty(&m.links) == false);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_LATCHED);
+
+    size_t cnt = 0;
+    struct ow_dfs_backup_notify *n = ow_dfs_backup_add_notify(&m,
+                                                              __FILE__,
+                                                              walk_ut_cb,
+                                                              &cnt);
+    assert(cnt == 2);
+    ow_dfs_backup_del_notify(n);
+    assert(cnt == 4);
+
+    n = ow_dfs_backup_add_notify(&m,
+                                 __FILE__,
+                                 walk_ut_cb,
+                                 &cnt);
+    assert(cnt == 6);
+    cqm_cb("vif1", OSW_CQM_LINK_CONNECTED, &c60, phy);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_CONFIGURED);
+    assert(ds_tree_is_empty(&m.links) == true);
+    ow_dfs_backup_del_notify(n);
+    assert(cnt == 7);
+
+    ow_dfs_backup_phy_reset(phy);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_REMOVED);
+
+    cqm_cb("vif1", OSW_CQM_LINK_TIMED_OUT, &c60, phy);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_REMOVED);
+    cqm_cb("vif1", OSW_CQM_LINK_DECONFIGURED, &c60, phy);
+    assert(ds_tree_is_empty(&m.links) == true);
+
+    /*
+    ow_dfs_backup_phy_set_bssid(phy, &bssid1);
+    ow_dfs_backup_phy_set_channel(phy, &c1);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_CONFIGURED);
+    Can't really test this without proper mock-up of CQM module.
+
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_LATCHED);
+
+    ow_dfs_backup_phy_reset(phy);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_CONFIGURED);
+    assert((phy->sm.state = phy_sm_next(&phy->sm)) == OW_DFS_BACKUP_PHY_REMOVED);
+    */
+
+    phy_free(phy);
+}
Index: core/src/lib/ow/src/ow_dfs_backup.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_dfs_backup.h
@@ -0,0 +1,51 @@
+#ifndef OW_DFS_FP_H_INCLUDED
+#define OW_DFS_FP_H_INCLUDED
+
+#include <osw_types.h>
+
+enum ow_dfs_backup_phy_state {
+    OW_DFS_BACKUP_PHY_REMOVED,
+    OW_DFS_BACKUP_PHY_CONFIGURED,
+    OW_DFS_BACKUP_PHY_LATCHED,
+};
+
+typedef void ow_dfs_backup_notify_fn_t(const char *phy_name,
+                                       const char *link_vif_name,
+                                       enum ow_dfs_backup_phy_state state,
+                                       const struct osw_hwaddr *bssid,
+                                       const struct osw_channel *channel,
+                                       void *priv);
+
+struct ow_dfs_backup;
+struct ow_dfs_backup_phy;
+struct ow_dfs_backup_notify;
+
+struct ow_dfs_backup_phy *
+ow_dfs_backup_get_phy(struct ow_dfs_backup *b,
+                      const char *phy_name);
+
+void
+ow_dfs_backup_phy_set_bssid(struct ow_dfs_backup_phy *phy,
+                            const struct osw_hwaddr *bssid);
+
+void
+ow_dfs_backup_phy_set_channel(struct ow_dfs_backup_phy *phy,
+                              const struct osw_channel *channel);
+
+void
+ow_dfs_backup_phy_reset(struct ow_dfs_backup_phy *phy);
+
+void
+ow_dfs_backup_unlatch_vif(struct ow_dfs_backup *b,
+                          const char *vif_name);
+
+struct ow_dfs_backup_notify *
+ow_dfs_backup_add_notify(struct ow_dfs_backup *b,
+                         const char *name,
+                         ow_dfs_backup_notify_fn_t *fn,
+                         void *fn_priv);
+
+void
+ow_dfs_backup_del_notify(struct ow_dfs_backup_notify *n);
+
+#endif /* OW_DFS_FP_H_INCLUDED */
Index: core/src/lib/ow/src/ow_ev_timer.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_ev_timer.c
@@ -0,0 +1,73 @@
+#include <stdint.h>
+#include <inttypes.h>
+#include <ev.h>
+#include <const.h>
+#include <log.h>
+#include <ds_dlist.h>
+#include <osa_assert.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_module.h>
+
+#define OW_EV_MAX_OVERRUN_NSEC OSW_TIME_SEC(5)
+
+struct ow_ev_timer {
+    ev_prepare prepare;
+    ev_timer timer;
+};
+
+struct ow_ev_timer g_ev_timer;
+
+static void
+ow_ev_timer_cb(EV_P_ ev_timer *arg,
+               int events)
+{
+    const uint64_t now_nsec = osw_time_mono_clk();
+    osw_timer_core_dispatch(now_nsec);
+}
+
+static void
+ow_ev_prepare_cb(EV_P_ ev_prepare *arg,
+                 int events)
+{
+    struct ow_ev_timer *timer = container_of(arg, struct ow_ev_timer, prepare);
+    const uint64_t now_nsec = osw_time_mono_clk();
+    uint64_t next_at_nsec;
+    double next_at_dbl;
+    bool result;
+
+    result = osw_timer_core_get_next_at(&next_at_nsec);
+    if (result == false)
+        return;
+
+    if (next_at_nsec == 0) {
+        next_at_dbl = 0.;
+    }
+    else if (next_at_nsec >= now_nsec) {
+        next_at_dbl = OSW_TIME_TO_DBL(next_at_nsec - now_nsec);
+    }
+    else /* now_nsec > next_at_nsec, overrun */ {
+        next_at_dbl = 0.;
+        LOGD("ow: ev_timer: timer overrun next_at_nsec: %"PRIu64" is earlier than now_nsec: %"PRIu64", setting timer at sec: %.2f",
+             next_at_nsec, now_nsec, next_at_dbl);
+        const uint64_t overrun_nsec = now_nsec - next_at_nsec;
+        WARN_ON(overrun_nsec >= OW_EV_MAX_OVERRUN_NSEC);
+    }
+
+    ev_timer_stop(EV_A_ &timer->timer);
+    ev_timer_set(&timer->timer, next_at_dbl, 0.);
+    ev_timer_start(EV_A_ &timer->timer);
+}
+
+OSW_MODULE(ow_ev_timer)
+{
+    struct ev_loop *loop = OSW_MODULE_LOAD(osw_ev);
+
+    ev_prepare_init(&g_ev_timer.prepare, ow_ev_prepare_cb);
+    ev_timer_init(&g_ev_timer.timer, ow_ev_timer_cb, 0., 0.);
+    ev_prepare_start(loop, &g_ev_timer.prepare);
+    ev_timer_start(loop, &g_ev_timer.timer);
+
+    LOGI("ow: ev_timer: initialized");
+    return NULL;
+}
Index: core/src/lib/ow/src/ow_ovsdb.c
===================================================================
--- core.orig/src/lib/ow/src/ow_ovsdb.c
+++ core/src/lib/ow/src/ow_ovsdb.c
@@ -1,19 +1,21 @@
+#include <ev.h>
 #include <const.h>
 #include <util.h>
 #include <memutil.h>
-#include <osw.h>
 #include <osw_drv_dummy.h>
 #include <osw_state.h>
 #include <osw_ut.h>
-#include "ow_bus.h"
+#include <osw_module.h>
 #include "ow_conf.h"
 #include "ow_ovsdb_ms.h"
 #include "ow_ovsdb_steer.h"
+#include "ow_ovsdb_cconf.h"
+#include "ow_ovsdb_stats.h"
 #include <ovsdb.h>
 #include <ovsdb_table.h>
 #include <ovsdb_cache.h>
 #include <ovsdb_sync.h>
-#include <module.h>
+#include <schema_consts.h>
 
 #define OW_OVSDB_RETRY_SECONDS 5.0
 #define OW_OVSDB_VIF_FLAG_SEEN 0x01
@@ -27,7 +29,6 @@ static ovsdb_table_t table_Wifi_Radio_Co
 static ovsdb_table_t table_Wifi_Radio_State;
 static ovsdb_table_t table_Wifi_VIF_Config;
 static ovsdb_table_t table_Wifi_VIF_State;
-static ovsdb_table_t table_Wifi_Credential_Config;
 static ovsdb_table_t table_Wifi_Associated_Clients;
 static ovsdb_table_t table_Openflow_Tag;
 
@@ -37,7 +38,7 @@ struct ow_ovsdb {
     struct ds_tree sta_tree;
     struct ow_ovsdb_ms_root ms;
     struct ds_tree vif_cleanup_tree;
-    struct ow_ovsdb_steer steering;
+    struct ow_ovsdb_steer *steering;
 };
 
 struct ow_ovsdb_phy {
@@ -325,19 +326,47 @@ ow_ovsdb_phystate_fill_bcn_int(struct sc
 }
 
 static void
-ow_ovsdb_phystate_get_channel_iter_cb(const struct osw_state_vif_info *info,
-                                      void *priv)
+ow_ovsdb_phystate_get_channel_h_chan(const struct osw_channel *i,
+                                     void *priv)
 {
-    const struct osw_channel *i = &info->drv_state->u.ap.channel;
     struct osw_channel *c = priv;
 
-    if (info->drv_state->enabled == false) return;
-    if (info->drv_state->vif_type != OSW_VIF_AP) return;
     if (c->control_freq_mhz == 0) *c = *i;
     if (memcmp(c, i, sizeof(*c)) != 0) c->control_freq_mhz = -1;
 }
 
 static void
+ow_ovsdb_phystate_get_channel_h_ap(const struct osw_state_vif_info *info,
+                                   void *priv)
+{
+    const struct osw_channel *i = &info->drv_state->u.ap.channel;
+
+    if (info->drv_state->enabled == false) return;
+    if (info->drv_state->vif_type != OSW_VIF_AP) return;
+    ow_ovsdb_phystate_get_channel_h_chan(i, priv);
+}
+
+static void
+ow_ovsdb_phystate_get_channel_h_sta(const struct osw_state_vif_info *info,
+                                    void *priv)
+{
+    const struct osw_channel *i = &info->drv_state->u.sta.link.channel;
+
+    if (info->drv_state->enabled == false) return;
+    if (info->drv_state->vif_type != OSW_VIF_STA) return;
+    if (info->drv_state->u.sta.link.status != OSW_DRV_VIF_STATE_STA_LINK_CONNECTED) return;
+    ow_ovsdb_phystate_get_channel_h_chan(i, priv);
+}
+
+static void
+ow_ovsdb_phystate_get_channel_iter_cb(const struct osw_state_vif_info *info,
+                                      void *priv)
+{
+    ow_ovsdb_phystate_get_channel_h_ap(info, priv);
+    ow_ovsdb_phystate_get_channel_h_sta(info, priv);
+}
+
+static void
 ow_ovsdb_phystate_fill_channel(struct schema_Wifi_Radio_State *schema,
                                const struct osw_state_phy_info *phy)
 {
@@ -568,6 +597,26 @@ ow_ovsdb_phystate_to_schema(struct schem
     ow_ovsdb_phystate_fill_channels(schema, phy);
     ow_ovsdb_phystate_fix_no_vifs(schema, rconf);
 
+    if (strlen(phy->drv_state->reg_domain.ccode) == 2) {
+        const char *cc = phy->drv_state->reg_domain.ccode;
+        const int rev =  phy->drv_state->reg_domain.revision;
+        if (cc[0] == '0' && cc[1] == '0') {
+            char rev_str[8];
+            snprintf(rev_str, sizeof(rev_str), "%d", rev);
+            SCHEMA_KEY_VAL_APPEND(schema->hw_params, "country_id", "0");
+            SCHEMA_KEY_VAL_APPEND(schema->hw_params, "reg_domain", rev_str);
+        }
+        else {
+            if (phy->drv_state->reg_domain.revision == 0) {
+                SCHEMA_SET_STR(schema->country, cc);
+            }
+            else {
+                char country[32];
+                snprintf(country, sizeof(country), "%s/%d", cc, rev);
+                SCHEMA_SET_STR(schema->country, country);
+            }
+        }
+    }
     // FIXME: channels[], needed for DFS
     // FIXME: tx_power
     // FIXME: radar[] ?
@@ -615,7 +664,10 @@ ow_ovsdb_vifstate_fix_up_security(struct
                             wpa && !rsn ? "1" :
                             "0";
 
-    SCHEMA_KEY_VAL_APPEND(schema->security, "mode", mode_str);
+    if (SCHEMA_KEY_VAL_NULL(vconf->security, "mode") != NULL) {
+        SCHEMA_KEY_VAL_APPEND(schema->security, "mode", mode_str);
+    }
+
     SCHEMA_KEY_VAL_APPEND(schema->security, "encryption", "WPA-PSK");
     SCHEMA_SET_BOOL(schema->ft_psk, ft);
 
@@ -661,8 +713,8 @@ ow_ovsdb_mode_to_type(const char *mode)
 }
 
 static void
-ow_ovsdb_vifstate_fill_ap_akm(struct schema_Wifi_VIF_State *schema,
-                               const struct osw_wpa *wpa)
+ow_ovsdb_vifstate_fill_akm(struct schema_Wifi_VIF_State *schema,
+                            const struct osw_wpa *wpa)
 {
     /* FIXME: This isn't totally accurate, but good enough for now. */
 
@@ -681,6 +733,11 @@ ow_ovsdb_vifstate_fill_ap_akm(struct sch
     if (wpa->akm_ft_psk) {
         SCHEMA_VAL_APPEND(schema->wpa_key_mgmt, "ft-wpa2-psk");
     }
+    switch (wpa->pmf) {
+        case OSW_PMF_DISABLED: SCHEMA_SET_STR(schema->pmf, "disabled"); break;
+        case OSW_PMF_OPTIONAL: SCHEMA_SET_STR(schema->pmf, "optional"); break;
+        case OSW_PMF_REQUIRED: SCHEMA_SET_STR(schema->pmf, "required"); break;
+    }
 }
 
 static int
@@ -750,6 +807,7 @@ ow_ovsdb_vifstate_to_schema(struct schem
                             const struct osw_state_vif_info *vif)
 {
     const struct osw_drv_vif_state_ap *ap = &vif->drv_state->u.ap;
+    const struct osw_drv_vif_state_sta *vsta = &vif->drv_state->u.sta;
     struct osw_hwaddr_str mac;
     int c;
 
@@ -788,7 +846,7 @@ ow_ovsdb_vifstate_to_schema(struct schem
             if (c != 0)
                 SCHEMA_SET_INT(schema->channel, c);
 
-            ow_ovsdb_vifstate_fill_ap_akm(schema, &ap->wpa);
+            ow_ovsdb_vifstate_fill_akm(schema, &ap->wpa);
             ow_ovsdb_vifstate_fill_ap_psk(schema, &ap->psk_list);
             ow_ovsdb_vifstate_fill_ap_acl(schema, &ap->acl);
             ow_ovsdb_vifstate_fix_min_hw_mode(schema, vconf);
@@ -798,6 +856,44 @@ ow_ovsdb_vifstate_to_schema(struct schem
             break;
         case OSW_VIF_STA:
             SCHEMA_SET_STR(schema->mode, "sta");
+            switch (vsta->link.status) {
+                case OSW_DRV_VIF_STATE_STA_LINK_CONNECTED:
+                    SCHEMA_SET_STR(schema->ssid, vsta->link.ssid.buf);
+                    if (osw_hwaddr_is_zero(&vsta->link.bssid) == false) {
+                        SCHEMA_SET_STR(schema->parent, osw_hwaddr2str(&vsta->link.bssid, &mac));
+                    }
+                    SCHEMA_SET_BOOL(schema->wpa, vsta->link.wpa.wpa || vsta->link.wpa.rsn);
+                    if (strlen(vsta->link.psk.str) > 0) {
+                        SCHEMA_KEY_VAL_APPEND(schema->wpa_psks, "key", vsta->link.psk.str);
+                    }
+                    ow_ovsdb_vifstate_fill_akm(schema, &vsta->link.wpa);
+
+                    c = ow_ovsdb_freq_to_chan(vsta->link.channel.control_freq_mhz);
+                    if (c != 0)
+                        SCHEMA_SET_INT(schema->channel, c);
+
+                    /* FIXME: something in the above is hard-required by controller; otherwise it removes valid entries.. */
+                    SCHEMA_SET_BOOL(schema->ap_bridge, true);
+                    SCHEMA_SET_BOOL(schema->dynamic_beacon, false);
+                    SCHEMA_SET_BOOL(schema->mcast2ucast, false);
+                    SCHEMA_SET_INT(schema->ft_psk, 0);
+                    SCHEMA_SET_INT(schema->rrm, 0);
+                    SCHEMA_SET_STR(schema->bridge, "");
+                    SCHEMA_SET_STR(schema->wps_pbc_key_id, "");
+                    SCHEMA_SET_STR(schema->dpp_connector, "");
+                    SCHEMA_SET_STR(schema->dpp_csign_hex, "");
+                    SCHEMA_SET_STR(schema->dpp_netaccesskey_hex, "");
+                    SCHEMA_SET_STR(schema->mac_list_type, "none");
+                    SCHEMA_SET_STR(schema->multi_ap, "none");
+                    SCHEMA_SET_STR(schema->ssid_broadcast, "enabled");
+                    SCHEMA_SET_BOOL(schema->uapsd_enable, false);
+                    SCHEMA_SET_BOOL(schema->wds, false);
+                    break;
+                case OSW_DRV_VIF_STATE_STA_LINK_UNKNOWN:
+                case OSW_DRV_VIF_STATE_STA_LINK_CONNECTING:
+                case OSW_DRV_VIF_STATE_STA_LINK_DISCONNECTED:
+                    break;
+            }
             break;
     }
 
@@ -2102,6 +2198,16 @@ ow_ovsdb_vconf_to_ow_conf_ap(const struc
         }
     }
 
+    if (is_new == true || vconf->wps_changed == true) {
+        if (vconf->wps_exists == true) {
+            const bool x = vconf->wps;
+            ow_conf_vif_set_ap_wps(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_wps(vconf->if_name, NULL);
+        }
+    }
+
     if (is_new == true || vconf->wpa_changed == true || vconf->security_changed == true)
         ow_ovsdb_vconf_to_ow_conf_ap_wpa(vconf);
 
@@ -2117,6 +2223,62 @@ ow_ovsdb_vconf_to_ow_conf_ap(const struc
 }
 
 static void
+ow_ovsdb_fill_wpa_akm(struct osw_wpa *wpa, const char *akm)
+{
+    if (strcmp(akm, "wpa-psk") == 0) {
+        wpa->wpa = true;
+        wpa->akm_psk = true;
+    }
+    else if (strcmp(akm, "wpa2-psk") == 0) {
+        wpa->rsn = true;
+        wpa->akm_psk = true;
+    }
+    else if (strcmp(akm, "sae") == 0) {
+        wpa->rsn = true;
+        wpa->akm_sae = true;
+    }
+}
+
+static void
+ow_ovsdb_vconf_to_ow_conf_sta(const struct schema_Wifi_VIF_Config *vconf,
+                              const bool is_new)
+{
+    if (ow_ovsdb_cconf_use_vconf(vconf) == true) {
+        struct osw_ssid ssid = {0};
+        struct osw_hwaddr bssid = {0};
+        struct osw_psk psk = {0};
+        struct osw_wpa wpa = {0};
+
+        STRSCPY_WARN(psk.str, vconf->wpa_psks[0]);
+        STRSCPY_WARN(ssid.buf, vconf->ssid);
+        ssid.len = strlen(vconf->ssid);
+        osw_hwaddr_from_cstr(vconf->parent, &bssid);
+
+        int i;
+        for (i = 0; i < vconf->wpa_key_mgmt_len; i++) {
+            ow_ovsdb_fill_wpa_akm(&wpa, vconf->wpa_key_mgmt[i]);
+        }
+
+        wpa.pairwise_tkip = vconf->wpa_pairwise_tkip
+                         || vconf->rsn_pairwise_tkip;
+        wpa.pairwise_ccmp = vconf->wpa_pairwise_ccmp
+                         || vconf->rsn_pairwise_ccmp;
+
+        wpa.pmf = (strcmp(vconf->pmf, SCHEMA_CONSTS_SECURITY_PMF_DISABLED) == 0) ? OSW_PMF_DISABLED
+                : (strcmp(vconf->pmf, SCHEMA_CONSTS_SECURITY_PMF_OPTIONAL) == 0) ? OSW_PMF_OPTIONAL
+                : (strcmp(vconf->pmf, SCHEMA_CONSTS_SECURITY_PMF_REQUIRED) == 0) ? OSW_PMF_REQUIRED
+                : OSW_PMF_DISABLED;
+
+        /* FIXME: Optimize to not overwrite it all the time */
+        ow_conf_vif_flush_sta_net(vconf->if_name);
+        ow_conf_vif_set_sta_net(vconf->if_name, &ssid, &bssid, &psk, &wpa);
+    }
+    else {
+        ow_ovsdb_cconf_sched();
+    }
+}
+
+static void
 ow_ovsdb_vconf_to_ow_conf(const struct schema_Wifi_VIF_Config *vconf,
                           const bool is_new)
 {
@@ -2150,11 +2312,160 @@ ow_ovsdb_vconf_to_ow_conf(const struct s
         case OSW_VIF_AP_VLAN:
             break;
         case OSW_VIF_STA:
+            ow_ovsdb_vconf_to_ow_conf_sta(vconf, is_new);
             break;
     }
 }
 
 static void
+ow_ovsdb_vconf_strip_legacy_akm(void *buf,
+                                int *n,
+                                int str_len,
+                                int arr_len)
+{
+    const size_t size = str_len * arr_len;
+    char copy[size];
+    char *in = copy;
+    char *out = buf;
+    bool psk = false;
+    bool eap = false;
+    bool ft = false;
+
+    memcpy(copy, buf, size);
+    for (*n = 0; arr_len; arr_len--, in += str_len) {
+        if (in[0] == 0) continue;
+        if (strncmp(in, SCHEMA_CONSTS_KEY_WPA_PSK, str_len) == 0 ||
+            strncmp(in, SCHEMA_CONSTS_KEY_WPA2_PSK, str_len) == 0) {
+            if (psk == false) {
+                strscpy(out, SCHEMA_CONSTS_KEY_WPA_PSK, str_len);
+                out += str_len;
+                (*n)++;
+                psk = true;
+            }
+        }
+        else if (strncmp(in, SCHEMA_CONSTS_KEY_WPA_EAP, str_len) == 0 ||
+                 strncmp(in, SCHEMA_CONSTS_KEY_WPA2_EAP, str_len) == 0) {
+            if (eap == false) {
+                strscpy(out, SCHEMA_CONSTS_KEY_WPA_EAP, str_len);
+                out += str_len;
+                (*n)++;
+                eap = true;
+            }
+        }
+        else if (strncmp(in, SCHEMA_CONSTS_KEY_FT_PSK, str_len) == 0 ||
+                 strncmp(in, SCHEMA_CONSTS_KEY_FT_WPA2_PSK, str_len) == 0) {
+            if (ft == false) {
+                strscpy(out, SCHEMA_CONSTS_KEY_FT_PSK, str_len);
+                out += str_len;
+                (*n)++;
+                ft = true;
+            }
+        }
+        else {
+            strscpy(out, in, str_len);
+            out += str_len;
+            (*n)++;
+        }
+    }
+}
+
+static bool
+ow_ovsdb_vconf_uses_legacy_tkip(const struct schema_Wifi_VIF_Config *vconf)
+{
+    int i;
+    for (i = 0; i < vconf->wpa_key_mgmt_len; i++) {
+        const char *akm = vconf->wpa_key_mgmt[i];
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_WPA_PSK) == 0) return true;
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_WPA2_PSK) == 0) continue;
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_WPA2_EAP) == 0) continue;
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_FT_WPA2_PSK) == 0) continue;
+    }
+    return false;
+}
+
+static bool
+ow_ovsdb_vconf_uses_legacy_ccmp(const struct schema_Wifi_VIF_Config *vconf)
+{
+    int i;
+    for (i = 0; i < vconf->wpa_key_mgmt_len; i++) {
+        const char *akm = vconf->wpa_key_mgmt[i];
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_WPA_PSK) == 0) continue;
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_WPA2_PSK) == 0) return true;
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_WPA2_EAP) == 0) return true;
+        if (strcmp(akm, SCHEMA_CONSTS_KEY_FT_WPA2_PSK) == 0) return true;
+    }
+    return false;
+}
+
+static bool
+ow_ovsdb_vconf_uses_legacy_akm(const struct schema_Wifi_VIF_Config *vconf)
+{
+    if (vconf->wpa_pairwise_tkip_exists == true) return false;
+    if (vconf->wpa_pairwise_ccmp_exists == true) return false;
+    if (vconf->rsn_pairwise_tkip_exists == true) return false;
+    if (vconf->rsn_pairwise_ccmp_exists == true) return false;
+    return true;
+}
+
+static void
+ow_ovsdb_vconf_fixup_pairwise(struct schema_Wifi_VIF_Config *vconf)
+{
+    if (ow_ovsdb_vconf_uses_legacy_akm(vconf) == false) return;
+    const bool tkip = ow_ovsdb_vconf_uses_legacy_tkip(vconf);
+    const bool ccmp = ow_ovsdb_vconf_uses_legacy_ccmp(vconf);
+    SCHEMA_SET_BOOL(vconf->wpa_pairwise_tkip, tkip);
+    SCHEMA_SET_BOOL(vconf->rsn_pairwise_ccmp, ccmp);
+    SCHEMA_SET_STR(vconf->pmf, SCHEMA_CONSTS_SECURITY_PMF_DISABLED);
+    ow_ovsdb_vconf_strip_legacy_akm(vconf->wpa_key_mgmt,
+                                    &vconf->wpa_key_mgmt_len,
+                                    sizeof(vconf->wpa_key_mgmt[0]),
+                                    ARRAY_SIZE(vconf->wpa_key_mgmt));
+}
+
+static void
+ow_ovsdb_vconf_fixup_security(struct schema_Wifi_VIF_Config *vconf)
+{
+    const bool is_vsta = (strcmp(vconf->mode, "sta") == 0);
+    const bool legacy_config = (vconf->security_len > 0);
+
+    if (legacy_config == false) return;
+    if (is_vsta == false) return;
+
+    bool wpa = false;
+    int mode = 0;
+    int i;
+    for (i = 0; i < vconf->security_len; i++) {
+        const char *k = vconf->security_keys[i];
+        const char *v = vconf->security[i];
+
+        if (strcmp(k, "mode") == 0) {
+            mode = atoi(v);
+        }
+        if (strcmp(k, "encryption") == 0) {
+            if (strcmp(v, "WPA-PSK") == 0) wpa = true;
+        }
+        if (strstr(k, "key") == k) {
+            SCHEMA_KEY_VAL_APPEND(vconf->wpa_psks, k, v);
+        }
+    }
+
+    if (wpa == true) {
+        SCHEMA_SET_BOOL(vconf->wpa, true);
+        if (mode == 0) mode = 2;
+        if (mode & 1) {
+            SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "wpa-psk");
+            SCHEMA_SET_BOOL(vconf->wpa_pairwise_tkip, true);
+        }
+        if (mode & 2) {
+            SCHEMA_SET_BOOL(vconf->rsn_pairwise_ccmp, true);
+            SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "wpa2-psk");
+        }
+        SCHEMA_SET_STR(vconf->pmf, "disabled");
+    }
+
+}
+
+static void
 callback_Wifi_VIF_Config(ovsdb_update_monitor_t *mon,
                          struct schema_Wifi_VIF_Config *old,
                          struct schema_Wifi_VIF_Config *vconf,
@@ -2169,14 +2480,18 @@ callback_Wifi_VIF_Config(ovsdb_update_mo
           mon->mon_type == OVSDB_UPDATE_ERROR ? "error" :
           ""));
 
-    if (strcmp(vconf->mode, "ap")) return; /* only AP is supported for now */
-
     switch (mon->mon_type) {
         case OVSDB_UPDATE_NEW:
             ow_ovsdb_vstate_fix_vif_config(vconf);
             /* fall through */
         case OVSDB_UPDATE_MODIFY:
-            ow_ovsdb_vconf_to_ow_conf(vconf, is_new);
+            {
+                struct schema_Wifi_VIF_Config vconf2;
+                memcpy(&vconf2, vconf, sizeof(vconf2));
+                ow_ovsdb_vconf_fixup_security(&vconf2);
+                ow_ovsdb_vconf_fixup_pairwise(&vconf2);
+                ow_ovsdb_vconf_to_ow_conf(&vconf2, is_new);
+            }
             ow_ovsdb_vif_set_config(vconf->if_name, vconf);
             break;
         case OVSDB_UPDATE_DEL:
@@ -2222,7 +2537,9 @@ ow_ovsdb_retry_cb(EV_P_ ev_timer *arg, i
     OVSDB_CACHE_MONITOR(Wifi_VIF_State, true);
 
     ow_ovsdb_ms_init(&g_ow_ovsdb.ms);
-    ow_ovsdb_steer_init(&g_ow_ovsdb.steering);
+    ow_ovsdb_cconf_init(&table_Wifi_VIF_Config);
+    ow_ovsdb_stats_init();
+    g_ow_ovsdb.steering = ow_ovsdb_steer_create();
     ow_ovsdb_flush();
     osw_state_register_observer(&g_ow_ovsdb_osw_state_obs);
     ev_timer_stop(EV_A_ arg);
@@ -2230,8 +2547,8 @@ ow_ovsdb_retry_cb(EV_P_ ev_timer *arg, i
     LOGI("ow: ovsdb: ready");
 }
 
-void
-ow_ovsdb_init(struct ow_bus_ops *ops)
+static void
+ow_ovsdb_init(void)
 {
     static bool initialized;
 
@@ -2241,7 +2558,6 @@ ow_ovsdb_init(struct ow_bus_ops *ops)
     OVSDB_TABLE_INIT(Wifi_Radio_State, if_name);
     OVSDB_TABLE_INIT(Wifi_VIF_Config, if_name);
     OVSDB_TABLE_INIT(Wifi_VIF_State, if_name);
-    OVSDB_TABLE_INIT(Wifi_Credential_Config, _uuid);
     OVSDB_TABLE_INIT(Wifi_Associated_Clients, mac);
     OVSDB_TABLE_INIT(Openflow_Tag, name);
 
@@ -2260,31 +2576,17 @@ ow_ovsdb_enabled(void)
         return false;
 }
 
-static void
-ow_ovsdb_module_init(void *arg)
+OSW_MODULE(ow_ovsdb)
 {
-    static struct ow_bus_ops ops = {
-        .name = "ovsdb",
-        .init_fn = ow_ovsdb_init,
-    };
-
     if (ow_ovsdb_enabled() == false) {
         LOGI("ow: ovsdb: disabled");
-        return;
+        return NULL;
     }
 
-    ow_bus_register_ops(&ops);
-}
-
-static void
-ow_ovsdb_module_fini(void *arg)
-{
+    ow_ovsdb_init();
+    return NULL;
 }
 
-MODULE(ow_ovsdb_module,
-       ow_ovsdb_module_init,
-       ow_ovsdb_module_fini);
-
 struct ow_ovsdb_ut {
     ev_async async;
 };
@@ -2336,9 +2638,9 @@ ow_ovsdb_ut_run(void)
 static void
 ow_ovsdb_ut_init(void)
 {
-    osw_init();
-    ow_conf_init();
-    ow_ovsdb_init(NULL);
+    osw_module_load_name("osw_drv");
+    osw_module_load_name("ow_conf");
+    ow_ovsdb_init();
     while (ev_is_active(&g_ow_ovsdb_retry))
         ev_run(EV_DEFAULT_ EVRUN_ONCE);
 
@@ -2351,8 +2653,7 @@ ow_ovsdb_ut_init(void)
     ow_ovsdb_ut_run();
 }
 
-static void
-ow_ovsdb_ut_rconf_cb(void *arg)
+OSW_UT(ow_ovsdb_ut_rconf)
 {
     const char *phy_name = "phy1";
     struct schema_Wifi_Radio_Config rconf = {0};
@@ -2375,8 +2676,7 @@ ow_ovsdb_ut_rconf_cb(void *arg)
     assert(ow_conf_phy_is_set(phy_name) == false);
 }
 
-static void
-ow_ovsdb_ut_vconf_cb(void *arg)
+OSW_UT(ow_ovsdb_ut_vconf)
 {
     const char *phy_name = "phy1";
     struct schema_Wifi_Radio_Config rconf = {0};
@@ -2432,8 +2732,7 @@ ow_ovsdb_ut_vconf_cb(void *arg)
     assert(strcmp(ow_conf_vif_get_phy_name(vif_name), phy_name) == 0);
 }
 
-static void
-ow_ovsdb_ut_rstate_cb(void *arg)
+OSW_UT(ow_ovsdb_ut_rstate)
 {
     struct schema_Wifi_Radio_State rstate = {0};
     const struct osw_state_phy_info phy = {
@@ -2456,8 +2755,7 @@ ow_ovsdb_ut_rstate_cb(void *arg)
     assert(rstate.tx_chainmask == phy.drv_state->tx_chainmask);
 }
 
-static void
-ow_ovsdb_ut_rstate_bcn_int_cb(void *arg)
+OSW_UT(ow_ovsdb_ut_rstate_bcn_int)
 {
     struct schema_Wifi_Radio_State rstate = {0};
     const struct osw_state_phy_info phy = {
@@ -2506,7 +2804,7 @@ ow_ovsdb_ut_rstate_bcn_int_cb(void *arg)
     SCHEMA_SET_STR(vconf1.if_name, vif1_100.vif_name);
     SCHEMA_SET_STR(vconf2.if_name, vif2.vif_name);
 
-    osw_init();
+    osw_module_load_name("osw_drv");
     osw_drv_dummy_init(&dummy);
 
     ow_ovsdb_ut_init();
@@ -2537,8 +2835,7 @@ ow_ovsdb_ut_rstate_bcn_int_cb(void *arg)
     assert(rstate.bcn_int == vif1_200.drv_state->u.ap.beacon_interval_tu);
 }
 
-static void
-ow_ovsdb_ut_vstate_cb(void *arg)
+OSW_UT(ow_ovsdb_ut_vstate)
 {
     struct schema_Wifi_Radio_State rstate = {0};
     struct schema_Wifi_VIF_State vstate = {0};
@@ -2617,8 +2914,7 @@ ow_ovsdb_ut_vstate_cb(void *arg)
     assert(vstate.vif_config_exists == true);
 }
 
-static void
-ow_ovsdb_ut_rstate_channel_cb(void *arg)
+OSW_UT(ow_ovsdb_ut_rstate_channel)
 {
     struct schema_Wifi_Radio_State rstate = {0};
     const struct osw_state_phy_info phy = {
@@ -2677,7 +2973,7 @@ ow_ovsdb_ut_rstate_channel_cb(void *arg)
     SCHEMA_SET_STR(vconf1.if_name, vif1_c1w20.vif_name);
     SCHEMA_SET_STR(vconf2.if_name, vif2_c1w20.vif_name);
 
-    osw_init();
+    osw_module_load_name("osw_drv");
     osw_drv_dummy_init(&dummy);
 
     ow_ovsdb_ut_init();
@@ -2722,8 +3018,7 @@ ow_ovsdb_ut_rstate_channel_cb(void *arg)
     assert(rstate.ht_mode_exists == false);
 }
 
-static void
-ow_ovsdb_ut_freq_band_cb(void *arg)
+OSW_UT(ow_ovsdb_ut_freq_band)
 {
     struct osw_drv_phy_state state = {0};
     struct osw_channel_state cs_2g[] = {
@@ -2800,8 +3095,7 @@ ow_ovsdb_ut_freq_band_cb(void *arg)
     assert(str == NULL);
 }
 
-static void
-ow_ovsdb_ut_phy_mem_cb(void *data)
+OSW_UT(ow_ovsdb_ut_phy_mem)
 {
     struct osw_drv_phy_state pstate = {0};
     struct osw_state_phy_info pinfo = {
@@ -2846,8 +3140,7 @@ ow_ovsdb_ut_phy_mem_cb(void *data)
     assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) == NULL);
 }
 
-static void
-ow_ovsdb_ut_sta_cb(void *data)
+OSW_UT(ow_ovsdb_ut_sta)
 {
     struct osw_channel_state cs_2g[] = {
             { .channel = { .control_freq_mhz = 2412 } },
@@ -2904,7 +3197,7 @@ ow_ovsdb_ut_sta_cb(void *data)
     SCHEMA_KEY_VAL_APPEND(vconf1.wpa_oftags, "key-1", "hello");
     SCHEMA_KEY_VAL_APPEND(vconf1.security, "oftag-key-2", "world");
 
-    osw_init();
+    osw_module_load_name("osw_drv");
     osw_drv_dummy_init(&dummy);
 
     ow_ovsdb_ut_init();
@@ -2932,25 +3225,32 @@ ow_ovsdb_ut_sta_cb(void *data)
     ow_ovsdb_ut_run();
 }
 
-static void
-ow_ovsdb_ut_module_init(void *arg)
+OSW_UT(ow_ovsdb_vconf_strip_legacy_akm)
 {
-    osw_ut_register("ow_ovsdb_ut_rconf", ow_ovsdb_ut_rconf_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_vconf", ow_ovsdb_ut_vconf_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_rstate", ow_ovsdb_ut_rstate_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_rstate_bcn_int", ow_ovsdb_ut_rstate_bcn_int_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_rstate_channel", ow_ovsdb_ut_rstate_channel_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_vstate", ow_ovsdb_ut_vstate_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_freq_band", ow_ovsdb_ut_freq_band_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_phy_mem", ow_ovsdb_ut_phy_mem_cb, NULL);
-    osw_ut_register("ow_ovsdb_ut_sta", ow_ovsdb_ut_sta_cb, NULL);
-}
+    struct schema_Wifi_VIF_Config vconf = {0};
 
-static void
-ow_ovsdb_ut_module_fini(void *arg)
-{
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, "test");
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, SCHEMA_CONSTS_KEY_WPA2_PSK);
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, SCHEMA_CONSTS_KEY_WPA2_EAP);
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, SCHEMA_CONSTS_KEY_FT_WPA2_PSK);
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, "test2");
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, SCHEMA_CONSTS_KEY_WPA_EAP);
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, SCHEMA_CONSTS_KEY_WPA_PSK);
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, SCHEMA_CONSTS_KEY_FT_PSK);
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, "test3");
+    SCHEMA_VAL_APPEND(vconf.wpa_key_mgmt, "test");
+
+    ow_ovsdb_vconf_strip_legacy_akm(vconf.wpa_key_mgmt,
+                                    &vconf.wpa_key_mgmt_len,
+                                    sizeof(vconf.wpa_key_mgmt[0]),
+                                    ARRAY_SIZE(vconf.wpa_key_mgmt));
+
+    assert(vconf.wpa_key_mgmt_len == 7);
+    assert(strcmp(vconf.wpa_key_mgmt[0], "test") == 0);
+    assert(strcmp(vconf.wpa_key_mgmt[1], SCHEMA_CONSTS_KEY_WPA_PSK) == 0);
+    assert(strcmp(vconf.wpa_key_mgmt[2], SCHEMA_CONSTS_KEY_WPA_EAP) == 0);
+    assert(strcmp(vconf.wpa_key_mgmt[3], SCHEMA_CONSTS_KEY_FT_PSK) == 0);
+    assert(strcmp(vconf.wpa_key_mgmt[4], "test2") == 0);
+    assert(strcmp(vconf.wpa_key_mgmt[5], "test3") == 0);
+    assert(strcmp(vconf.wpa_key_mgmt[6], "test") == 0);
 }
-
-MODULE(ow_ovsdb_ut_module,
-       ow_ovsdb_ut_module_init,
-       ow_ovsdb_ut_module_fini);
Index: core/src/lib/ow/src/ow_ovsdb.h
===================================================================
--- core.orig/src/lib/ow/src/ow_ovsdb.h
+++ core/src/lib/ow/src/ow_ovsdb.h
@@ -1,4 +1,4 @@
-#ifndef OW_OVSDB_H
-#define OW_OVSDB_H
+#ifndef OW_OVSDB_H_INCLUDED
+#define OW_OVSDB_H_INCLUDED
 
-#endif /* OW_OVSDB_H */
+#endif /* OW_OVSDB_H_INCLUDED */
Index: core/src/lib/ow/src/ow_ovsdb_cconf.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_ovsdb_cconf.c
@@ -0,0 +1,114 @@
+#include <ev.h>
+#include <ovsdb.h>
+#include <ovsdb_table.h>
+#include <ovsdb_cache.h>
+#include <ovsdb_sync.h>
+#include "ow_conf.h"
+
+static ovsdb_table_t table_Wifi_Credential_Config;
+static ovsdb_table_t *table_Wifi_VIF_Config;
+static ev_timer g_ow_ovsdb_cconf_timer;
+
+static void
+ow_ovsdb_cconf_apply_on_vif(const char *vif_name, struct ds_tree *cc_rows)
+{
+    LOGD("ow: ovsdb: cconf: applying: %s", vif_name);
+
+    ow_conf_vif_flush_sta_net(vif_name);
+
+    ovsdb_cache_row_t *i;
+    ds_tree_foreach(cc_rows, i) {
+        struct osw_wpa wpa = {0};
+        struct osw_psk psk = {0};
+        struct osw_ssid ssid = {0};
+        const struct osw_hwaddr bssid = {0};
+        const struct schema_Wifi_Credential_Config *c = (const void *)i->record;
+        const char *pass = SCHEMA_KEY_VAL(c->security, "key");
+
+        /* FIXME: Technically each vif_config carries
+         * a list of credential config uuids. These
+         * should be used to link between VIF_Config
+         * and Credential_Config.
+         */
+
+        /* FIXME: Wifi_Credential_Config doesn't support new
+         * style wpa_key_mgmt etc.  columns like
+         * Wifi_VIF_Config does now. It was always implied
+         * that Wifi_Credential_Config entries are
+         * wpa2-only, hence hardocding it for the time being
+         * until Wifi_Credential_Config gets a revamp to
+         * allow expressing, eg. SAE, or DPP.
+         */
+        wpa.rsn = true;
+        wpa.pairwise_ccmp = true;
+        wpa.akm_psk = true;
+
+        STRSCPY_WARN(psk.str, pass);
+        STRSCPY_WARN(ssid.buf, c->ssid);
+        ssid.len = strlen(ssid.buf);
+
+        ow_conf_vif_set_sta_net(vif_name, &ssid, &bssid, &psk, &wpa);
+    }
+}
+
+static void
+ow_ovsdb_cconf_apply(struct ds_tree *v_rows,
+                     struct ds_tree *cc_rows)
+{
+    LOGD("ow: ovsdb: cconf: applying");
+
+    ovsdb_cache_row_t *i;
+    ds_tree_foreach(v_rows, i) {
+        const struct schema_Wifi_VIF_Config *v = (const void *)i->record;
+        const bool is_sta = (strcmp(v->mode, "sta") == 0);
+        const bool has_ssid = strlen(v->ssid) > 0;
+
+        if (is_sta == false) continue;
+        if (has_ssid == true) continue;
+
+        ow_ovsdb_cconf_apply_on_vif(v->if_name, cc_rows);
+    }
+}
+
+static void
+ow_ovsdb_cconf_timer_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct ds_tree *cc_rows = &table_Wifi_Credential_Config.rows;
+    struct ds_tree *v_rows = &table_Wifi_VIF_Config->rows;
+    ow_ovsdb_cconf_apply(v_rows, cc_rows);
+}
+
+void
+ow_ovsdb_cconf_sched(void)
+{
+    struct ev_timer *t = &g_ow_ovsdb_cconf_timer;
+    ev_timer_stop(EV_DEFAULT_ t);
+    ev_timer_set(t, 0, 0);
+    ev_timer_start(EV_DEFAULT_ t);
+    LOGT("ow: ovsdb: cconf: scheduled");
+}
+
+static void
+callback_Wifi_Credential_Config(ovsdb_update_monitor_t *mon,
+                                struct schema_Wifi_Credential_Config *old,
+                                struct schema_Wifi_Credential_Config *cconf,
+                                ovsdb_cache_row_t *row)
+{
+    ow_ovsdb_cconf_sched();
+}
+
+void
+ow_ovsdb_cconf_init(ovsdb_table_t *vconft)
+{
+    struct ev_timer *t = &g_ow_ovsdb_cconf_timer;
+    ev_timer_init(t, ow_ovsdb_cconf_timer_cb, 0, 0);
+    table_Wifi_VIF_Config = vconft;
+    OVSDB_TABLE_INIT(Wifi_Credential_Config, _uuid);
+    OVSDB_CACHE_MONITOR(Wifi_Credential_Config, true);
+}
+
+bool
+ow_ovsdb_cconf_use_vconf(const struct schema_Wifi_VIF_Config *vconf)
+{
+    return strlen(vconf->ssid) > 0;
+}
Index: core/src/lib/ow/src/ow_ovsdb_cconf.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_ovsdb_cconf.h
@@ -0,0 +1,14 @@
+#ifndef OW_OVSDB_CCONF_H_INCLUDED
+#define OW_OVSDB_CCONF_H_INCLUDED
+
+void
+ow_ovsdb_cconf_init(ovsdb_table_t *vconft);
+
+void
+ow_ovsdb_cconf_sched(void);
+
+bool
+ow_ovsdb_cconf_use_vconf(const struct schema_Wifi_VIF_Config *vconf);
+
+#endif /* OW_OVSDB_CCONF_H_INCLUDED */
+
Index: core/src/lib/ow/src/ow_ovsdb_csa.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_ovsdb_csa.c
@@ -0,0 +1,141 @@
+#include <log.h>
+#include <const.h>
+#include <osw_module.h>
+#include <osw_state.h>
+#include <ovsdb_table.h>
+#include <ovsdb_sync.h>
+
+/**
+ * Purpose:
+ *
+ * This provides a legacy way of updating the local data
+ * model of OVSDB to match the soon-to-be topology change by
+ * inheriting the CSA channel from a parent (when acting as
+ * a leaf).
+ *
+ * Reason:
+ *
+ * There's an ambiguity of what a leaf device should do if
+ * it's implicitly moved to a new channel and then loses a
+ * connection - should it stick to the Wifi_Radio_Config
+ * implied channel (ie. move back to some other channel if
+ * there was a STA-related CSA before), or should it stick
+ * to the last STA interface channel. This policy has been
+ * left undefined and therefore needs this behaviour in
+ * order to provide sane default behavior. Without the
+ * policy there's no other way to address this other than
+ * implicitly influencing data model adapters by
+ * reconfiguring the underlying configuration locally,
+ * effectively overriding what a remote controller requested
+ * before.
+ *
+ * Future:
+ *
+ * If the data model becomes able to express the
+ * channel-stickiness policy explicitly, then this override
+ * will become unnecessary since data model related modules
+ * will be able to take care of this ambiguity in more
+ * explicit way on their own.
+ */
+
+#define LOG_PREFIX "ow: ovsdb: csa: "
+
+struct ow_ovsdb_csa {
+    struct osw_state_observer state_obs;
+    ovsdb_table_t table;
+};
+
+static json_t *
+ow_ovsdb_csa_where_rconf(const char *phy_name,
+                         const json_int_t chan)
+{
+    json_t *where = json_array();
+    json_t *j_ifname = json_string(phy_name);
+    json_t *j_chan = json_integer(chan);
+    json_t *w_ifname = ovsdb_tran_cond_single_json(SCHEMA_COLUMN(Wifi_Radio_Config, if_name),
+                                                   OFUNC_EQ,
+                                                   j_ifname);
+    json_t *w_channel = ovsdb_tran_cond_single_json(SCHEMA_COLUMN(Wifi_Radio_Config, channel),
+                                                    OFUNC_NEQ,
+                                                    j_chan);
+    json_array_append(where, w_ifname);
+    json_array_append(where, w_channel);
+    return where;
+}
+
+static void
+ow_ovsdb_csa_fix_rconf(struct ow_ovsdb_csa *m,
+                       const char *phy_name,
+                       const struct osw_channel *channel)
+{
+    struct schema_Wifi_Radio_Config rconf = {0};
+    const int freq = channel->control_freq_mhz;
+    const int chan = osw_freq_to_chan(freq);
+
+    json_t *where = ow_ovsdb_csa_where_rconf(phy_name, chan);
+    if (WARN_ON(where == NULL)) return;
+
+    rconf._partial_update = true;
+    SCHEMA_SET_STR(rconf.if_name, phy_name);
+    SCHEMA_SET_INT(rconf.channel, chan);
+
+    const bool ok = ovsdb_table_update_where(&m->table, where, &rconf);
+
+    if (ok == false) return;
+
+    LOGN(LOG_PREFIX"%s: overriding channel: %d", phy_name, chan);
+
+    return;
+
+}
+
+static void
+ow_ovsdb_csa_rx_cb(struct osw_state_observer *obs,
+                   const struct osw_state_vif_info *vif,
+                   const struct osw_channel *channel)
+{
+    struct ow_ovsdb_csa *m = container_of(obs, struct ow_ovsdb_csa, state_obs);
+    const char *phy_name = vif->phy->phy_name;
+    const struct osw_drv_vif_state_sta_link *link = &vif->drv_state->u.sta.link;
+    const bool connected = (link->status == OSW_DRV_VIF_STATE_STA_LINK_CONNECTED);
+    const bool bw_mismatch = (link->channel.width != channel->width);
+
+    /* This module isn't really expected to adjust
+     * configured channel width, but it does make sense to
+     * log attempts where CSA would imply a different one.
+     */
+    if (connected && bw_mismatch) {
+        LOGN(LOG_PREFIX"%s: cowardly refusing to handle width change: "OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+            phy_name,
+            OSW_CHANNEL_ARG(&link->channel),
+            OSW_CHANNEL_ARG(channel));
+    }
+
+    ow_ovsdb_csa_fix_rconf(m, phy_name, channel);
+}
+
+static void
+mod_init(struct ow_ovsdb_csa *m)
+{
+    const struct osw_state_observer obs = {
+        .name = __FILE__,
+        .vif_csa_rx_fn = ow_ovsdb_csa_rx_cb,
+    };
+
+    m->state_obs = obs;
+    OVSDB_TABLE_VAR_INIT(&m->table, Wifi_Radio_Config, if_name);
+}
+
+static void
+mod_attach(struct ow_ovsdb_csa *m)
+{
+    osw_state_register_observer(&m->state_obs);
+}
+
+OSW_MODULE(ow_ovsdb_csa)
+{
+    static struct ow_ovsdb_csa m;
+    mod_init(&m);
+    mod_attach(&m);
+    return &m;
+}
Index: core/src/lib/ow/src/ow_ovsdb_dfs_backup.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_ovsdb_dfs_backup.c
@@ -0,0 +1,187 @@
+#include <memutil.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <const.h>
+#include <log.h>
+
+#include <ovsdb.h>
+#include <ovsdb_cache.h>
+
+#include <osw_ut.h>
+#include <osw_types.h>
+#include <osw_module.h>
+#include "ow_dfs_backup.h"
+
+/*
+ * Purpose:
+ *
+ * Perform legacy style parent change upon dfs connection
+ * loss on a sta interface.
+ *
+ * Description:
+ *
+ * Historically the device would self-modify
+ * Wifi_Radio_Config, Wifi_VIF_Config and Wifi_Inet_Config
+ * tables accordingly upon dfs connection loss. This is less
+ * than ideal long-term, but this does provide a smooth way
+ * to transition away with the new codebase.
+ *
+ * Future:
+ *
+ * This module will hopefully be replaced by a mutator-based
+ * parent override and an explicit unlatching commands from
+ * the controller.
+ *
+ * Notes:
+ *
+ * This does 2 things actually, arguably unnecessarily. It
+ * feeds ow_dfs_backup with ovsdb (data model) configuration
+ * _and_ acts upon backup trigger. These could be done
+ * separately, but given how tighly coupled these are it
+ * would probably be problematic to consider them separate
+ * anyway.
+ */
+
+#define LOG_PREFIX "ow: ovsdb: dfs_backup: "
+
+struct ow_ovsdb_dfs_backup {
+    struct ow_dfs_backup *ow_dfs_backup;
+    struct ow_dfs_backup_notify *backup_notify;
+    ovsdb_table_t table;
+};
+
+static void
+parent_change(struct ow_ovsdb_dfs_backup *m,
+              const char *phy_name,
+              const char *link_vif_name,
+              const struct osw_hwaddr *bssid,
+              const struct osw_channel *channel)
+{
+    if (WARN_ON(phy_name == NULL)) return;
+    if (WARN_ON(link_vif_name == NULL)) return;
+
+    const struct osw_hwaddr bssid0 = {0};
+    const struct osw_channel chan0 = {0};
+
+    struct osw_hwaddr_str bssid_strbuf;
+    const char *bssid_str = "";
+    if (bssid != NULL) {
+        bssid_str = osw_hwaddr2str(bssid, &bssid_strbuf);
+    }
+
+    char chan_str[32] = {0};
+    if (channel != NULL) {
+        const int freq = channel->control_freq_mhz;
+        const int chan = osw_freq_to_chan(freq);
+        snprintf(chan_str, sizeof(chan_str), "%d", chan);
+    }
+
+    const char *output = strexa("/usr/opensync/bin/parentchange.sh",
+                                phy_name,
+                                bssid_str,
+                                chan_str);
+
+    LOGN(LOG_PREFIX"parent change: from %s to %s @ "OSW_HWADDR_FMT" on "OSW_CHANNEL_FMT": output = '%s'",
+         link_vif_name,
+         phy_name,
+         OSW_HWADDR_ARG(bssid ?: &bssid0),
+         OSW_CHANNEL_ARG(channel ?: &chan0),
+         output ?: "");
+
+    ow_dfs_backup_unlatch_vif(m->ow_dfs_backup, link_vif_name);
+}
+
+static void
+backup_cb(const char *phy_name,
+          const char *link_vif_name,
+          enum ow_dfs_backup_phy_state state,
+          const struct osw_hwaddr *bssid,
+          const struct osw_channel *channel,
+          void *priv)
+{
+    struct ow_ovsdb_dfs_backup *m = priv;
+    switch (state) {
+        case OW_DFS_BACKUP_PHY_REMOVED:
+            break;
+        case OW_DFS_BACKUP_PHY_CONFIGURED:
+            break;
+        case OW_DFS_BACKUP_PHY_LATCHED:
+            parent_change(m, phy_name, link_vif_name, bssid, channel);
+            break;
+    }
+}
+
+static void
+rconf_cb(ovsdb_update_monitor_t *mon,
+         struct schema_Wifi_Master_State *old,
+         struct schema_Wifi_Master_State *rec,
+         ovsdb_cache_row_t *row)
+{
+    ovsdb_table_t *table = mon->mon_data;
+    struct ow_ovsdb_dfs_backup *m = container_of(table, struct ow_ovsdb_dfs_backup, table);
+    const struct schema_Wifi_Radio_Config *rconf = (const void *)row->record;
+    struct ow_dfs_backup_phy *phy = ow_dfs_backup_get_phy(m->ow_dfs_backup, rconf->if_name);
+
+    ow_dfs_backup_phy_reset(phy);
+
+    if (rconf->fallback_parents_len < 1) return;
+    WARN_ON(rconf->fallback_parents_len > 1);
+
+    const char *bssid_str = rconf->fallback_parents_keys[0];
+    const int chan = rconf->fallback_parents[0];
+    const enum osw_band band = rconf->freq_band[0] == '2' ? OSW_BAND_2GHZ
+                             : rconf->freq_band[0] == '5' ? OSW_BAND_5GHZ
+                             : rconf->freq_band[0] == '6' ? OSW_BAND_6GHZ
+                             : OSW_BAND_UNDEFINED;
+    const int freq_mhz = osw_chan_to_freq(band, chan);
+    const int htmode = atoi((strstr(rconf->ht_mode, "HT") ?: "HT20") + strlen("HT"));
+    const int width_mhz = htmode == 2040 ? 40
+                        : htmode == 8080 ? 160
+                        : htmode;
+    const struct osw_channel c = {
+        .control_freq_mhz = freq_mhz,
+        .width = width_mhz
+    };
+
+    struct osw_hwaddr bssid = {0};
+    const bool bssid_bad = osw_hwaddr_from_cstr(bssid_str, &bssid) == false;
+    const bool freq_bad = freq_mhz < 2000;
+
+    if (WARN_ON(bssid_bad == true)) return;
+    if (WARN_ON(freq_bad == true)) return;
+
+    ow_dfs_backup_phy_set_bssid(phy, &bssid);
+    ow_dfs_backup_phy_set_channel(phy, &c);
+}
+
+static void
+connect_cb(void *priv)
+{
+    struct ow_ovsdb_dfs_backup *m = priv;
+    ovsdb_cache_monitor(&m->table, (void *)rconf_cb, true);
+}
+
+static void
+mod_init(struct ow_ovsdb_dfs_backup *m)
+{
+    OVSDB_TABLE_VAR_INIT(&m->table, Wifi_Radio_Config, if_name);
+}
+
+static void
+mod_attach(struct ow_ovsdb_dfs_backup *m)
+{
+    m->backup_notify = ow_dfs_backup_add_notify(m->ow_dfs_backup,
+                                                __FILE__,
+                                                backup_cb,
+                                                m);
+    ovsdb_when_ready(connect_cb, m);
+}
+
+OSW_MODULE(ow_ovsdb_dfs_backup)
+{
+    static struct ow_ovsdb_dfs_backup m;
+    m.ow_dfs_backup = OSW_MODULE_LOAD(ow_dfs_backup);
+    mod_init(&m);
+    mod_attach(&m);
+    return &m;
+}
Index: core/src/lib/ow/src/ow_ovsdb_ms.c
===================================================================
--- core.orig/src/lib/ow/src/ow_ovsdb_ms.c
+++ core/src/lib/ow/src/ow_ovsdb_ms.c
@@ -235,6 +235,7 @@ ow_ovsdb_ms_set_vif(struct ow_ovsdb_ms_r
         case OSW_VIF_AP_VLAN:
             break;
         case OSW_VIF_STA:
+            ms->vif_active = (vif->drv_state->u.sta.link.status == OSW_DRV_VIF_STATE_STA_LINK_CONNECTED);
             break;
     }
 
Index: core/src/lib/ow/src/ow_ovsdb_ms.h
===================================================================
--- core.orig/src/lib/ow/src/ow_ovsdb_ms.h
+++ core/src/lib/ow/src/ow_ovsdb_ms.h
@@ -1,5 +1,5 @@
-#ifndef OW_OVSDB_MS_H
-#define OW_OVSDB_MS_H
+#ifndef OW_OVSDB_MS_H_INCLUDED
+#define OW_OVSDB_MS_H_INCLUDED
 
 #include <ovsdb_table.h>
 #include <ds_tree.h>
@@ -18,4 +18,4 @@ ow_ovsdb_ms_set_vif(struct ow_ovsdb_ms_r
 void
 ow_ovsdb_ms_init(struct ow_ovsdb_ms_root *root);
 
-#endif /* OW_OVSDB_MS_H */
+#endif /* OW_OVSDB_MS_H_INCLUDED */
Index: core/src/lib/ow/src/ow_ovsdb_stats.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_ovsdb_stats.c
@@ -0,0 +1,105 @@
+#include <ovsdb.h>
+#include <ovsdb_table.h>
+#include <ovsdb_cache.h>
+#include <ovsdb_sync.h>
+#include <schema_consts.h>
+#include "ow_stats_conf.h"
+
+static ovsdb_table_t table_Wifi_Stats_Config;
+
+static enum ow_stats_conf_radio_type
+ow_ovsdb_stats_xlate_radio(const struct schema_Wifi_Stats_Config *c)
+{
+    const char *s = c->radio_type;
+    if (strcmp(s, SCHEMA_CONSTS_RADIO_TYPE_STR_2G) == 0) return OW_STATS_CONF_RADIO_TYPE_2G;
+    if (strcmp(s, SCHEMA_CONSTS_RADIO_TYPE_STR_5G) == 0) return OW_STATS_CONF_RADIO_TYPE_5G;
+    if (strcmp(s, SCHEMA_CONSTS_RADIO_TYPE_STR_5GL) == 0) return OW_STATS_CONF_RADIO_TYPE_5GL;
+    if (strcmp(s, SCHEMA_CONSTS_RADIO_TYPE_STR_5GU) == 0) return OW_STATS_CONF_RADIO_TYPE_5GU;
+    if (strcmp(s, SCHEMA_CONSTS_RADIO_TYPE_STR_6G) == 0) return OW_STATS_CONF_RADIO_TYPE_6G;
+    return OW_STATS_CONF_RADIO_TYPE_UNSPEC;
+}
+
+static enum ow_stats_conf_scan_type
+ow_ovsdb_stats_xlate_scan(const struct schema_Wifi_Stats_Config *c)
+{
+    const char *s = c->survey_type;
+    if (strcmp(s, SCHEMA_CONSTS_SCAN_TYPE_ON_CHAN) == 0) return OW_STATS_CONF_SCAN_TYPE_ON_CHAN;
+    if (strcmp(s, SCHEMA_CONSTS_SCAN_TYPE_OFF_CHAN) == 0) return OW_STATS_CONF_SCAN_TYPE_OFF_CHAN;
+    if (strcmp(s, SCHEMA_CONSTS_SCAN_TYPE_FULL) == 0) return OW_STATS_CONF_SCAN_TYPE_FULL;
+    return OW_STATS_CONF_SCAN_TYPE_UNSPEC;
+}
+
+static enum ow_stats_conf_stats_type
+ow_ovsdb_stats_xlate_stats(const struct schema_Wifi_Stats_Config *c)
+{
+    const char *s = c->stats_type;
+    if (strcmp(s, SCHEMA_CONSTS_REPORT_TYPE_NEIGHBOR) == 0) return OW_STATS_CONF_STATS_TYPE_NEIGHBOR;
+    if (strcmp(s, SCHEMA_CONSTS_REPORT_TYPE_CLIENT) == 0) return OW_STATS_CONF_STATS_TYPE_CLIENT;
+    if (strcmp(s, SCHEMA_CONSTS_REPORT_TYPE_SURVEY) == 0) return OW_STATS_CONF_STATS_TYPE_SURVEY;
+    return OW_STATS_CONF_STATS_TYPE_UNSPEC;
+}
+
+static void
+ow_ovsdb_stats_setup(struct ow_stats_conf_entry *e,
+                     const struct schema_Wifi_Stats_Config *c)
+{
+    const enum ow_stats_conf_radio_type radio = ow_ovsdb_stats_xlate_radio(c);
+    const enum ow_stats_conf_scan_type scan = ow_ovsdb_stats_xlate_scan(c);
+    const enum ow_stats_conf_stats_type stats = ow_ovsdb_stats_xlate_stats(c);
+    const int sampling = c->sampling_interval;
+    const int reporting = c->reporting_interval;
+    const int *channels = c->channel_list;
+    const size_t n_channels = c->channel_list_len;
+
+    WARN_ON(c->reporting_count != 0); /* FIXME */
+    if (c->report_type_exists == true) WARN_ON(strcmp(c->report_type, "raw") != 0); /* FIXME */
+
+    /* FIXME: survey_interval_ms is dwell time;
+     * need to extend ow_stats_conf to support it
+     */
+
+    /* FIXME need to respect threshold for offchan
+     * scans later. Need to pass that to
+     * ow_stats_conf.
+     */
+
+    ow_stats_conf_entry_set_radio_type(e, radio);
+    ow_stats_conf_entry_set_scan_type(e, scan);
+    ow_stats_conf_entry_set_stats_type(e, stats);
+    ow_stats_conf_entry_set_channels(e, channels, n_channels);
+    if (sampling > 0) ow_stats_conf_entry_set_sampling(e, sampling);
+    if (reporting > 0) ow_stats_conf_entry_set_reporting(e, reporting);
+}
+
+static void
+callback_Wifi_Stats_Config(ovsdb_update_monitor_t *mon,
+                           struct schema_Wifi_Stats_Config *old,
+                           struct schema_Wifi_Stats_Config *cconf,
+                           ovsdb_cache_row_t *row)
+{
+    const struct schema_Wifi_Stats_Config *c = (const void *)row->record;
+    const char *id = c->_uuid.uuid;
+    struct ow_stats_conf *conf = ow_stats_conf_get();
+    struct ow_stats_conf_entry *e = ow_stats_conf_get_entry(conf, id);
+
+    if (WARN_ON(e == NULL)) return;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+        case OVSDB_UPDATE_MODIFY:
+            ow_ovsdb_stats_setup(e, c);
+            break;
+        case OVSDB_UPDATE_DEL:
+            ow_stats_conf_entry_reset(e);
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+}
+
+void
+ow_ovsdb_stats_init(ovsdb_table_t *vconft)
+{
+    OVSDB_TABLE_INIT(Wifi_Stats_Config, _uuid);
+    OVSDB_CACHE_MONITOR(Wifi_Stats_Config, true);
+}
Index: core/src/lib/ow/src/ow_ovsdb_stats.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_ovsdb_stats.h
@@ -0,0 +1,7 @@
+#ifndef OW_OVSDB_STATS_H_INCLUDED
+#define OW_OVSDB_STATS_H_INCLUDED
+
+void
+ow_ovsdb_stats_init(void);
+
+#endif /* OW_OVSDB_STATS_H_INCLUDED */
Index: core/src/lib/ow/src/ow_ovsdb_steer.c
===================================================================
--- core.orig/src/lib/ow/src/ow_ovsdb_steer.c
+++ core/src/lib/ow/src/ow_ovsdb_steer.c
@@ -1,23 +1,326 @@
+#include <inttypes.h>
+#include <ovsdb_table.h>
 #include <ovsdb_cache.h>
+#include <util.h>
 #include <const.h>
+#include <log.h>
+#include <osw_types.h>
+#include <ow_steer_bm.h>
 
-#include "ow_ovsdb_steer.h"
-#include "ow_steer.h"
+struct ow_ovsdb_steer {
+    ovsdb_table_t neighbor_table;
+    ovsdb_table_t config_table;
+    ovsdb_table_t client_table;
+};
+
+static bool
+ow_ovsdb_steer_parse_bool(const char *ovsdb_value,
+                          bool *value)
+{
+    ASSERT(ovsdb_value != NULL, "");
+    ASSERT(value != NULL, "");
+
+    if (strcmp(ovsdb_value, "true") == 0)
+        *value = true;
+    else if (strcmp(ovsdb_value, "false") == 0)
+        *value = false;
+    else
+        return false;
+
+    return true;
+}
 
 static void
-ow_ovsdb_steer_new_config(struct ow_ovsdb_steer *steering,
-                          const struct schema_Band_Steering_Config *row)
+ow_ovsdb_steer_group_add(const struct schema_Band_Steering_Config *row)
 {
+    ASSERT(row != NULL, "");
+
+    /* Either (if_name_2g, if_name_5g) or ifnames can exists */
+    if (((row->ifnames_len > 0) && (row->if_name_2g_exists == true || row->if_name_5g_exists == true)) ||
+        ((row->ifnames_len == 0) && row->if_name_2g_exists == false && row->if_name_5g_exists == false))
+    {
+        LOGW("ow: steer: ovsdb: group uuid: %s cannot add group, invalid ifnames", row->_uuid.uuid);
+        return;
+    }
+
+    struct ow_steer_bm_group *group = ow_steer_bm_get_group(row->_uuid.uuid);
+
+    if (row->if_name_2g_exists == true) {
+        ow_steer_bm_group_get_vif(group, row->if_name_2g);
+    }
+    if (row->if_name_5g_exists == true) {
+        ow_steer_bm_group_get_vif(group, row->if_name_5g);
+    }
     if (row->ifnames_len > 0) {
-        /* TODO */
+        int i;
+        for (i = 0; i < row->ifnames_len; i++)
+            ow_steer_bm_group_get_vif(group, row->ifnames_keys[i]);
+    }
+}
+
+static void
+ow_ovsdb_steer_neighbor_add(const struct schema_Wifi_VIF_Neighbors *row)
+{
+    ASSERT(row != NULL, "");
+
+    struct osw_hwaddr bssid;
+
+    if (row->bssid_exists == false) {
+        LOGW("ow: steer: ovsdb: cannot add neighbor, bssid is missing");
+        return;
+    }
+    const bool addr_is_valid = osw_hwaddr_from_cstr(row->bssid, &bssid) == true;
+    if (addr_is_valid == false) {
+        LOGW("ow: steer: ovsdb: bssid: %s invalid value", row->bssid);
+        return;
+    }
+    if (row->if_name_exists == false) {
+        LOGW("ow: steer: ovsdb: neighbor bssid: "OSW_HWADDR_FMT" cannot add, if_name is missing", OSW_HWADDR_ARG(&bssid));
+        return;
+    }
+    if (row->priority_exists == false) {
+        LOGW("ow: steer: ovsdb: neighbor bssid: "OSW_HWADDR_FMT" cannot add, priority is missing", OSW_HWADDR_ARG(&bssid));
+        return;
+    }
+    if (row->channel_exists == false) {
+        LOGW("ow: steer: ovsdb: neighbor bssid: "OSW_HWADDR_FMT" cannot add, channel is missing", OSW_HWADDR_ARG(&bssid));
+        return;
+    }
+    if (row->op_class_exists == false) {
+        LOGW("ow: steer: ovsdb: neighbor bssid: "OSW_HWADDR_FMT" cannot add, op_class is missing", OSW_HWADDR_ARG(&bssid));
+        return;
+    }
+
+    struct ow_steer_bm_neighbor *neighbor = ow_steer_bm_get_neighbor(bssid.octet);
+    const char *vif_name = row->if_name;
+    ow_steer_bm_neighbor_set_vif_name(neighbor, vif_name);
+    const uint8_t channel = row->channel;
+    ow_steer_bm_neighbor_set_channel_number(neighbor, &channel);
+    const uint8_t op_class = row->op_class;
+    ow_steer_bm_neighbor_set_op_class(neighbor, &op_class);
+}
+
+static void
+ow_steer_bm_client_set_btm_params(const struct osw_hwaddr *sta_addr,
+                                  struct ow_steer_bm_btm_params *btm_params,
+                                  const char *btm_params_name,
+                                  const char keys[][64],
+                                  const char values[][32],
+                                  int len)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(btm_params != NULL, "");
+    ASSERT(btm_params_name != NULL, "");
+    ASSERT(len > 0, "");
+
+    int i;
+    for (i = 0; i < len; i++) {
+        const char *key = keys[i];
+        const char *value = values[i];
+
+        if (strcmp(key, "abridged") == 0) {
+            uint8_t abridged;
+            const bool parsed = sscanf(value, "%"SCNu8, &abridged) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_abridged(btm_params, &abridged);
+                continue;
+            }
+        }
+        else if (strcmp(key, "bss_term") == 0) {
+            uint8_t bss_term;
+            const bool parsed = sscanf(value, "%"SCNu8, &bss_term) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_bss_term(btm_params, &bss_term);
+                continue;
+            }
+        }
+        else if (strcmp(key, "btm_max_retries") == 0) {
+            uint8_t btm_max_retries;
+            const bool parsed = sscanf(value, "%"SCNu8, &btm_max_retries) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_btm_max_retries(btm_params, &btm_max_retries);
+                continue;
+            }
+        }
+        else if (strcmp(key, "btm_retry_interval") == 0) {
+            uint8_t btm_retry_interval;
+            const bool parsed = sscanf(value, "%"SCNu8, &btm_retry_interval) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_btm_retry_interval(btm_params, &btm_retry_interval);
+                continue;
+            }
+        }
+        else if (strcmp(key, "disassoc_imminent") == 0) {
+            uint8_t disassoc_imminent;
+            const bool parsed = sscanf(value, "%"SCNu8, &disassoc_imminent) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_disassoc_imminent(btm_params, &disassoc_imminent);
+                continue;
+            }
+        }
+        else if (strcmp(key, "inc_neigh") == 0) {
+            bool inc_neigh;
+            const bool parsed = ow_ovsdb_steer_parse_bool(value, &inc_neigh) == false;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_inc_neigh(btm_params, &inc_neigh);
+                continue;
+            }
+        }
+        else if (strcmp(key, "pref") == 0) {
+            uint8_t pref;
+            const bool parsed = sscanf(value, "%"SCNu8, &pref) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_pref(btm_params, &pref);
+                continue;
+            }
+        }
+        else if (strcmp(key, "valid_interval") == 0) {
+            uint8_t valid_interval;
+            const bool parsed = sscanf(value, "%"SCNu8, &valid_interval) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_valid_interval(btm_params, &valid_interval);
+                continue;
+            }
+        }
+        else if (strcmp(key, "inc_self") == 0) {
+            bool inc_self;
+            const bool parsed = ow_ovsdb_steer_parse_bool(value, &inc_self) == false;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_inc_self(btm_params, &inc_self);
+                continue;
+            }
+        }
+        else if (strcmp(key, "bssid") == 0) {
+            struct osw_hwaddr bssid;
+            const bool parsed = osw_hwaddr_from_cstr(value, &bssid) == false;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_bssid(btm_params, &bssid);
+                continue;
+            }
+        }
+        else if (strcmp(key, "bssid_info") == 0) {
+            uint32_t bssid_info;
+            const bool parsed = sscanf(value, "%"SCNu32, &bssid_info) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_bssid_info(btm_params, &bssid_info);
+                continue;
+            }
+        }
+        else if (strcmp(key, "phy_type") == 0) {
+            uint8_t phy_type;
+            const bool parsed = sscanf(value, "%"SCNu8, &phy_type) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_phy_type(btm_params, &phy_type);
+                continue;
+            }
+        }
+        else if (strcmp(key, "channel") == 0) {
+            uint8_t channel;
+            const bool parsed = sscanf(value, "%"SCNu8, &channel) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_channel(btm_params, &channel);
+                continue;
+            }
+        }
+        else if (strcmp(key, "op_class") == 0) {
+            uint8_t op_class;
+            const bool parsed = sscanf(value, "%"SCNu8, &op_class) == 0;
+            if (parsed == true) {
+                ow_steer_bm_btm_params_op_class(btm_params, &op_class);
+                continue;
+            }
+        }
+        else {
+            LOGW("ow: steer: ovsdb: client: sta_addr: "OSW_HWADDR_FMT" btm_params: %s key: %s is not supported",
+                 OSW_HWADDR_ARG(sta_addr), btm_params_name, keys[i]);
+             continue;
+        }
+
+        LOGW("ow: steer: ovsdb: client: sta_addr: "OSW_HWADDR_FMT" btm_params: %s key: %s value: %s is invalid",
+             OSW_HWADDR_ARG(sta_addr), btm_params_name, key, value);
+    }
+}
+
+static void
+ow_ovsdb_steer_client_add(const struct schema_Band_Steering_Clients *row)
+{
+    ASSERT(row != NULL, "");
+
+    if (row->mac_exists == false) {
+        LOGW("ow: steer: ovsdb: cannot add client, mac is missing");
+        return;
+    }
+
+    struct osw_hwaddr addr;
+    const bool result = osw_hwaddr_from_cstr(row->mac, &addr);
+    if (result == false) {
+        LOGW("ow: steer: ovsdb: client: addr: %s cannot add client, invalid sta addr", row->mac);
+        return;
+    }
+
+    struct ow_steer_bm_client *client = ow_steer_bm_get_client(addr.octet);
+
+    if (row->hwm_exists == true) {
+        const unsigned int hwm = row->hwm;
+        ow_steer_bm_client_set_hwm(client, &hwm);
+    }
+    else {
+        ow_steer_bm_client_set_hwm(client, NULL);
+    }
+
+    if (row->lwm_exists == true) {
+        const unsigned int lwm = row->lwm;
+        ow_steer_bm_client_set_lwm(client, &lwm);
+    }
+    else {
+        ow_steer_bm_client_set_lwm(client, NULL);
+    }
+
+    if (row->pref_5g_exists == true) {
+        if (strcmp(row->pref_5g, "always") == 0) {
+             const enum ow_steer_bm_client_pref_5g pref_5g = OW_STEER_BM_CLIENT_PREF_5G_ALWAYS;
+             ow_steer_bm_client_set_pref_5g(client, &pref_5g);
+        }
+        else if (strcmp(row->pref_5g, "never") == 0) {
+             const enum ow_steer_bm_client_pref_5g pref_5g = OW_STEER_BM_CLIENT_PREF_5G_NEVER;
+             ow_steer_bm_client_set_pref_5g(client, &pref_5g);
+        }
+        else {
+            LOGW("ow: steer: ovsdb: client: sta_addr: "OSW_HWADDR_FMT" cannot add, unsupported pref_5g: %s",
+                 OSW_HWADDR_ARG(&addr), row->pref_5g);
+            ow_steer_bm_client_set_pref_5g(client, NULL);
+        }
+    }
+    else {
+        ow_steer_bm_client_set_pref_5g(client, NULL);
+    }
+
+    if (row->sc_btm_params_len != 0) {
+        struct ow_steer_bm_btm_params *sc_btm_params = ow_steer_bm_client_get_sc_btm_params(client);
+        ow_steer_bm_client_set_btm_params(&addr, sc_btm_params, "steering_btm_params", row->steering_btm_params_keys,
+                                          row->steering_btm_params, row->steering_btm_params_len);
     }
 }
 
 static void
-ow_ovsdb_steer_new_client(struct ow_ovsdb_steer *steering,
-                          const struct schema_Band_Steering_Clients *row)
+ow_ovsdb_steer_neighbor_table_cb(ovsdb_update_monitor_t *mon,
+                                  struct schema_Wifi_VIF_Neighbors *old,
+                                  struct schema_Wifi_VIF_Neighbors *rec,
+                                  ovsdb_cache_row_t *row)
 {
-    /* TODO */
+    const struct schema_Wifi_VIF_Neighbors *neighbor = (void *)row->record;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+            ow_ovsdb_steer_neighbor_add(neighbor);
+            break;
+        case OVSDB_UPDATE_MODIFY:
+            break;
+        case OVSDB_UPDATE_DEL:
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
 }
 
 static void
@@ -26,13 +329,11 @@ ow_ovsdb_steer_config_table_cb(ovsdb_upd
                                struct schema_Band_Steering_Config *rec,
                                ovsdb_cache_row_t *row)
 {
-    ovsdb_table_t *table = mon->mon_data;
-    struct ow_ovsdb_steer *steering = container_of(table, struct ow_ovsdb_steer, config_table);
-    const struct schema_Band_Steering_Config *config = (void *)row->record;
+    const struct schema_Band_Steering_Config *group = (void *)row->record;
 
     switch (mon->mon_type) {
         case OVSDB_UPDATE_NEW:
-            ow_ovsdb_steer_new_config(steering, config);
+            ow_ovsdb_steer_group_add(group);
             break;
         case OVSDB_UPDATE_MODIFY:
             break;
@@ -44,18 +345,16 @@ ow_ovsdb_steer_config_table_cb(ovsdb_upd
 }
 
 static void
-ow_ovsdb_steer_clients_table_cb(ovsdb_update_monitor_t *mon,
+ow_ovsdb_steer_client_table_cb(ovsdb_update_monitor_t *mon,
                                 struct schema_Band_Steering_Clients *old,
                                 struct schema_Band_Steering_Clients *rec,
                                 ovsdb_cache_row_t *row)
 {
-    ovsdb_table_t *table = mon->mon_data;
-    struct ow_ovsdb_steer *steering = container_of(table, struct ow_ovsdb_steer, clients_table);
     const struct schema_Band_Steering_Clients *client = (void *)row->record;
 
     switch (mon->mon_type) {
         case OVSDB_UPDATE_NEW:
-            ow_ovsdb_steer_new_client(steering, client);
+            ow_ovsdb_steer_client_add(client);
             break;
         case OVSDB_UPDATE_MODIFY:
             break;
@@ -66,11 +365,19 @@ ow_ovsdb_steer_clients_table_cb(ovsdb_up
     }
 }
 
-void
-ow_ovsdb_steer_init(struct ow_ovsdb_steer *steering)
+struct ow_ovsdb_steer*
+ow_ovsdb_steer_create(void)
 {
+    struct ow_ovsdb_steer *steering = CALLOC(1, sizeof(*steering));
+
+    OVSDB_TABLE_VAR_INIT_NO_KEY(&steering->neighbor_table, Wifi_VIF_Neighbors);
+    ovsdb_cache_monitor(&steering->neighbor_table, (void *)ow_ovsdb_steer_neighbor_table_cb, true);
     OVSDB_TABLE_VAR_INIT_NO_KEY(&steering->config_table, Band_Steering_Config);
     ovsdb_cache_monitor(&steering->config_table, (void *)ow_ovsdb_steer_config_table_cb, true);
-    OVSDB_TABLE_VAR_INIT(&steering->clients_table, Band_Steering_Clients, mac);
-    ovsdb_cache_monitor(&steering->clients_table, (void *)ow_ovsdb_steer_clients_table_cb, true);
+    OVSDB_TABLE_VAR_INIT(&steering->client_table, Band_Steering_Clients, mac);
+    ovsdb_cache_monitor(&steering->client_table, (void *)ow_ovsdb_steer_client_table_cb, true);
+
+    LOGI("ow: steer: ovsdb: initialized");
+
+    return steering;
 }
Index: core/src/lib/ow/src/ow_ovsdb_steer.h
===================================================================
--- core.orig/src/lib/ow/src/ow_ovsdb_steer.h
+++ core/src/lib/ow/src/ow_ovsdb_steer.h
@@ -1,17 +1,9 @@
-#ifndef OW_OVSDB_STEER_H
-#define OW_OVSDB_STEER_H
+#ifndef OW_OVSDB_STEER_H_INCLUDED
+#define OW_OVSDB_STEER_H_INCLUDED
 
-#include <ovsdb_table.h>
-#include <ds_tree.h>
-#include <osw_state.h>
+struct ow_ovsdb_steer;
 
-struct ow_ovsdb_steer {
-    ovsdb_table_t config_table;
-    ovsdb_table_t clients_table;
-    ovsdb_table_t neighbors_table;
-};
+struct ow_ovsdb_steer*
+ow_ovsdb_steer_create(void);
 
-void
-ow_ovsdb_steer_init(struct ow_ovsdb_steer *steering);
-
-#endif /* OW_OVSDB_STEER_H */
+#endif /* OW_OVSDB_STEER_H_INCLUDED */
Index: core/src/lib/ow/src/ow_sigalrm.c
===================================================================
--- core.orig/src/lib/ow/src/ow_sigalrm.c
+++ core/src/lib/ow/src/ow_sigalrm.c
@@ -6,12 +6,13 @@
 #include <ev.h>
 
 /* opensync */
-#include <module.h>
+#include <osw_module.h>
 
 #define OW_SIGALRM_WDOG_SECONDS 30.0
 #define OW_SIGALRM_WDOG_COUNT 3
 
 static ev_async g_ow_sigalrm_async;
+struct ev_loop *g_ow_sigalrm_loop;
 static int g_ow_sigalrm_cnt;
 
 static void
@@ -20,7 +21,7 @@ ow_sigalrm_sig_cb(int signum)
     if (signum != SIGALRM) return;
 
     assert(++g_ow_sigalrm_cnt < OW_SIGALRM_WDOG_COUNT);
-    ev_async_send(EV_DEFAULT_ &g_ow_sigalrm_async);
+    ev_async_send(g_ow_sigalrm_loop, &g_ow_sigalrm_async);
     alarm(OW_SIGALRM_WDOG_SECONDS);
 }
 
@@ -33,20 +34,19 @@ ow_sigalrm_async_cb(EV_P_ ev_async *arg,
 }
 
 static void
-ow_sigalrm_module_init_cb(void *arg)
+ow_sigalrm_init(EV_P)
 {
     ev_async_init(&g_ow_sigalrm_async, ow_sigalrm_async_cb);
-    ev_async_start(EV_DEFAULT_ &g_ow_sigalrm_async);
-    ev_unref(EV_DEFAULT);
+    ev_async_start(EV_A_ &g_ow_sigalrm_async);
+    ev_unref(EV_A);
+    g_ow_sigalrm_loop = EV_A;
     signal(SIGALRM, ow_sigalrm_sig_cb);
     alarm(OW_SIGALRM_WDOG_SECONDS);
 }
 
-static void
-ow_sigalrm_module_fini_cb(void *arg)
+OSW_MODULE(ow_sigalrm)
 {
+    struct ev_loop *loop = OSW_MODULE_LOAD(osw_ev);
+    ow_sigalrm_init(loop);
+    return NULL;
 }
-
-MODULE(ow_sigalrm_module,
-       ow_sigalrm_module_init_cb,
-       ow_sigalrm_module_fini_cb);
Index: core/src/lib/ow/src/ow_sta_channel_override.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_sta_channel_override.c
@@ -0,0 +1,113 @@
+#include <stdlib.h>
+#include <log.h>
+#include <osw_conf.h>
+#include <osw_state.h>
+#include <osw_module.h>
+
+/* Purpose:
+ *
+ * This module provides logic that mutates the
+ * osw_conf/osw_confsync so that if there's an active
+ * OSW_VIF_STA link then any OSW_VIF_AP channel
+ * configurations will be overriden with the root AP
+ * operational channel.
+ *
+ * Rationale:
+ *
+ * This is currently desired (and implied in the design of
+ * the entire system). If desired AP channels are different
+ * than where the STA link currently resides on, then its
+ * better to stick to the STA's channel. Otherwise, moving
+ * away will sever the connecting to STA's root AP.
+ * Consequently this will break internet connectivity and
+ * cloud connection. Extender will be essentially orphaned
+ * and will enter recovery procedures.
+ *
+ * Observable effect:
+ *
+ * The module will take effect whenever underlying data
+ * model (eg. ovsdb) doesn't get updated with a new channel
+ * while the sta link is on another channel that what the
+ * data model wants.
+ *
+ * Another case is when CSA is in progress. As soon as CSA
+ * intention gets processed by the driver, and somehow data
+ * model gets updated fast enough, then data model would be
+ * pointing to a future state of the STA interface (that is
+ * still on old channel, waiting for CSA countdown to
+ * finish).
+ *
+ * Future:
+ *
+ * Channel stickiness should be an explicitly configured
+ * hint per PHY (this still assumes single-channel radios
+ * and 1xSTA + NxAP). Possible options would be:
+ * inherit_from_sta and inherit_from_ap.
+ */
+
+static void
+find_vsta_cb(const struct osw_state_vif_info *info,
+            void *priv)
+{
+    const struct osw_drv_vif_state *state = info->drv_state;
+    const struct osw_drv_vif_state_sta *vsta = &state->u.sta;
+    const struct osw_state_vif_info **ret = priv;
+
+    if (state->vif_type != OSW_VIF_STA) return;
+    if (state->enabled == false) return;
+    if (vsta->link.status != OSW_DRV_VIF_STATE_STA_LINK_CONNECTED) return;
+
+    WARN_ON(*ret != NULL);
+    *ret = info;
+}
+
+static void
+ow_sta_channel_override_mutate_cb(struct osw_conf_mutator *mutator,
+                                  struct ds_tree *phy_tree)
+{
+    struct osw_conf_phy *phy;
+
+    ds_tree_foreach(phy_tree, phy) {
+        const struct osw_state_vif_info *vsta = NULL;
+        const char *phy_name = phy->phy_name;
+
+        osw_state_vif_get_list(find_vsta_cb, phy_name, &vsta);
+        if (vsta == NULL) continue;
+
+        struct osw_conf_vif *vif;
+        ds_tree_foreach(&phy->vif_tree, vif) {
+            struct osw_conf_vif_ap *vap = &vif->u.ap;
+            struct osw_channel *ap_chan = &vap->channel;
+            const char *vif_name = vif->vif_name;
+            const char *vsta_name = vsta->vif_name;
+            const struct osw_channel *vsta_chan = &vsta->drv_state->u.sta.link.channel;
+            const size_t size = sizeof(*ap_chan);
+            const bool same_chan = (memcmp(ap_chan, vsta_chan, size) == 0);
+
+            if (vif->vif_type != OSW_VIF_AP) continue;
+            if (same_chan == true) continue;
+
+            LOGI("ow: %s/%s: inheriting channel from %s: "OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+                 phy_name,
+                 vif_name,
+                 vsta_name,
+                 OSW_CHANNEL_ARG(ap_chan),
+                 OSW_CHANNEL_ARG(vsta_chan));
+
+            *ap_chan = *vsta_chan;
+        }
+    }
+}
+
+OSW_MODULE(ow_sta_channel_override)
+{
+    OSW_MODULE_LOAD(osw_conf);
+    OSW_MODULE_LOAD(osw_state);
+    static struct osw_conf_mutator mut = {
+        .name = __FILE__,
+        .type = OSW_CONF_TAIL,
+        .mutate_fn = ow_sta_channel_override_mutate_cb,
+    };
+    osw_conf_register_mutator(&mut);
+    return NULL;
+}
Index: core/src/lib/ow/src/ow_sta_log_snr.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_sta_log_snr.c
@@ -0,0 +1,233 @@
+/* opensync */
+#include <log.h>
+#include <const.h>
+#include <util.h>
+#include <memutil.h>
+
+/* osw */
+#include <osw_module.h>
+#include <osw_state.h>
+#include <osw_stats.h>
+#include <osw_stats_defs.h>
+
+/*
+ * Purpose:
+ *
+ * Generate logs containing SNR of a client, whenever a
+ * client connects, or client's SNR has changed
+ * significantly enough beyond possible
+ * deviation/instability of SNR reports.
+ *
+ * Future:
+ *
+ * Either this, or a derivative of this module, could be
+ * used to auto-tune tx power on backhaul links when "too
+ * strong" signal condition is detected. This is beyond just
+ * steering. If possible, per-sta tx power could be also
+ * adjusted (if supported by unerlying driver) not only for
+ * backhaul links, but also for regular clients if they
+ * happen to find themselves too close to the AP.
+ */
+
+#define OW_STA_LOG_SNR_TOO_WEAK_SNR_DB 10 /* -95 + 15 = -85dBm that's barely enough */
+#define OW_STA_LOG_SNR_TOO_STRONG_SNR_DB 75 /* -95 + 75 = -20 dBm, that's a lot */
+#define OW_STA_LOG_SNR_THRESHOLD_DB 10
+#define OW_STA_LOG_SNR_PERIOD_SEC 1.0
+
+struct ow_sta_log_snr_sta_id {
+    struct osw_hwaddr sta_addr;
+    struct osw_ifname vif_name;
+};
+
+struct ow_sta_log_snr_sta {
+    struct ds_tree_node node;
+    struct ow_sta_log_snr_sta_id id;
+    int last_snr_db;
+    bool just_connected;
+};
+
+struct ow_sta_log_snr {
+    struct osw_state_observer state_obs;
+    struct osw_stats_subscriber *stats_sub;
+    struct ds_tree sta_tree;
+    int threshold_db;
+    int too_weak_snr_db;
+    int too_strong_snr_db;
+    float period_sec;
+};
+
+static int
+ow_sta_log_snr_sta_id_cmp(const void *a, const void *b)
+{
+    const struct ow_sta_log_snr_sta_id *x = a;
+    const struct ow_sta_log_snr_sta_id *y = b;
+    const int d1 = strcmp(x->vif_name.buf, y->vif_name.buf);
+    if (d1 != 0) return d1;
+    const int d2 = osw_hwaddr_cmp(&x->sta_addr, &y->sta_addr);
+    if (d2 != 0) return d2;
+    return 0;
+}
+
+static void
+ow_sta_log_snr_report_cb(const enum osw_stats_id stats_id,
+                         const struct osw_tlv *delta,
+                         const struct osw_tlv *last,
+                         void *priv)
+{
+    struct ow_sta_log_snr *m = priv;
+
+    if (stats_id != OSW_STATS_STA) return;
+
+    const struct osw_stats_defs *defs = osw_stats_defs_lookup(stats_id);
+    const size_t tb_size = defs->size;
+    const struct osw_tlv_policy *policy = defs->tpolicy;
+
+    const struct osw_tlv_hdr *tb[tb_size];
+    memset(tb, 0, tb_size * sizeof(tb[0]));
+
+    const size_t left = osw_tlv_parse(delta->data, delta->used, policy, tb, tb_size);
+    WARN_ON(left != 0);
+
+    const struct osw_tlv_hdr *phy = tb[OSW_STATS_STA_PHY_NAME];
+    const struct osw_tlv_hdr *vif = tb[OSW_STATS_STA_VIF_NAME];
+    const struct osw_tlv_hdr *mac = tb[OSW_STATS_STA_MAC_ADDRESS];
+    const struct osw_tlv_hdr *snr = tb[OSW_STATS_STA_SNR_DB];
+
+    if (phy == NULL) return;
+    if (vif == NULL) return;
+    if (mac == NULL) return;
+    if (snr == NULL) return;
+
+    /* It's unsigned, but putting into signed to make sure
+     * subtraction won't underflow over to 2^32-1.
+     */
+    const int snr_db = osw_tlv_get_u32(snr);
+
+    const char *vif_name = osw_tlv_get_string(vif);
+    struct ow_sta_log_snr_sta_id id = {0};
+    STRSCPY_WARN(id.vif_name.buf, vif_name);
+    osw_tlv_get_hwaddr(&id.sta_addr, mac);
+
+    struct ow_sta_log_snr_sta *sta = ds_tree_find(&m->sta_tree, &id);
+    if (sta == NULL) return;
+
+    const int snr_diff = abs(sta->last_snr_db - snr_db);
+    const bool snr_diff_enough = snr_diff >= m->threshold_db;
+    const bool should_report = sta->just_connected || snr_diff_enough;
+
+    LOGT("ow: sta_log_snr: %s/"OSW_HWADDR_FMT": snr=%d last=%d diff=%d connected=%d should=%d",
+         vif_name,
+         OSW_HWADDR_ARG(&id.sta_addr),
+         snr_db,
+         sta->last_snr_db,
+         snr_diff,
+         sta->just_connected,
+         should_report);
+
+    if (should_report == false) return;
+
+    if (sta->just_connected) {
+        LOGI("ow: sta_log_snr: %s/"OSW_HWADDR_FMT": snr upon connect: %d",
+             vif_name,
+             OSW_HWADDR_ARG(&id.sta_addr),
+             snr_db);
+    }
+    else {
+        LOGI("ow: sta_log_snr: %s/"OSW_HWADDR_FMT": snr changed: %d -> %d",
+             vif_name,
+             OSW_HWADDR_ARG(&id.sta_addr),
+             sta->last_snr_db,
+             snr_db);
+    }
+
+    if (snr_db <= m->too_weak_snr_db) {
+        LOGN("ow: sta_log_snr: %s/"OSW_HWADDR_FMT": snr too weak: %d <= %d, expect link issues",
+             vif_name,
+             OSW_HWADDR_ARG(&id.sta_addr),
+             snr_db,
+             m->too_weak_snr_db);
+    }
+
+    if (snr_db >= m->too_strong_snr_db) {
+        LOGN("ow: sta_log_snr: %s/"OSW_HWADDR_FMT": snr too strong: %d >= %d, expect link issues",
+             vif_name,
+             OSW_HWADDR_ARG(&id.sta_addr),
+             snr_db,
+             m->too_strong_snr_db);
+    }
+
+    sta->last_snr_db = snr_db;
+    sta->just_connected = false;
+}
+
+static void
+ow_sta_log_snr_sta_connected_cb(struct osw_state_observer *o,
+                                const struct osw_state_sta_info *info)
+{
+    struct ow_sta_log_snr *m = container_of(o, struct ow_sta_log_snr, state_obs);
+    struct ow_sta_log_snr_sta_id id = {0};
+    STRSCPY_WARN(id.vif_name.buf, info->vif->vif_name);
+    id.sta_addr = *info->mac_addr;
+    struct ow_sta_log_snr_sta *sta = ds_tree_find(&m->sta_tree, &id);
+    if (WARN_ON(sta != NULL)) return;
+    sta = CALLOC(1, sizeof(*sta));
+    sta->id = id;
+    sta->just_connected = true;
+    ds_tree_insert(&m->sta_tree, sta, &sta->id);
+}
+
+static void
+ow_sta_log_snr_sta_disconnected_cb(struct osw_state_observer *o,
+                                   const struct osw_state_sta_info *info)
+{
+    struct ow_sta_log_snr *m = container_of(o, struct ow_sta_log_snr, state_obs);
+    struct ow_sta_log_snr_sta_id id = {0};
+    STRSCPY_WARN(id.vif_name.buf, info->vif->vif_name);
+    id.sta_addr = *info->mac_addr;
+    struct ow_sta_log_snr_sta *sta = ds_tree_find(&m->sta_tree, &id);
+    if (WARN_ON(sta == NULL)) return;
+    ds_tree_remove(&m->sta_tree, sta);
+    FREE(sta);
+}
+
+#define SET_PARAM_F(w, n, e) do { \
+        const char *v = getenv(#e); \
+        if (v != NULL) (w)->n = strtof(v, NULL); \
+    } while (0)
+
+#define SET_PARAM_ULL(w, n, e) do { \
+        const char *v = getenv(#e); \
+        if (v != NULL) (w)->n = strtoull(v, NULL, 10); \
+    } while (0)
+
+OSW_MODULE(ow_sta_log_snr)
+{
+    OSW_MODULE_LOAD(osw_state);
+    OSW_MODULE_LOAD(osw_stats);
+    static struct ow_sta_log_snr m = {
+        .state_obs = {
+        .name = __FILE__,
+            .sta_connected_fn = ow_sta_log_snr_sta_connected_cb,
+            .sta_disconnected_fn = ow_sta_log_snr_sta_disconnected_cb,
+        },
+        .sta_tree = DS_TREE_INIT(ow_sta_log_snr_sta_id_cmp, struct ow_sta_log_snr_sta, node),
+        .threshold_db = OW_STA_LOG_SNR_THRESHOLD_DB,
+        .too_weak_snr_db = OW_STA_LOG_SNR_TOO_WEAK_SNR_DB,
+        .too_strong_snr_db = OW_STA_LOG_SNR_TOO_STRONG_SNR_DB,
+        .period_sec = OW_STA_LOG_SNR_PERIOD_SEC,
+    };
+    SET_PARAM_ULL(&m, threshold_db, OW_STA_LOG_SNR_THRESHOLD_DB);
+    SET_PARAM_ULL(&m, too_weak_snr_db, OW_STA_LOG_SNR_TOO_WEAK_SNR_DB);
+    SET_PARAM_ULL(&m, too_strong_snr_db, OW_STA_LOG_SNR_TOO_STRONG_SNR_DB);
+    SET_PARAM_F(&m, period_sec, OW_STA_LOG_SNR_PERIOD_SEC);
+    m.stats_sub = osw_stats_subscriber_alloc();
+
+    osw_stats_subscriber_set_sta(m.stats_sub, true);
+    osw_stats_subscriber_set_report_fn(m.stats_sub, ow_sta_log_snr_report_cb, &m);
+    osw_stats_subscriber_set_report_seconds(m.stats_sub, m.period_sec);
+    osw_stats_subscriber_set_poll_seconds(m.stats_sub, m.period_sec);
+
+    osw_stats_register_subscriber(m.stats_sub);
+    osw_state_register_observer(&m.state_obs);
+    return &m;
+}
Index: core/src/lib/ow/src/ow_state_watchdog.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_state_watchdog.c
@@ -0,0 +1,286 @@
+#include <stdlib.h>
+#include <inttypes.h>
+#include <log.h>
+#include <const.h>
+#include <osw_state.h>
+#include <osw_mux.h>
+#include <osw_module.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+
+/* Purpose
+ *
+ * Provide best-effort hints in case osw driver
+ * implementations are buggy and don't report state change
+ * reports when underlying system state actually changes.
+ *
+ * It is possible to override operational timings via
+ * environment variables matching the #define names.
+ */
+
+#define OW_STATE_WATCHDOG_GRACE_NSEC OSW_TIME_SEC(5)
+#define OW_STATE_WATCHDOG_POLL_NSEC OSW_TIME_SEC(5)
+#define OW_STATE_WATCHDOG_PERIOD_NSEC OSW_TIME_SEC(5 * 60) /* 5 minutes */
+#define OW_STATE_WATCHDOG_POSTPONE_NSEC OSW_TIME_SEC(5 * 60) /* 5 minutes */
+
+enum state {
+    ARM_PERIOD, /* -> WAITING_FOR_PERIOD */
+    WAITING_FOR_PERIOD, /* -> WAITING_FOR_IDLE */
+    WAITING_FOR_IDLE, /* -> [POLL | POLL_FORCED] */
+    POLL, /* -> WAITING_FOR_POLL */
+    POLL_FORCED, /* -> ARM_PERIOD */
+    WAITING_FOR_POLL, /* -> WAITING_FOR_POLL_FORCED */
+    WAITING_FOR_POLL_FORCED, /* -> ARM_PERIOD */
+};
+
+struct ow_state_watchdog {
+    struct osw_state_observer state_obs;
+
+    enum state state;
+
+    struct osw_timer period;
+    struct osw_timer grace;
+    struct osw_timer poll;
+    struct osw_timer postpone;
+
+    uint64_t grace_nsec;
+    uint64_t poll_nsec;
+    uint64_t period_nsec;
+    uint64_t postpone_nsec;
+
+    unsigned int changes_while_polling;
+};
+
+static void
+arm_poll(struct ow_state_watchdog *wdog, const uint64_t now)
+{
+    const uint64_t poll_at = now + wdog->poll_nsec;
+    osw_timer_arm_at_nsec(&wdog->poll, poll_at);
+    wdog->changes_while_polling = 0;
+}
+
+static void
+arm_period(struct ow_state_watchdog *wdog, const uint64_t now)
+{
+    const uint64_t period_at = now + wdog->period_nsec;
+    osw_timer_arm_at_nsec(&wdog->period, period_at);
+}
+
+static void
+arm_grace(struct ow_state_watchdog *wdog, const uint64_t now)
+{
+    const uint64_t at = now + wdog->grace_nsec;
+    osw_timer_arm_at_nsec(&wdog->grace, at);
+}
+
+static void
+arm_postpone(struct ow_state_watchdog *wdog, const uint64_t now)
+{
+    const uint64_t at = now + wdog->postpone_nsec;
+    osw_timer_arm_at_nsec(&wdog->postpone, at);
+}
+
+static void
+update_count(struct ow_state_watchdog *wdog)
+{
+    const bool should_update = osw_timer_is_armed(&wdog->poll) == true;
+    if (should_update == true) wdog->changes_while_polling++;
+    LOGT("ow: state watchdog: changes = %u (should %d)", wdog->changes_while_polling, should_update);
+}
+
+static void
+note_change(struct ow_state_watchdog *wdog, const uint64_t now)
+{
+    arm_grace(wdog, now);
+    update_count(wdog);
+}
+
+static const char *
+state_to_str(const enum state s)
+{
+    switch (s) {
+        case WAITING_FOR_PERIOD: return "waiting_for_period";
+        case WAITING_FOR_IDLE: return "waiting_for_idle";
+        case POLL: return "poll";
+        case POLL_FORCED: return "poll_forced";
+        case WAITING_FOR_POLL: return "waiting_for_poll";
+        case WAITING_FOR_POLL_FORCED: return "waiting_for_poll_forced";
+        case ARM_PERIOD: return "arm_period";
+    }
+    return "?";
+}
+
+static void
+set_state(struct ow_state_watchdog *wdog, const enum state s)
+{
+    if (wdog->state == s) return;
+    const char *from = state_to_str(wdog->state);
+    const char *to = state_to_str(s);
+    LOGT("ow: state watchdog: state %s -> %s", from, to);
+    wdog->state = s;
+}
+
+static void
+do_work(struct ow_state_watchdog *wdog,
+        const uint64_t now)
+{
+    int budget = 64;
+
+    for (;;) {
+        LOGT("ow: state watchdog: work: budget=%d", budget);
+        enum state last = wdog->state;
+        switch (wdog->state) {
+            case WAITING_FOR_PERIOD:
+                if (osw_timer_is_armed(&wdog->period) == false) {
+                    arm_postpone(wdog, now);
+                    set_state(wdog, WAITING_FOR_IDLE);
+                }
+                break;
+            case WAITING_FOR_IDLE:
+                if (osw_timer_is_armed(&wdog->postpone) == false) {
+                    set_state(wdog, POLL_FORCED);
+                    break;
+                }
+                if (osw_timer_is_armed(&wdog->grace) == false) {
+                    set_state(wdog, POLL);
+                    break;
+                }
+                break;
+            case POLL:
+                osw_mux_poll();
+                arm_poll(wdog, now);
+                set_state(wdog, WAITING_FOR_POLL);
+                break;
+            case POLL_FORCED:
+                osw_mux_poll();
+                arm_poll(wdog, now);
+                set_state(wdog, WAITING_FOR_POLL_FORCED);
+                break;
+            case WAITING_FOR_POLL:
+                if (osw_timer_is_armed(&wdog->poll) == false) {
+                    if (wdog->changes_while_polling > 0) {
+                        const unsigned int n = wdog->changes_while_polling;
+                        LOGN("ow: state watchdog: %u changes observed during poll, possible driver bug", n);
+                    }
+                    set_state(wdog, ARM_PERIOD);
+                    break;
+                }
+                break;
+            case WAITING_FOR_POLL_FORCED:
+                if (osw_timer_is_armed(&wdog->poll) == false) {
+                    if (wdog->changes_while_polling > 0) {
+                        const unsigned int n = wdog->changes_while_polling;
+                        LOGI("ow: state watchdog: %u changes observed during poll", n);
+                    }
+                    set_state(wdog, ARM_PERIOD);
+                    break;
+                }
+                break;
+            case ARM_PERIOD:
+                arm_period(wdog, now);
+                set_state(wdog, WAITING_FOR_PERIOD);
+                break;
+        }
+
+        assert(--budget);
+
+        if (last == wdog->state)
+            break;
+    }
+}
+
+static void
+changed_cb(struct osw_state_observer *o)
+{
+    struct ow_state_watchdog *wdog = container_of(o, struct ow_state_watchdog, state_obs);
+    const uint64_t now = osw_time_mono_clk();
+
+    note_change(wdog, now);
+    do_work(wdog, now);
+}
+
+static void
+changed_phy_cb(struct osw_state_observer *o, const struct osw_state_phy_info *info)
+{
+    changed_cb(o);
+}
+
+static void
+changed_vif_cb(struct osw_state_observer *o, const struct osw_state_vif_info *info)
+{
+    changed_cb(o);
+}
+
+static void
+changed_sta_cb(struct osw_state_observer *o, const struct osw_state_sta_info *info)
+{
+    changed_cb(o);
+}
+
+#define DO_WORK(fn, m) \
+static void \
+fn(struct osw_timer *t) \
+{ \
+    struct ow_state_watchdog *wdog = container_of(t, struct ow_state_watchdog, m); \
+    const uint64_t now = osw_time_mono_clk(); \
+ \
+    LOGT("ow: state watchdog: "#m" done"); \
+    do_work(wdog, now); \
+}
+
+DO_WORK(poll_cb, poll);
+DO_WORK(grace_cb, grace);
+DO_WORK(period_cb, period);
+DO_WORK(postpone_cb, postpone);
+
+#define SET_PARAM(w, n, e) do { \
+        const char *v = getenv(#e); \
+        if (v != NULL) (w)->n = strtoull(v, NULL, 10); \
+    } while (0)
+
+OSW_MODULE(ow_state_watchdog)
+{
+    OSW_MODULE_LOAD(osw_state);
+    OSW_MODULE_LOAD(osw_timer);
+    OSW_MODULE_LOAD(osw_mux);
+    static struct ow_state_watchdog wdog = {
+        .state = ARM_PERIOD,
+        .grace_nsec = OW_STATE_WATCHDOG_GRACE_NSEC,
+        .poll_nsec = OW_STATE_WATCHDOG_POLL_NSEC,
+        .period_nsec = OW_STATE_WATCHDOG_PERIOD_NSEC,
+        .postpone_nsec = OW_STATE_WATCHDOG_POSTPONE_NSEC,
+        .grace = { .cb = grace_cb },
+        .poll = { .cb = poll_cb },
+        .period = { .cb = period_cb },
+        .postpone = { .cb = postpone_cb },
+        .state_obs = {
+            .name = __FILE__,
+            .phy_added_fn = changed_phy_cb,
+            .phy_removed_fn = changed_phy_cb,
+            .phy_changed_fn = changed_phy_cb,
+            .vif_added_fn = changed_vif_cb,
+            .vif_removed_fn = changed_vif_cb,
+            .vif_changed_fn = changed_vif_cb,
+            .sta_connected_fn = changed_sta_cb,
+            .sta_disconnected_fn = changed_sta_cb,
+            .sta_changed_fn = changed_sta_cb,
+        },
+    };
+    SET_PARAM(&wdog, grace_nsec, OW_STATE_WATCHDOG_GRACE_NSEC);
+    SET_PARAM(&wdog, poll_nsec, OW_STATE_WATCHDOG_POLL_NSEC);
+    SET_PARAM(&wdog, period_nsec, OW_STATE_WATCHDOG_PERIOD_NSEC);
+    SET_PARAM(&wdog, postpone_nsec, OW_STATE_WATCHDOG_POSTPONE_NSEC);
+    LOGI("ow: state watchdog: params:"
+         " grace=%"PRIu64
+         " poll=%"PRIu64
+         " period=%"PRIu64
+         " postpone=%"PRIu64,
+         wdog.grace_nsec,
+         wdog.poll_nsec,
+         wdog.period_nsec,
+         wdog.postpone_nsec);
+    osw_state_register_observer(&wdog.state_obs);
+    const uint64_t now = osw_time_mono_clk();
+    do_work(&wdog, now);
+    return NULL;
+}
Index: core/src/lib/ow/src/ow_stats_conf.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_stats_conf.c
@@ -0,0 +1,1660 @@
+#include <math.h>
+#include <inttypes.h>
+#include <memutil.h>
+#include <const.h>
+#include <log.h>
+#include <util.h>
+#include <qm_conn.h>
+#include <os_time.h>
+#include <stddef.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <osw_ut.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_stats.h>
+#include <osw_stats_subscriber.h>
+#include <osw_stats_defs.h>
+#include <osw_sampler.h>
+#include <osw_module.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <ow_stats_conf.h>
+#include <dpp_types.h>
+#include <dpp_survey.h>
+#include <dppline.h>
+
+#if 0
+_uuid              : b5e0~8b41
+_version           : e9f6~f281
+channel_list       : ["set",[1,6,11]]
+radio_type         : 2.4G
+report_type        : ["set",[]]
+reporting_count    : 0
+reporting_interval : 120
+sampling_interval  : 10
+stats_type         : survey
+survey_interval_ms : 50
+survey_type        : off-chan
+threshold          : ["map",[["max_delay",600],["util",10]]]
+#endif
+
+#ifndef RADIO_TYPE_STR_6G
+#define RADIO_TYPE_6G RADIO_TYPE_NONE
+#endif
+
+/*
+ * ow_stats_conf
+ *
+ * This is intended to simplify integration to some
+ * configuration systems like OVSDB (Wifi_Stats_Config).
+ * It bakes in some of the pecularities of how the
+ * polling/sampling/reporting times are set.
+ *
+ * Ideally this should be renamed to ow_stats_pb (protobuf)
+ * and the publishing should be abstracted, so that
+ * ow_stats_pb_qm could be used to publish the generated
+ * protobuf over QM (unix socket). The alternate trasnport
+ * would be ow_stats_pb_rbus for example.
+ */
+
+struct ow_stats_conf {
+    struct ds_tree entries; /* ow_stats_conf_entry */
+    struct ds_tree bands;
+    struct ds_tree freqs_phy;
+    struct ds_tree freqs_vif;
+    struct osw_state_observer state_obs;
+    struct osw_timer work;
+};
+
+struct ow_stats_conf_band {
+    struct ds_tree_node node;
+    char *phy_name;
+    enum ow_stats_conf_radio_type type;
+};
+
+struct ow_stats_conf_freq_phy {
+    struct ds_tree_node node;
+    struct ds_tree vifs;
+    char *phy_name;
+};
+
+struct ow_stats_conf_freq_vif {
+    struct ds_tree_node phy_node; /* ow_stats_conf_freq_phy.vifs */
+    struct ds_tree_node conf_node; /* ow_stats_conf.freqs_vif */
+    struct ow_stats_conf_freq *phy_freq;
+    char *vif_name;
+    uint32_t freq_mhz;
+};
+
+struct ow_stats_conf_sta_id {
+    struct osw_ifname vif_name;
+    struct osw_hwaddr addr;
+};
+
+struct ow_stats_conf_sta {
+    struct ds_tree_node node;
+    struct ow_stats_conf_sta_id id;
+    struct osw_ssid ssid;
+    uint32_t num_connects;
+    uint32_t num_disconnects;
+    double connected_at;
+    double disconnected_at;
+    bool is_connected;
+    /* FIXME: needs a way to ageout these entries - can't
+     * remove them when client disconnects if there's a
+     * bucket to be reported for it.
+     */
+};
+
+struct ow_stats_conf_entry_params {
+    int *channels;
+    size_t n_channels;
+    enum ow_stats_conf_radio_type radio_type;
+    enum ow_stats_conf_scan_type scan_type;
+    enum ow_stats_conf_stats_type stats_type;
+    double sample_seconds;
+    double report_seconds;
+    bool valid;
+};
+
+struct ow_stats_conf_entry {
+    struct ds_tree_node node; /* keyed by `id` */
+    struct ds_dlist surveys; /* dpp_survey_record_t */
+    struct ds_dlist neighbors; /* dpp_neighbor_record_list_t */
+    struct ds_dlist clients; /* dpp_client_record_t */
+    struct ds_tree sta_tree; /* ow_stats_conf_sta */
+    struct osw_stats_subscriber *sub;
+    struct osw_state_observer obs;
+    struct ow_stats_conf *conf;
+    struct ow_stats_conf_entry_params params;
+    struct ow_stats_conf_entry_params params_next;
+    double report_at;
+    double last_sub_reported_at;
+    char *id;
+    int underrun;
+};
+
+static radio_scan_type_t
+ow_stats_conf_scan_type_to_dpp(const enum ow_stats_conf_scan_type t)
+{
+    switch (t) {
+        case OW_STATS_CONF_SCAN_TYPE_UNSPEC: return RADIO_SCAN_TYPE_NONE;
+        case OW_STATS_CONF_SCAN_TYPE_ON_CHAN: return RADIO_SCAN_TYPE_ONCHAN;
+        case OW_STATS_CONF_SCAN_TYPE_OFF_CHAN: return RADIO_SCAN_TYPE_OFFCHAN;
+        case OW_STATS_CONF_SCAN_TYPE_FULL: return RADIO_SCAN_TYPE_FULL;
+    }
+    return RADIO_SCAN_TYPE_NONE;
+}
+
+static radio_type_t
+ow_stats_conf_radio_type_to_dpp(const enum ow_stats_conf_radio_type t)
+{
+    switch (t) {
+        case OW_STATS_CONF_RADIO_TYPE_UNSPEC: return RADIO_TYPE_NONE;
+        case OW_STATS_CONF_RADIO_TYPE_2G: return RADIO_TYPE_2G;
+        case OW_STATS_CONF_RADIO_TYPE_5G: return RADIO_TYPE_5G;
+        case OW_STATS_CONF_RADIO_TYPE_5GL: return RADIO_TYPE_5GL;
+        case OW_STATS_CONF_RADIO_TYPE_5GU: return RADIO_TYPE_5GU;
+        case OW_STATS_CONF_RADIO_TYPE_6G: return RADIO_TYPE_6G;
+    }
+    return RADIO_TYPE_NONE;
+}
+
+static radio_chanwidth_t
+ow_stats_conf_width_to_dpp(const uint32_t mhz)
+{
+    switch (mhz) {
+        case 20: return RADIO_CHAN_WIDTH_20MHZ;
+        case 40: return RADIO_CHAN_WIDTH_40MHZ;
+        case 80: return RADIO_CHAN_WIDTH_80MHZ;
+        case 160: return RADIO_CHAN_WIDTH_160MHZ;
+        case 8080: return RADIO_CHAN_WIDTH_80_PLUS_80MHZ;
+    }
+    return RADIO_CHAN_WIDTH_UNKNOWN;
+}
+
+static const char *
+ow_stats_conf_radio_type_to_str(const enum ow_stats_conf_radio_type t)
+{
+    switch (t) {
+        case OW_STATS_CONF_RADIO_TYPE_UNSPEC: return "unspec";
+        case OW_STATS_CONF_RADIO_TYPE_2G: return  "2g";
+        case OW_STATS_CONF_RADIO_TYPE_5G: return "5g";
+        case OW_STATS_CONF_RADIO_TYPE_5GL: return "5gl";
+        case OW_STATS_CONF_RADIO_TYPE_5GU: return "5gu";
+        case OW_STATS_CONF_RADIO_TYPE_6G: return "6g";
+    }
+    return "";
+}
+
+static const char *
+ow_stats_conf_scan_type_to_str(const enum ow_stats_conf_scan_type t)
+{
+    switch (t) {
+        case OW_STATS_CONF_SCAN_TYPE_UNSPEC: return "unspec";
+        case OW_STATS_CONF_SCAN_TYPE_ON_CHAN: return "on-chan";
+        case OW_STATS_CONF_SCAN_TYPE_OFF_CHAN: return "off-chan";
+        case OW_STATS_CONF_SCAN_TYPE_FULL: return "full";
+    }
+    return "";
+}
+
+static const char *
+ow_stats_conf_stats_type_to_str(const enum ow_stats_conf_stats_type t)
+{
+    switch (t) {
+        case OW_STATS_CONF_STATS_TYPE_SURVEY: return "survey";
+        case OW_STATS_CONF_STATS_TYPE_CLIENT: return "client";
+        case OW_STATS_CONF_STATS_TYPE_NEIGHBOR: return "neighbor";
+        case OW_STATS_CONF_STATS_TYPE_UNSPEC: return "unspec";
+    }
+    return "";
+}
+
+static void
+ow_stats_conf_entry_params_free(struct ow_stats_conf_entry_params *p)
+{
+    FREE(p->channels);
+    memset(p, 0, sizeof(*p));
+}
+
+static void
+ow_stats_conf_entry_params_copy(struct ow_stats_conf_entry_params *dst,
+                                const struct ow_stats_conf_entry_params *src)
+{
+    *dst = *src;
+    if (dst->channels != NULL) {
+        const size_t size = dst->n_channels * sizeof(dst->channels[0]);
+        dst->channels = MEMNDUP(dst->channels, size);
+    }
+}
+
+static bool
+ow_stats_conf_entry_params_changed(const struct ow_stats_conf_entry_params *a,
+                                   const struct ow_stats_conf_entry_params *b)
+{
+    const size_t size = a->n_channels * sizeof(a->channels[0]);
+    return (a->n_channels != b->n_channels)
+        || (a->radio_type != b->radio_type)
+        || (a->scan_type != b->scan_type)
+        || (a->stats_type != b->stats_type)
+        || (a->sample_seconds != b->sample_seconds)
+        || (a->report_seconds != b->report_seconds)
+        || (size > 0 &&
+            ((a->channels == NULL || b->channels == NULL) ||
+             memcmp(a->channels, b->channels, size) != 0));
+}
+
+static void
+ow_stats_conf_entry_get_sub_timings(const struct ow_stats_conf_entry *e,
+                                    double *poll,
+                                    double *report)
+{
+    *poll = 0;
+    *report = 0;
+    switch (e->params.stats_type) {
+        case OW_STATS_CONF_STATS_TYPE_SURVEY:
+            /* Surveys are special compared to others.
+             * Survey samples are not aggregated per keyed
+             * bucket. Instead, they are appended on a list.
+             */
+            *poll = e->params.sample_seconds;
+            *report = e->params.sample_seconds;
+            break;
+        case OW_STATS_CONF_STATS_TYPE_CLIENT: /* fall-through */
+        case OW_STATS_CONF_STATS_TYPE_NEIGHBOR:
+            *report = e->params.report_seconds;
+            *poll = e->params.sample_seconds;
+            break;
+        case OW_STATS_CONF_STATS_TYPE_UNSPEC:
+            break;
+    }
+
+    if (*poll == 0) {
+        *poll = *report;
+    }
+}
+
+static void
+ow_stats_conf_entry_free_surveys(struct ow_stats_conf_entry *e)
+{
+    dpp_survey_record_t *i;
+    while ((i = ds_dlist_remove_head(&e->surveys)) != NULL) {
+        dpp_survey_record_free(i);
+    }
+}
+
+static void
+ow_stats_conf_entry_free_neighbors(struct ow_stats_conf_entry *e)
+{
+    dpp_neighbor_record_list_t *i;
+    while ((i = ds_dlist_remove_head(&e->neighbors)) != NULL) {
+        dpp_neighbor_record_free(i);
+    }
+}
+
+static void
+ow_stats_conf_entry_free_clients(struct ow_stats_conf_entry *e)
+{
+    dpp_client_record_t *i;
+    while ((i = ds_dlist_remove_head(&e->clients)) != NULL) {
+        dpp_client_record_free(i);
+    }
+}
+
+static void
+ow_stats_conf_entry_free_sta_list(struct ow_stats_conf_entry *e)
+{
+    struct ow_stats_conf_sta *sta;
+    while ((sta = ds_tree_head(&e->sta_tree)) != NULL) {
+        ds_tree_remove(&e->sta_tree, sta);
+        FREE(sta);
+    }
+}
+
+static void
+ow_stats_conf_entry_stop(struct ow_stats_conf_entry *e)
+{
+    if (e == NULL) return;
+    if (e->sub != NULL) {
+        osw_state_unregister_observer(&e->obs);
+        osw_stats_unregister_subscriber(e->sub);
+        osw_stats_subscriber_free(e->sub);
+        e->sub = NULL;
+        LOGI("ow: stats: entry: %s: stopping", e->id ?: "");
+    }
+    ow_stats_conf_entry_free_surveys(e);
+    ow_stats_conf_entry_free_neighbors(e);
+    ow_stats_conf_entry_free_clients(e);
+    ow_stats_conf_entry_free_sta_list(e);
+}
+
+static void
+ow_stats_conf_entry_free(struct ow_stats_conf_entry *e)
+{
+    if (e == NULL) return;
+    e->report_at = -1;
+    ow_stats_conf_entry_stop(e);
+    ow_stats_conf_entry_params_free(&e->params);
+    ow_stats_conf_entry_params_free(&e->params_next);
+    ds_tree_remove(&e->conf->entries, e);
+    FREE(e->id);
+    FREE(e);
+}
+
+static uint32_t
+ow_stats_conf_freq_to_chan(const enum ow_stats_conf_radio_type t,
+                           const uint32_t freq_mhz)
+{
+    if (freq_mhz == 0) return 0;
+    switch (t) {
+        case OW_STATS_CONF_RADIO_TYPE_UNSPEC:
+            break;
+        case OW_STATS_CONF_RADIO_TYPE_2G:
+            return (freq_mhz - 2407) / 5;
+        case OW_STATS_CONF_RADIO_TYPE_5G: /* fall through */
+        case OW_STATS_CONF_RADIO_TYPE_5GL: /* fall through */
+        case OW_STATS_CONF_RADIO_TYPE_5GU:
+            return (freq_mhz - 5000) / 5;
+        case OW_STATS_CONF_RADIO_TYPE_6G:
+            if (freq_mhz == 5935) return 2;
+            return (freq_mhz - 5950) / 5;
+    }
+    return 0;
+}
+
+static uint32_t
+ow_stats_conf_get_oper_mhz(struct ow_stats_conf *c,
+                           const char *phy_name)
+{
+    struct ow_stats_conf_freq_phy *fp = ds_tree_find(&c->freqs_phy, phy_name);
+    if (fp == NULL) return 0;
+    struct ow_stats_conf_freq_vif *fv = ds_tree_head(&fp->vifs);
+    if (fv == NULL) return 0;
+    return fv->freq_mhz;
+}
+
+static struct ow_stats_conf_band *
+ow_stats_conf_get_radio_type(struct ow_stats_conf *c,
+                             const enum ow_stats_conf_radio_type type)
+{
+    struct ow_stats_conf_band *b;
+    ds_tree_foreach(&c->bands, b)
+        if (b->type == type)
+            return b;
+    return NULL;
+}
+
+static uint32_t
+ow_stats_conf_get_oper_chan(struct ow_stats_conf *c,
+                            const enum ow_stats_conf_radio_type type)
+{
+    struct ow_stats_conf_band *b = ow_stats_conf_get_radio_type(c, type);
+    const uint32_t freq_mhz = ow_stats_conf_get_oper_mhz(c, b->phy_name);
+    const uint32_t chan = ow_stats_conf_freq_to_chan(type, freq_mhz);
+    return chan;
+}
+
+static bool
+ow_stats_conf_is_chan_ok(struct ow_stats_conf_entry *e,
+                         const char *phy_name,
+                         const uint32_t chan)
+{
+    switch (e->params.scan_type) {
+        case OW_STATS_CONF_SCAN_TYPE_UNSPEC: return false;
+        case OW_STATS_CONF_SCAN_TYPE_FULL: return false; /* FIXME */
+        case OW_STATS_CONF_SCAN_TYPE_ON_CHAN: return true;
+        case OW_STATS_CONF_SCAN_TYPE_OFF_CHAN:
+            {
+                const uint32_t oper_mhz = ow_stats_conf_get_oper_mhz(e->conf, phy_name);
+                const uint32_t oper_chan = ow_stats_conf_freq_to_chan(e->params.radio_type, oper_mhz);
+                if (oper_chan == chan) return false;
+                if (e->params.n_channels == 0) return true;
+                size_t i;
+                bool match = false;
+                for (i = 0; i < e->params.n_channels; i++)
+                    if (e->params.channels[i] == (int)chan)
+                        match = true;
+                return match;
+            }
+    }
+    return false;
+}
+
+static bool
+ow_stats_conf_is_scan_type_ok(struct ow_stats_conf_entry *e,
+                              const char *phy_name,
+                              const uint32_t freq_mhz)
+{
+    const uint32_t oper_mhz = ow_stats_conf_get_oper_mhz(e->conf, phy_name);
+    const enum ow_stats_conf_scan_type scan_type = oper_mhz == freq_mhz
+                                                 ? OW_STATS_CONF_SCAN_TYPE_ON_CHAN
+                                                 : OW_STATS_CONF_SCAN_TYPE_OFF_CHAN;
+    return e->params.scan_type == scan_type;
+}
+
+static bool
+ow_stats_conf_is_radio_type_ok(struct ow_stats_conf_entry *e,
+                               const char *phy_name)
+{
+    struct ow_stats_conf *c = e->conf;
+    const struct ow_stats_conf_band *band = ds_tree_find(&c->bands, phy_name);
+    if (band == NULL) return false;
+    return e->params.radio_type == band->type;
+}
+
+static void
+ow_stats_conf_sub_report_survey(struct ow_stats_conf_entry *e,
+                                const struct osw_stats_defs *defs,
+                                const struct osw_tlv_hdr **tb,
+                                const double now)
+{
+    const struct osw_tlv_hdr *percent = tb[OSW_STATS_CHAN_CNT_PERCENT];
+    const struct osw_tlv_hdr *phy = tb[OSW_STATS_CHAN_PHY_NAME];
+    const struct osw_tlv_hdr *freq = tb[OSW_STATS_CHAN_FREQ_MHZ];
+
+    if (percent == NULL) return;
+    if (phy == NULL) return;
+    if (freq == NULL) return;
+
+    const char *phy_name = osw_tlv_get_string(phy);
+    const uint32_t freq_mhz = osw_tlv_get_u32(freq);
+    const uint32_t chan = ow_stats_conf_freq_to_chan(e->params.radio_type, freq_mhz);
+
+    if (ow_stats_conf_is_radio_type_ok(e, phy_name) == false) return;
+    if (ow_stats_conf_is_scan_type_ok(e, phy_name, freq_mhz) == false) return;
+    if (ow_stats_conf_is_chan_ok(e, phy_name, chan) == false) return;
+
+    const struct osw_tlv_hdr *active = tb[OSW_STATS_CHAN_ACTIVE_MSEC];
+    const struct osw_tlv_hdr *nf = tb[OSW_STATS_CHAN_NOISE_FLOOR_DBM];
+    const size_t tb_size2 = defs->tpolicy[OSW_STATS_CHAN_CNT_PERCENT].tb_size;
+    const struct osw_tlv_policy *policy2 = defs->tpolicy[OSW_STATS_CHAN_CNT_PERCENT].nested;
+    const struct osw_tlv_hdr *tb2[tb_size2];
+    memset(tb2, 0, tb_size2 * sizeof(tb2[0]));
+    const void *data2 = osw_tlv_get_data(percent);
+    const size_t len2 = percent->len;
+    const size_t left2 = osw_tlv_parse(data2, len2, policy2, tb2, tb_size2);
+    const struct osw_tlv_hdr *tx = tb2[OSW_STATS_CHAN_CNT_TX];
+    const struct osw_tlv_hdr *rx = tb2[OSW_STATS_CHAN_CNT_RX];
+    const struct osw_tlv_hdr *inbss = tb2[OSW_STATS_CHAN_CNT_RX_INBSS];
+    const struct osw_tlv_hdr *busy = tb2[OSW_STATS_CHAN_CNT_BUSY];
+    WARN_ON(left2 != 0);
+
+    const uint32_t active_msec = active ? osw_tlv_get_u32(active) : 0;
+    if (active_msec == 0) return;
+
+    dpp_survey_record_t *r = dpp_survey_record_alloc();
+    ds_dlist_insert_tail(&e->surveys, r);
+
+    r->info.chan = ow_stats_conf_freq_to_chan(e->params.radio_type, freq_mhz);
+    r->info.timestamp_ms = now * 1e3;
+    r->duration_ms = active_msec;
+
+    if (tx) r->chan_tx = osw_tlv_get_u32(tx);
+    if (rx) r->chan_rx = osw_tlv_get_u32(rx);
+    if (inbss) r->chan_self = osw_tlv_get_u32(inbss);
+    if (busy) r->chan_busy = osw_tlv_get_u32(busy);
+    if (nf) r->chan_noise = (int)osw_tlv_get_float(nf);
+
+    LOGT("ow: stats: conf: report: survey:"
+         " chan=%"PRIu32
+         " ts=%"PRIu64
+         " msec=%"PRIu32
+         " nf=%"PRId32
+         " tx=%"PRIu32
+         " rx=%"PRIu32
+         " self=%"PRIu32
+         " busy=%"PRIu32,
+         r->info.chan,
+         r->info.timestamp_ms,
+         r->duration_ms,
+         r->chan_noise,
+         r->chan_tx,
+         r->chan_rx,
+         r->chan_self,
+         r->chan_busy);
+
+    /* FIXME: r->chan_noise */
+}
+
+static void
+ow_stats_conf_sub_report_bss_scan(struct ow_stats_conf_entry *e,
+                                  const struct osw_stats_defs *defs,
+                                  const struct osw_tlv_hdr **tb,
+                                  const double now)
+{
+    const struct osw_tlv_hdr *phy = tb[OSW_STATS_BSS_SCAN_PHY_NAME];
+    const struct osw_tlv_hdr *mac = tb[OSW_STATS_BSS_SCAN_MAC_ADDRESS];
+    const struct osw_tlv_hdr *freq = tb[OSW_STATS_BSS_SCAN_FREQ_MHZ];
+    const struct osw_tlv_hdr *ssid = tb[OSW_STATS_BSS_SCAN_SSID];
+    const struct osw_tlv_hdr *width = tb[OSW_STATS_BSS_SCAN_WIDTH_MHZ];
+    const struct osw_tlv_hdr *ies = tb[OSW_STATS_BSS_SCAN_IES];
+    const struct osw_tlv_hdr *snr = tb[OSW_STATS_BSS_SCAN_SNR_DB];
+
+    if (phy == NULL) return;
+    if (mac == NULL) return;
+
+    const char *phy_name = osw_tlv_get_string(phy);
+    const uint32_t freq_mhz = osw_tlv_get_u32(freq);
+    const uint32_t chan = ow_stats_conf_freq_to_chan(e->params.radio_type, freq_mhz);
+
+    if (ow_stats_conf_is_radio_type_ok(e, phy_name) == false) return;
+    if (ow_stats_conf_is_scan_type_ok(e, phy_name, freq_mhz) == false) return;
+    if (ow_stats_conf_is_chan_ok(e, phy_name, chan) == false) return;
+
+    struct osw_hwaddr bssid;
+    struct osw_hwaddr_str bssid_strbuf;
+    osw_tlv_get_hwaddr(&bssid, mac);
+    const char *bssid_str = osw_hwaddr2str(&bssid, &bssid_strbuf);
+
+    dpp_neighbor_record_list_t *r = dpp_neighbor_record_alloc();
+    ds_dlist_insert_tail(&e->neighbors, r);
+
+    r->entry.chan = chan;
+    r->entry.type = ow_stats_conf_radio_type_to_dpp(e->params.radio_type);
+    snprintf(r->entry.bssid,sizeof(r->entry.ssid), "%s", bssid_str);
+
+    if (ssid != NULL) {
+        memcpy(r->entry.ssid, osw_tlv_get_data(ssid), ssid->len);
+        r->entry.ssid[ssid->len] = '\0';
+    }
+
+    if (width != NULL) {
+        const uint32_t mhz = osw_tlv_get_u32(width);
+        r->entry.chanwidth = ow_stats_conf_width_to_dpp(mhz);
+    }
+
+    if (ies != NULL) {
+        /* FIXME:*/
+    }
+
+    if (snr != NULL) {
+        const uint32_t snr_db = osw_tlv_get_u32(snr);
+        r->entry.sig = snr_db;
+    }
+
+    LOGT("ow: stats: conf: report: bss:"
+         " bssid=%s"
+         " radio=%d"
+         " chan=%"PRIu32
+         " width=%d"
+         " snr=%"PRId32
+         " ssid=%s",
+         r->entry.bssid,
+         r->entry.type,
+         r->entry.chan,
+         r->entry.chanwidth,
+         r->entry.sig,
+         r->entry.ssid);
+
+    /* FIXME: r->entry.tsf (unnecessary?) */
+    /* FIXME: r->entry.sig (rssi) */
+    /* FIXME: r->entry.lastseen for diff reports */
+}
+
+static void
+ow_stats_conf_sub_report_sta(struct ow_stats_conf_entry *e,
+                             const struct osw_stats_defs *defs,
+                             const struct osw_tlv_hdr **tb,
+                             const double now)
+{
+    const struct osw_tlv_hdr *phy = tb[OSW_STATS_STA_PHY_NAME];
+    const struct osw_tlv_hdr *vif = tb[OSW_STATS_STA_VIF_NAME];
+    const struct osw_tlv_hdr *mac = tb[OSW_STATS_STA_MAC_ADDRESS];
+
+    if (phy == NULL) return;
+    if (vif == NULL) return;
+    if (mac == NULL) return;
+
+    const char *phy_name = osw_tlv_get_string(phy);
+    const char *vif_name = osw_tlv_get_string(vif);
+    (void)vif_name;
+
+    if (ow_stats_conf_is_radio_type_ok(e, phy_name) == false) return;
+
+    struct ow_stats_conf_sta_id id = {0};
+    STRSCPY_WARN(id.vif_name.buf, vif_name);
+    osw_tlv_get_hwaddr(&id.addr, mac);
+
+    /* FIXME: This is subject to a possible race. If client
+     * connects as report is about to be scheduled it's
+     * possible that driver will deliver stats, but won't go
+     * through all the motions of reporting sta_state. In
+     * that case the report will be posponed until another
+     * report target time. This could be re-tried sooner
+     * upon sta_connected_cb, although that would violate
+     * the reporting interval a little bit.
+     *
+     * Right now what it means is that the reported stats
+     * delta will be lost, although arguably there would be
+     * little to report anyway.
+     */
+    struct ow_stats_conf_sta *sta = ds_tree_find(&e->sta_tree, &id);
+    if (sta == NULL) return;
+
+    dpp_client_record_t *r = dpp_client_record_alloc();
+    ds_dlist_insert_tail(&e->clients, r);
+
+    r->is_connected = sta->is_connected;
+    r->connected = sta->num_connects;
+    r->disconnected = sta->num_disconnects;
+    r->connect_ts = sta->connected_at * 1e3;
+    r->disconnect_ts = sta->disconnected_at * 1e3;
+    assert(sizeof(r->info.essid) > sta->ssid.len);
+    memcpy(r->info.essid, sta->ssid.buf, sta->ssid.len);
+    /* FIXME: network id */
+
+    sta->num_connects = 0;
+    sta->num_disconnects = 0;
+    sta->connected_at = 0;
+    sta->disconnected_at = 0;
+
+    r->info.type = e->params.radio_type;
+    memcpy(r->info.mac, &id.addr.octet, 6);
+
+    const struct osw_tlv_hdr *tx_bytes = tb[OSW_STATS_STA_TX_BYTES];
+    const struct osw_tlv_hdr *rx_bytes = tb[OSW_STATS_STA_RX_BYTES];
+    const struct osw_tlv_hdr *tx_frames = tb[OSW_STATS_STA_TX_FRAMES];
+    const struct osw_tlv_hdr *rx_frames = tb[OSW_STATS_STA_RX_FRAMES];
+    const struct osw_tlv_hdr *tx_retries = tb[OSW_STATS_STA_TX_RETRIES];
+    const struct osw_tlv_hdr *rx_retries = tb[OSW_STATS_STA_RX_RETRIES];
+    const struct osw_tlv_hdr *tx_errors = tb[OSW_STATS_STA_TX_ERRORS];
+    const struct osw_tlv_hdr *rx_errors = tb[OSW_STATS_STA_RX_ERRORS];
+    const struct osw_tlv_hdr *tx_rate = tb[OSW_STATS_STA_TX_RATE_MBPS];
+    const struct osw_tlv_hdr *rx_rate = tb[OSW_STATS_STA_RX_RATE_MBPS];
+    const struct osw_tlv_hdr *snr = tb[OSW_STATS_STA_SNR_DB];
+
+    if (tx_bytes) r->stats.bytes_tx = osw_tlv_get_u32(tx_bytes);
+    if (rx_bytes) r->stats.bytes_rx = osw_tlv_get_u32(rx_bytes);
+    if (tx_frames) r->stats.frames_tx = osw_tlv_get_u32(tx_frames);
+    if (rx_frames) r->stats.frames_rx = osw_tlv_get_u32(rx_frames);
+    if (tx_retries) r->stats.retries_tx = osw_tlv_get_u32(tx_retries);
+    if (rx_retries) r->stats.retries_rx = osw_tlv_get_u32(rx_retries);
+    if (tx_errors) r->stats.errors_tx = osw_tlv_get_u32(tx_errors);
+    if (rx_errors) r->stats.errors_rx = osw_tlv_get_u32(rx_errors);
+    if (tx_rate) r->stats.rate_tx = osw_tlv_get_u32(tx_rate);
+    if (rx_rate) r->stats.rate_rx = osw_tlv_get_u32(rx_rate);
+    if (snr) r->stats.rssi = osw_tlv_get_u32(snr);
+
+    LOGT("ow: stats: conf: report: sta: "OSW_HWADDR_FMT":"
+         " sta=%p"
+         " radio=%u"
+         " ssid=%s"
+         " is_connected=%"PRIu32
+         " connected=%"PRIu32
+         " disconnected=%"PRIu32
+         " connect_ts=%"PRIu64
+         " disconnect_ts=%"PRIu64
+         " bytes_tx=%"PRIu64
+         " bytes_rx=%"PRIu64
+         " frames_tx=%"PRIu64
+         " frames_rx=%"PRIu64
+         " retries_tx=%"PRIu64
+         " retries_rx=%"PRIu64
+         " errors_tx=%"PRIu64
+         " errors_rx=%"PRIu64
+         " rate_tx=%lf"
+         " rate_rx=%lf"
+         " rssi=%"PRId32,
+         OSW_HWADDR_ARG(&id.addr),
+         sta,
+         r->info.type,
+         r->info.essid,
+         r->is_connected,
+         r->connected,
+         r->disconnected,
+         r->connect_ts,
+         r->disconnect_ts,
+         r->stats.bytes_tx,
+         r->stats.bytes_rx,
+         r->stats.frames_tx,
+         r->stats.frames_rx,
+         r->stats.retries_tx,
+         r->stats.retries_rx,
+         r->stats.errors_tx,
+         r->stats.errors_rx,
+         r->stats.rate_tx,
+         r->stats.rate_rx,
+         r->stats.rssi);
+
+    /* FIXME: rate_rx_perceived */
+    /* FIXME: rate_tx_perceived */
+}
+
+static void
+ow_stats_conf_sub_report(const enum osw_stats_id id,
+                         const struct osw_tlv *delta,
+                         const double now,
+                         struct ow_stats_conf_entry *e)
+{
+    const struct osw_stats_defs *defs = osw_stats_defs_lookup(id);
+    const size_t tb_size = defs->size;
+    const struct osw_tlv_policy *policy = defs->tpolicy;
+
+    const struct osw_tlv_hdr *tb[tb_size];
+    memset(tb, 0, tb_size * sizeof(tb[0]));
+
+    const size_t left = osw_tlv_parse(delta->data, delta->used, policy, tb, tb_size);
+    WARN_ON(left != 0);
+
+    e->last_sub_reported_at = now;
+    switch (id) {
+        case OSW_STATS_PHY: break;
+        case OSW_STATS_VIF: break;
+        case OSW_STATS_STA: ow_stats_conf_sub_report_sta(e, defs, tb, now); break;
+        case OSW_STATS_CHAN: ow_stats_conf_sub_report_survey(e, defs, tb, now); break;
+        case OSW_STATS_BSS_SCAN: ow_stats_conf_sub_report_bss_scan(e, defs, tb, now); break;
+        case OSW_STATS_MAX__: break;
+    }
+}
+
+static void
+ow_stats_conf_sub_report_cb(const enum osw_stats_id id,
+                            const struct osw_tlv *delta,
+                            const struct osw_tlv *last,
+                            void *priv)
+{
+    const double now_mono = OSW_TIME_TO_DBL(osw_time_mono_clk());
+    ow_stats_conf_sub_report(id, delta, now_mono, priv);
+}
+
+static bool
+ow_stats_conf_entry_report_survey(struct ow_stats_conf_entry *e,
+                                  const double now_mono,
+                                  const double now_real)
+{
+    if (ds_dlist_is_empty(&e->surveys)) return false;
+
+    const uint64_t mono_msec = now_mono * 1e3;
+    const uint64_t real_msec = now_real * 1e3;
+
+    dpp_survey_record_t *i;
+    ds_dlist_foreach(&e->surveys, i) {
+        i->info.timestamp_ms -= mono_msec;
+        i->info.timestamp_ms += real_msec;
+    }
+
+    dpp_survey_report_data_t r = {
+        .list = e->surveys,
+        .report_type = REPORT_TYPE_RAW, /* FIXME: support other types */
+        .radio_type = ow_stats_conf_radio_type_to_dpp(e->params.radio_type),
+        .scan_type = ow_stats_conf_scan_type_to_dpp(e->params.scan_type),
+        .timestamp_ms = real_msec,
+    };
+    dpp_put_survey(&r);
+    ow_stats_conf_entry_free_surveys(e);
+    return true;
+}
+
+static bool
+ow_stats_conf_entry_report_neighbor(struct ow_stats_conf_entry *e,
+                                    const double now_mono,
+                                    const double now_real)
+{
+    if (ds_dlist_is_empty(&e->neighbors)) return false;
+
+    const uint64_t mono_msec = now_mono * 1e3;
+    const uint64_t real_msec = now_real * 1e3;
+
+    (void)mono_msec;
+
+    dpp_neighbor_report_data_t r = {
+        .list = e->neighbors,
+        .report_type = REPORT_TYPE_RAW, /* FIXME: support other types */
+        .radio_type = ow_stats_conf_radio_type_to_dpp(e->params.radio_type),
+        .scan_type = ow_stats_conf_scan_type_to_dpp(e->params.scan_type),
+        .timestamp_ms = real_msec,
+    };
+    dpp_put_neighbor(&r);
+    ow_stats_conf_entry_free_neighbors(e);
+    return true;
+}
+
+static bool
+ow_stats_conf_entry_report_client(struct ow_stats_conf_entry *e,
+                                  const double now_mono,
+                                  const double now_real)
+{
+    if (ds_dlist_is_empty(&e->clients)) return false;
+
+    const uint32_t channel = ow_stats_conf_get_oper_chan(e->conf, e->params.radio_type);
+    const uint64_t mono_msec = now_mono * 1e3;
+    const uint64_t real_msec = now_real * 1e3;
+
+    dpp_client_record_t *i;
+    ds_dlist_foreach(&e->clients, i) {
+        if (i->connect_ts) {
+            i->connect_ts -= mono_msec;
+            i->connect_ts += real_msec;
+        }
+
+        if (i->disconnect_ts) {
+            i->disconnect_ts -= mono_msec;
+            i->disconnect_ts += real_msec;
+        }
+    }
+
+    struct ow_stats_conf_sta *sta;
+    struct ow_stats_conf_sta *tmp;
+    ds_tree_foreach_safe(&e->sta_tree, sta, tmp) {
+        if (sta->is_connected == true ||
+            sta->num_connects != 0 ||
+            sta->num_disconnects != 0 ||
+            sta->connected_at != 0 ||
+            sta->disconnected_at != 0) {
+            continue;
+        }
+
+        ds_tree_remove(&e->sta_tree, sta);
+        FREE(sta);
+    }
+
+    dpp_client_report_data_t r = {
+        .list = e->clients,
+        .radio_type = ow_stats_conf_radio_type_to_dpp(e->params.radio_type),
+        .timestamp_ms = real_msec,
+        .channel = channel,
+        /* FIXME: uplink_type? */
+        /* FIXME: uplink_changed? */
+    };
+    dpp_put_client(&r);
+    ow_stats_conf_entry_free_clients(e);
+    return true;
+}
+
+
+#define OW_STATS_CONF_MAX_UNDERRUN 10
+
+static bool
+ow_stats_conf_is_entry_ready(struct ow_stats_conf_entry *e,
+                             const double now)
+{
+    /* FIXME: The osw_stats_subscriber report timer will
+     * overlap with ow_stats_conf report timer. Their order
+     * of undefined currently so it's possible that this
+     * code is called _before_ osw_stats_subscriber delivers
+     * buckets of data. In such case don't advance the
+     * timer. Keep it unchanged (but armed) so that this
+     * function is re-run. Keep a limit to avoid infinite
+     * loops though.
+     *
+     * This could be fixed if ow_stats_conf_run() and
+     * osw_stats_run() get orchestrated in order to prevent
+     * this in the first place. But these are intended to
+     * not know about each other, at least explicitly, so
+     * there's no easy way to fix this otherwise for now.
+     */
+    const double age_seconds = now - e->last_sub_reported_at;
+    const double max_age_seconds = (e->params.sample_seconds ?: e->params.report_seconds) / 2;
+    if (age_seconds > max_age_seconds) {
+        e->underrun++;
+        if (e->underrun < OW_STATS_CONF_MAX_UNDERRUN) {
+            return false;
+        }
+
+        LOGI("ow: stats: conf: underrun on entry '%s', type=%s radio=%s chan=%s",
+             e->id,
+             ow_stats_conf_stats_type_to_str(e->params.stats_type),
+             ow_stats_conf_radio_type_to_str(e->params.radio_type),
+             ow_stats_conf_scan_type_to_str(e->params.scan_type));
+    }
+    return true;
+}
+
+static void
+ow_stats_conf_entry_report(struct ow_stats_conf_entry *e,
+                           const double now_mono,
+                           const double now_real)
+{
+    if (e->report_at <= 0) return;
+    if (e->report_at > now_mono) return;
+    if (ow_stats_conf_is_entry_ready(e, now_mono) == false) return;
+
+    switch (e->params.stats_type) {
+    case OW_STATS_CONF_STATS_TYPE_SURVEY:
+        ow_stats_conf_entry_report_survey(e, now_mono, now_real);
+        break;
+    case OW_STATS_CONF_STATS_TYPE_NEIGHBOR:
+        ow_stats_conf_entry_report_neighbor(e, now_mono, now_real);
+        break;
+    case OW_STATS_CONF_STATS_TYPE_CLIENT:
+        ow_stats_conf_entry_report_client(e, now_mono, now_real);
+        break;
+    case OW_STATS_CONF_STATS_TYPE_UNSPEC:
+        break;
+    }
+
+    assert(e->params.report_seconds > 0);
+    e->report_at = (floor(now_mono / e->params.report_seconds) + 1) * e->params.report_seconds;
+    e->underrun = 0;
+}
+
+static int
+ow_stats_conf_sta_cmp(const void *a, const void *b)
+{
+    const struct ow_stats_conf_sta_id *x = a;
+    const struct ow_stats_conf_sta_id *y = b;
+    const int c1 = osw_hwaddr_cmp(&x->addr, &y->addr);
+    const int c2 = strcmp(x->vif_name.buf, y->vif_name.buf);
+    if (c1 != 0) return c1;
+    if (c2 != 0) return c2;
+    return 0;
+}
+
+const struct osw_ssid *
+ow_stats_conf_sta_get_ssid(const struct osw_state_sta_info *sta)
+{
+    const struct osw_drv_vif_state_ap *vap = &sta->vif->drv_state->u.ap;
+    const struct osw_drv_vif_state_sta *vsta = &sta->vif->drv_state->u.sta;
+
+    switch (sta->vif->drv_state->vif_type) {
+        case OSW_VIF_UNDEFINED: return NULL;
+        case OSW_VIF_AP_VLAN: return NULL;
+        case OSW_VIF_AP: return &vap->ssid;
+        case OSW_VIF_STA: return &vsta->link.ssid;
+    }
+
+    return NULL;
+}
+
+struct ow_stats_conf_sta *
+ow_stats_conf_sta_get(struct ow_stats_conf_entry *e,
+                      const struct osw_state_sta_info *sta)
+{
+    struct ow_stats_conf_sta_id id = {0};
+    STRSCPY_WARN(id.vif_name.buf, sta->vif->vif_name);
+    id.addr = *sta->mac_addr;
+
+    struct ow_stats_conf_sta *i = ds_tree_find(&e->sta_tree, &id);
+    if (i != NULL) return i;
+
+    const struct osw_ssid *ssid = ow_stats_conf_sta_get_ssid(sta);
+    if (WARN_ON(ssid == NULL)) return NULL;
+
+    i = CALLOC(1, sizeof(*i));
+    i->id = id;
+    memcpy(&i->ssid, ssid, sizeof(*ssid));
+    ds_tree_insert(&e->sta_tree, i, &i->id);
+
+    return i;
+}
+
+void
+ow_stats_conf_sta_set_connected(struct ow_stats_conf_entry *e,
+                                const struct osw_state_sta_info *sta,
+                                const bool connected,
+                                const double now)
+{
+    struct ow_stats_conf_sta *scsta = ow_stats_conf_sta_get(e, sta);
+    if (scsta == NULL) return;
+
+    if (connected == true) {
+        scsta->connected_at = now;
+        scsta->num_connects++;
+    }
+    else {
+        scsta->disconnected_at = now;
+        scsta->num_disconnects++;
+    }
+
+    scsta->is_connected = connected;
+}
+
+void
+ow_stats_conf_sta_connected_cb(struct osw_state_observer *self,
+                               const struct osw_state_sta_info *sta)
+{
+    struct ow_stats_conf_entry *e = container_of(self, struct ow_stats_conf_entry, obs);
+    const double now_mono = OSW_TIME_TO_DBL(osw_time_mono_clk());
+    ow_stats_conf_sta_set_connected(e, sta, true, now_mono);
+}
+
+void
+ow_stats_conf_sta_disconnected_cb(struct osw_state_observer *self,
+                                  const struct osw_state_sta_info *sta)
+{
+    struct ow_stats_conf_entry *e = container_of(self, struct ow_stats_conf_entry, obs);
+    const double now_mono = OSW_TIME_TO_DBL(osw_time_mono_clk());
+    ow_stats_conf_sta_set_connected(e, sta, false, now_mono);
+}
+
+static const struct osw_state_observer g_ow_stats_conf_sta_obs = {
+    .name = __FILE__,
+    .sta_connected_fn = ow_stats_conf_sta_connected_cb,
+    .sta_disconnected_fn = ow_stats_conf_sta_disconnected_cb,
+};
+
+static void
+ow_stats_conf_entry_start(struct ow_stats_conf_entry *e,
+                          const double now)
+{
+    double poll;
+    double report;
+    ow_stats_conf_entry_get_sub_timings(e, &poll, &report);
+    assert(report > 0);
+
+    LOGI("ow: stats: entry: %s: starting type=%s radio=%s chan=%s",
+          e->id ?: "",
+          ow_stats_conf_stats_type_to_str(e->params.stats_type),
+          ow_stats_conf_radio_type_to_str(e->params.radio_type),
+          ow_stats_conf_scan_type_to_str(e->params.scan_type));
+
+    e->obs = g_ow_stats_conf_sta_obs;
+
+    assert(e->sub == NULL);
+    e->sub = osw_stats_subscriber_alloc();
+    switch (e->params.stats_type) {
+        case OW_STATS_CONF_STATS_TYPE_SURVEY: osw_stats_subscriber_set_chan(e->sub, true); break;
+        case OW_STATS_CONF_STATS_TYPE_CLIENT: osw_stats_subscriber_set_sta(e->sub, true); break;
+        case OW_STATS_CONF_STATS_TYPE_NEIGHBOR: osw_stats_subscriber_set_bss(e->sub, true); break;
+        case OW_STATS_CONF_STATS_TYPE_UNSPEC: break;
+    }
+    osw_stats_subscriber_set_report_fn(e->sub, ow_stats_conf_sub_report_cb, e);
+    osw_stats_subscriber_set_report_seconds(e->sub, report);
+    osw_stats_subscriber_set_poll_seconds(e->sub, poll);
+    osw_stats_register_subscriber(e->sub);
+    osw_state_register_observer(&e->obs);
+
+    if (e->params.report_seconds > 0) {
+        e->report_at = (floor(now / e->params.report_seconds) + 1) * e->params.report_seconds;
+    }
+}
+
+enum ow_stats_conf_entry_process_op {
+    OW_STATS_CONF_ENTRY_PROCESS_NOP,
+    OW_STATS_CONF_ENTRY_PROCESS_STOP,
+    OW_STATS_CONF_ENTRY_PROCESS_FREE,
+    OW_STATS_CONF_ENTRY_PROCESS_START,
+};
+
+static enum ow_stats_conf_entry_process_op
+ow_stats_conf_entry_process__(struct ow_stats_conf_entry *e)
+{
+    bool processed = true;
+    const bool changed = ow_stats_conf_entry_params_changed(&e->params,
+                                                            &e->params_next);
+
+    ow_stats_conf_entry_params_free(&e->params);
+    ow_stats_conf_entry_params_copy(&e->params, &e->params_next);
+
+    if (changed == true) {
+        processed = false;
+    }
+
+    if (e->params.valid == false) {
+        processed = false;
+    }
+
+    if (processed == true) {
+        return OW_STATS_CONF_ENTRY_PROCESS_NOP;
+    }
+
+    if (e->params_next.valid == false) {
+        return OW_STATS_CONF_ENTRY_PROCESS_FREE;
+    }
+
+    if (e->params.radio_type == OW_STATS_CONF_RADIO_TYPE_UNSPEC) {
+        LOGD("%s: %s: radio type unspec", __func__, e->id);
+        return OW_STATS_CONF_ENTRY_PROCESS_STOP;
+    }
+
+    switch (e->params.stats_type) {
+        case OW_STATS_CONF_STATS_TYPE_UNSPEC:
+            return OW_STATS_CONF_ENTRY_PROCESS_STOP;
+        case OW_STATS_CONF_STATS_TYPE_NEIGHBOR:
+        case OW_STATS_CONF_STATS_TYPE_SURVEY:
+            if (e->params.scan_type == OW_STATS_CONF_SCAN_TYPE_UNSPEC) {
+                LOGD("%s: %s: scan type unspec", __func__, e->id);
+                return OW_STATS_CONF_ENTRY_PROCESS_STOP;
+            }
+            break;
+        case OW_STATS_CONF_STATS_TYPE_CLIENT:
+            break;
+    }
+
+    return OW_STATS_CONF_ENTRY_PROCESS_START;
+}
+
+static void
+ow_stats_conf_entry_process(struct ow_stats_conf_entry *e,
+                            const double now)
+{
+    switch (ow_stats_conf_entry_process__(e)) {
+        case OW_STATS_CONF_ENTRY_PROCESS_NOP:
+            break;
+        case OW_STATS_CONF_ENTRY_PROCESS_STOP:
+            ow_stats_conf_entry_stop(e);
+            break;
+        case OW_STATS_CONF_ENTRY_PROCESS_FREE:
+            ow_stats_conf_entry_free(e);
+            break;
+        case OW_STATS_CONF_ENTRY_PROCESS_START:
+            ow_stats_conf_entry_stop(e);
+            ow_stats_conf_entry_start(e, now);
+            break;
+    }
+}
+
+struct ow_stats_conf_entry *
+ow_stats_conf_get_entry(struct ow_stats_conf *conf,
+                        const char *id)
+{
+    struct ow_stats_conf_entry *e = ds_tree_find(&conf->entries, id);
+    if (e == NULL) {
+        e = CALLOC(1, sizeof(*e));
+        e->conf = conf;
+        e->id = STRDUP(id);
+        ds_dlist_init(&e->surveys, dpp_survey_record_t, node);
+        ds_dlist_init(&e->neighbors, dpp_neighbor_record_list_t, node);
+        ds_dlist_init(&e->clients, dpp_client_record_t, node);
+        ds_tree_init(&e->sta_tree, ow_stats_conf_sta_cmp, struct ow_stats_conf_sta, node);
+        ds_tree_insert(&conf->entries, e, e->id);
+    }
+    return e;
+}
+
+void
+ow_stats_conf_entry_reset_all(struct ow_stats_conf *conf)
+{
+    struct ow_stats_conf_entry *e;
+    ds_tree_foreach(&conf->entries, e)
+        ow_stats_conf_entry_reset(e);
+}
+
+void
+ow_stats_conf_entry_reset(struct ow_stats_conf_entry *e)
+{
+    osw_timer_arm_at_nsec(&e->conf->work, 0);
+    memset(&e->params_next, 0, sizeof(e->params_next));
+}
+
+void
+ow_stats_conf_entry_set_sampling(struct ow_stats_conf_entry *e,
+                                 int seconds)
+{
+    osw_timer_arm_at_nsec(&e->conf->work, 0);
+    e->params_next.valid = true;
+    e->params_next.sample_seconds = seconds;
+}
+
+void
+ow_stats_conf_entry_set_reporting(struct ow_stats_conf_entry *e,
+                                  int seconds)
+{
+    osw_timer_arm_at_nsec(&e->conf->work, 0);
+    e->params_next.valid = true;
+    e->params_next.report_seconds = seconds;
+}
+
+void
+ow_stats_conf_entry_set_radio_type(struct ow_stats_conf_entry *e,
+                                   enum ow_stats_conf_radio_type radio_type)
+{
+    osw_timer_arm_at_nsec(&e->conf->work, 0);
+    e->params_next.valid = true;
+    e->params_next.radio_type = radio_type;
+}
+
+void
+ow_stats_conf_entry_set_scan_type(struct ow_stats_conf_entry *e,
+                                   enum ow_stats_conf_scan_type scan_type)
+{
+    osw_timer_arm_at_nsec(&e->conf->work, 0);
+    e->params_next.valid = true;
+    e->params_next.scan_type = scan_type;
+}
+
+void
+ow_stats_conf_entry_set_stats_type(struct ow_stats_conf_entry *e,
+                                   enum ow_stats_conf_stats_type stats_type)
+{
+    osw_timer_arm_at_nsec(&e->conf->work, 0);
+    e->params_next.valid = true;
+    e->params_next.stats_type = stats_type;
+}
+
+void
+ow_stats_conf_entry_set_channels(struct ow_stats_conf_entry *e,
+                                 const int *channels,
+                                 size_t n_channels)
+{
+    osw_timer_arm_at_nsec(&e->conf->work, 0);
+    e->params_next.valid = true;
+
+    const size_t size = n_channels * sizeof(*channels);
+    const bool changed = ((n_channels == e->params_next.n_channels) &&
+                          (n_channels == 0 ||
+                           memcmp(channels, e->params_next.channels, size) == 0));
+    if (changed == false) return;
+
+    FREE(e->params_next.channels);
+    e->params_next.channels = NULL;
+    e->params_next.n_channels = 0;
+    if (channels == NULL) return;
+    e->params_next.channels = MEMNDUP(channels, size);
+    e->params_next.n_channels = n_channels;
+}
+
+static bool
+ow_stats_conf_report_gen(uint8_t **buf, uint32_t *len)
+{
+    const size_t max = 128 * 1024;
+#ifndef DPP_FAST_PACK
+    if (dpp_get_queue_elements() == 0)
+        return false;
+
+    *buf = MALLOC(max);
+    return dpp_get_report(*buf, max, len);
+#else
+    return dpp_get_report2(buf, max, len);
+#endif
+}
+
+static void
+ow_stats_conf_report_send(void)
+{
+    uint8_t *buf = NULL;
+    uint32_t len;
+    const bool generated = ow_stats_conf_report_gen(&buf, &len);
+    if (generated == false) goto free;
+    if (len <= 0) goto free;
+    qm_response_t res;
+    LOGI("ow: stats: conf: sending report: len=%u", len);
+    const bool sent = qm_conn_send_stats(buf, len, &res);
+    WARN_ON(sent == false);
+    /* FIXME: Should probably store the buffer if sending
+     * failed and re-try later without re-generating reports
+     */
+free:
+    FREE(buf);
+}
+
+static double
+ow_stats_conf_get_next_at(struct ow_stats_conf *c)
+{
+    struct ow_stats_conf_entry *e;
+    double at = -1;
+
+    ds_tree_foreach(&c->entries, e) {
+        const bool changed = ow_stats_conf_entry_params_changed(&e->params,
+                                                                &e->params_next);
+        if (changed == true) at = 0;
+        if (e->report_at <= 0) continue;
+        if (at < 0) at = e->report_at;
+        if (at > e->report_at) at = e->report_at;
+    }
+
+    return OSW_TIME_SEC(at);
+}
+
+static void
+ow_stats_conf_run(struct ow_stats_conf *c,
+                  const double now_mono,
+                  const double now_real)
+{
+    struct ow_stats_conf_entry *e;
+    struct ow_stats_conf_entry *te;
+
+    ds_tree_foreach_safe(&c->entries, e, te)
+        ow_stats_conf_entry_process(e, now_mono);
+
+    ds_tree_foreach(&c->entries, e)
+        ow_stats_conf_entry_report(e, now_mono, now_real);
+
+    ow_stats_conf_report_send();
+
+    const double next_at = ow_stats_conf_get_next_at(c);
+    if (next_at >= 0) osw_timer_arm_at_nsec(&c->work, next_at);
+}
+
+static void
+ow_stats_conf_work_cb(struct osw_timer *t)
+{
+    struct ow_stats_conf *c = container_of(t, struct ow_stats_conf, work);
+    const double now_mono = OSW_TIME_TO_DBL(osw_time_mono_clk());
+    const double now_real = OSW_TIME_TO_DBL(osw_time_wall_clk());
+    ow_stats_conf_run(c, now_mono, now_real);
+}
+
+radio_type_t
+ow_stats_conf_phy_to_type(const struct osw_state_phy_info *phy)
+{
+    const int b2ch1 = 2412;
+    const int b2ch13 = 2472;
+    const int b2ch14 = 2484;
+    const int b5ch36 = 5180;
+    const int b5ch100 = 5500;
+    const int b5ch177 = 5885;
+    const int b6ch1 = 5955;
+    const int b6ch2 = 5935;
+    const int b6ch233 = 7115;
+    bool band_2g = false;
+    bool band_5gl = false;
+    bool band_5gu = false;
+    bool band_6g = false;
+    size_t i;
+    for (i = 0; i < phy->drv_state->n_channel_states; i++) {
+        const struct osw_channel_state *s = &phy->drv_state->channel_states[i];
+        const int freq = s->channel.control_freq_mhz;
+        if (freq >= b2ch1 && freq <= b2ch13) band_2g = true;
+        if (freq == b2ch14) band_2g = true;
+        if (freq >= b5ch36 && freq < b5ch100) band_5gl = true;
+        if (freq >= b5ch100 && freq <= b5ch177) band_5gu = true;
+        if (freq == b6ch2) band_6g = true;
+        if (freq >= b6ch1 && freq <= b6ch233) band_6g = true;
+    }
+    const bool band_5g = band_5gl && band_5gu;
+    const bool bands = band_2g + (band_5gl || band_5gu) + band_6g;
+    if (bands != 1) return RADIO_TYPE_NONE;
+    else if (band_2g) return RADIO_TYPE_2G;
+    else if (band_5g) return RADIO_TYPE_5G;
+    else if (band_5gl) return RADIO_TYPE_5GL;
+    else if (band_5gu) return RADIO_TYPE_5GU;
+    else if (band_6g) return RADIO_TYPE_6G;
+    else return RADIO_TYPE_NONE;
+}
+
+static void
+ow_stats_conf_band_set__(struct ow_stats_conf *c,
+                         const char *phy_name,
+                         enum ow_stats_conf_radio_type t)
+{
+    struct ow_stats_conf_band *b = ds_tree_find(&c->bands, phy_name);
+
+    if (b == NULL) {
+        b = CALLOC(1, sizeof(*b));
+        b->phy_name = STRDUP(phy_name);
+        ds_tree_insert(&c->bands, b, b->phy_name);
+    }
+
+    b->type = t;
+
+    if (t == OW_STATS_CONF_RADIO_TYPE_UNSPEC) {
+        ds_tree_remove(&c->bands, b);
+        FREE(b->phy_name);
+        FREE(b);
+    }
+}
+
+static void
+ow_stats_conf_band_set(struct osw_state_observer *self,
+                       const struct osw_state_phy_info *phy,
+                       bool removing)
+{
+    struct ow_stats_conf *c = container_of(self, struct ow_stats_conf, state_obs);
+    const radio_type_t t = removing ? 0 : ow_stats_conf_phy_to_type(phy);
+    ow_stats_conf_band_set__(c, phy->phy_name, t);
+}
+
+static void
+ow_stats_conf_phy_added_cb(struct osw_state_observer *self,
+                           const struct osw_state_phy_info *phy)
+{
+    ow_stats_conf_band_set(self, phy, false);
+}
+
+static void
+ow_stats_conf_phy_changed_cb(struct osw_state_observer *self,
+                             const struct osw_state_phy_info *phy)
+{
+    ow_stats_conf_band_set(self, phy, false);
+}
+
+static void
+ow_stats_conf_phy_removed_cb(struct osw_state_observer *self,
+                             const struct osw_state_phy_info *phy)
+{
+    ow_stats_conf_band_set(self, phy, true);
+}
+
+static int
+ow_stats_conf_vif_get_freq_mhz(const struct osw_state_vif_info *vif)
+{
+    if (vif->drv_state->enabled == false) return 0;
+    switch (vif->drv_state->vif_type) {
+        case OSW_VIF_UNDEFINED: return 0;
+        case OSW_VIF_AP: return vif->drv_state->u.ap.channel.control_freq_mhz;
+        case OSW_VIF_AP_VLAN: return 0;
+        case OSW_VIF_STA: return 0; /* FIXME */
+    }
+    return 0;
+}
+
+static void
+ow_stats_conf_freq_set__(struct ow_stats_conf *c,
+                         const char *phy_name,
+                         const char *vif_name,
+                         uint32_t freq_mhz)
+{
+    struct ow_stats_conf_freq_vif *fv = ds_tree_find(&c->freqs_vif, vif_name);
+    struct ow_stats_conf_freq_phy *fp = ds_tree_find(&c->freqs_phy, phy_name);
+
+    if (fp == NULL) {
+        fp = CALLOC(1, sizeof(*fp));
+        fp->phy_name = STRDUP(phy_name);
+        ds_tree_init(&fp->vifs, ds_str_cmp, struct ow_stats_conf_freq_vif, phy_node);
+        ds_tree_insert(&c->freqs_phy, fp, fp->phy_name);
+    }
+
+    if (fv == NULL) {
+        fv = CALLOC(1, sizeof(*fv));
+        fv->vif_name = STRDUP(vif_name);
+        ds_tree_insert(&c->freqs_vif, fv, fv->vif_name);
+        ds_tree_insert(&fp->vifs, fv, fv->vif_name);
+    }
+
+    fv->freq_mhz = freq_mhz;
+
+    if (freq_mhz == 0) {
+        ds_tree_remove(&fp->vifs, fv);
+        ds_tree_remove(&c->freqs_vif, fv);
+        FREE(fv->vif_name);
+        FREE(fv);
+
+        if (ds_tree_is_empty(&fp->vifs) == true) {
+            ds_tree_remove(&c->freqs_phy, fp);
+            FREE(fp->phy_name);
+            FREE(fp);
+        }
+    }
+}
+
+static bool
+ow_stats_conf_freq_is_valid(const struct osw_state_vif_info *vif)
+{
+    switch (vif->drv_state->vif_type) {
+        case OSW_VIF_UNDEFINED:
+        case OSW_VIF_AP_VLAN:
+            return false;
+        case OSW_VIF_AP:
+        case OSW_VIF_STA:
+            return vif->drv_state->enabled;
+    }
+    return false;
+}
+
+static void
+ow_stats_conf_freq_set(struct osw_state_observer *self,
+                       const struct osw_state_vif_info *vif,
+                       const bool removing)
+{
+    struct ow_stats_conf *c = container_of(self, struct ow_stats_conf, state_obs);
+    const bool valid = (removing == false && ow_stats_conf_freq_is_valid(vif));
+    const int freq_mhz = valid ? ow_stats_conf_vif_get_freq_mhz(vif) : 0;
+    ow_stats_conf_freq_set__(c, vif->phy->phy_name, vif->vif_name, freq_mhz);
+}
+
+static void
+ow_stats_conf_vif_added_cb(struct osw_state_observer *self,
+                           const struct osw_state_vif_info *vif)
+{
+    ow_stats_conf_freq_set(self, vif, false);
+}
+
+static void
+ow_stats_conf_vif_changed_cb(struct osw_state_observer *self,
+                             const struct osw_state_vif_info *vif)
+{
+    ow_stats_conf_freq_set(self, vif, false);
+}
+
+static void
+ow_stats_conf_vif_removed_cb(struct osw_state_observer *self,
+                             const struct osw_state_vif_info *vif)
+{
+    ow_stats_conf_freq_set(self, vif, true);
+}
+
+static void
+ow_stats_conf_init_dpp(void)
+{
+    static bool initialized = false;
+    if (initialized == true) return;
+    dpp_init();
+    initialized = true;
+}
+
+static void
+ow_stats_conf_init(struct ow_stats_conf *c)
+{
+    ds_tree_init(&c->entries, ds_str_cmp, struct ow_stats_conf_entry, node);
+    ds_tree_init(&c->bands, ds_str_cmp, struct ow_stats_conf_band, node);
+    ds_tree_init(&c->freqs_phy, ds_str_cmp, struct ow_stats_conf_freq_phy, node);
+    ds_tree_init(&c->freqs_vif, ds_str_cmp, struct ow_stats_conf_freq_vif, conf_node);
+    ow_stats_conf_init_dpp();
+    osw_timer_init(&c->work, ow_stats_conf_work_cb);
+}
+
+static void
+ow_stats_conf_attach(struct ow_stats_conf *c)
+{
+    struct osw_state_observer obs = {
+        .name = __FILE__,
+        .phy_added_fn = ow_stats_conf_phy_added_cb,
+        .phy_changed_fn = ow_stats_conf_phy_changed_cb,
+        .phy_removed_fn = ow_stats_conf_phy_removed_cb,
+        .vif_added_fn = ow_stats_conf_vif_added_cb,
+        .vif_changed_fn = ow_stats_conf_vif_changed_cb,
+        .vif_removed_fn = ow_stats_conf_vif_removed_cb,
+    };
+    memcpy(&c->state_obs, &obs, sizeof(obs));
+    osw_state_register_observer(&c->state_obs);
+}
+
+struct ow_stats_conf *
+ow_stats_conf_get(void)
+{
+    static struct ow_stats_conf c;
+    if (c.state_obs.name == NULL) {
+        ow_stats_conf_init(&c);
+        ow_stats_conf_attach(&c);
+    }
+    return &c;
+}
+
+OSW_MODULE(ow_stats_conf)
+{
+    OSW_MODULE_LOAD(osw_stats);
+    return NULL;
+}
+
+OSW_UT(ow_stats_conf_changed)
+{
+    struct ow_stats_conf_entry_params p1 = {0};
+    struct ow_stats_conf_entry_params p2 = {0};
+    int c1[] = { 1, 2, 3 };
+
+    assert(ow_stats_conf_entry_params_changed(&p1, &p2) == false);
+    p1.n_channels = 1;
+    assert(ow_stats_conf_entry_params_changed(&p1, &p2) == true);
+    p2.n_channels = 1;
+    assert(ow_stats_conf_entry_params_changed(&p1, &p2) == true);
+    p1.n_channels = 0;
+    p2.n_channels = 0;
+
+    p1.channels = c1;
+    p1.n_channels = ARRAY_SIZE(c1);
+
+    ow_stats_conf_entry_params_free(&p2);
+    assert(ow_stats_conf_entry_params_changed(&p1, &p2) == true);
+    ow_stats_conf_entry_params_copy(&p2, &p1);
+    assert(p2.n_channels == 3);
+    assert(p2.channels != NULL);
+    assert(ow_stats_conf_entry_params_changed(&p1, &p2) == false);
+    ow_stats_conf_entry_params_free(&p2);
+}
+
+OSW_UT(ow_stats_conf_process)
+{
+    struct ow_stats_conf c = {0};
+    struct ow_stats_conf_entry e1 = {
+        .conf = &c,
+        .id = "e1",
+    };
+    enum ow_stats_conf_entry_process_op op;
+
+    ow_stats_conf_init(&c);
+
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_FREE);
+
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_FREE);
+
+    ow_stats_conf_entry_set_sampling(&e1, 1);
+    assert(e1.params_next.valid == true);
+    assert(e1.params_next.sample_seconds == 1);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_STOP);
+
+    ow_stats_conf_entry_set_radio_type(&e1, OW_STATS_CONF_RADIO_TYPE_2G);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_STOP);
+
+    ow_stats_conf_entry_set_stats_type(&e1, OW_STATS_CONF_STATS_TYPE_SURVEY);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_STOP);
+
+    ow_stats_conf_entry_set_stats_type(&e1, OW_STATS_CONF_STATS_TYPE_NEIGHBOR);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_STOP);
+
+    ow_stats_conf_entry_set_stats_type(&e1, OW_STATS_CONF_STATS_TYPE_NEIGHBOR);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_NOP);
+
+    ow_stats_conf_entry_set_scan_type(&e1, OW_STATS_CONF_SCAN_TYPE_ON_CHAN);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_START);
+
+    ow_stats_conf_entry_set_scan_type(&e1, OW_STATS_CONF_SCAN_TYPE_UNSPEC);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_STOP);
+
+    ow_stats_conf_entry_set_stats_type(&e1, OW_STATS_CONF_STATS_TYPE_CLIENT);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_START);
+
+    ow_stats_conf_entry_set_stats_type(&e1, OW_STATS_CONF_STATS_TYPE_CLIENT);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_NOP);
+
+    ow_stats_conf_entry_reset(&e1);
+    ow_stats_conf_entry_set_sampling(&e1, 1);
+    ow_stats_conf_entry_set_radio_type(&e1, OW_STATS_CONF_RADIO_TYPE_2G);
+    ow_stats_conf_entry_set_stats_type(&e1, OW_STATS_CONF_STATS_TYPE_CLIENT);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_NOP);
+
+    ow_stats_conf_entry_reset(&e1);
+    ow_stats_conf_entry_set_sampling(&e1, 2);
+    ow_stats_conf_entry_set_radio_type(&e1, OW_STATS_CONF_RADIO_TYPE_2G);
+    ow_stats_conf_entry_set_stats_type(&e1, OW_STATS_CONF_STATS_TYPE_CLIENT);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_START);
+
+    ow_stats_conf_entry_reset(&e1);
+    op = ow_stats_conf_entry_process__(&e1);
+    assert(op == OW_STATS_CONF_ENTRY_PROCESS_FREE);
+}
Index: core/src/lib/ow/src/ow_stats_conf_file.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_stats_conf_file.c
@@ -0,0 +1,156 @@
+#include <module.h>
+#include <const.h>
+#include <memutil.h>
+#include <os_time.h>
+#include <log.h>
+#include <osw_module.h>
+#include <ow_stats_conf.h>
+#include <ev.h>
+
+#define NOTE(fmt, ...) LOGI("%s:%d:%s(): " fmt, __FILE__, __LINE__, __func__, ##__VA_ARGS__)
+
+struct ow_stats_conf_file {
+    struct ow_stats_conf *conf;
+    struct ev_loop *loop;
+    ev_stat stat;
+};
+
+static void
+ow_stats_conf_file_process_line(struct ow_stats_conf *c,
+                                char *line)
+{
+    struct ow_stats_conf_entry *e = NULL;
+    bool empty = true;
+
+    while (line != NULL) {
+        char *attr = strsep(&line, " \n"); if (attr == NULL) break;
+        const char *k = strsep(&attr, "="); if (k == NULL) break;
+        char *v = strsep(&attr, " \n"); if (v == NULL) break;
+
+        NOTE("k='%s' v='%s'", k, v);
+
+        if (strcmp(k, "id") == 0) {
+            e = ow_stats_conf_get_entry(c, v);
+        }
+        else if (strcmp(k, "stats_type") == 0) {
+            if (e == NULL) continue;
+            if (strcmp(v, "survey") == 0) {
+                ow_stats_conf_entry_set_stats_type(e, OW_STATS_CONF_STATS_TYPE_SURVEY);
+                empty = false;
+            }
+            else if (strcmp(v, "neighbor") == 0) {
+                ow_stats_conf_entry_set_stats_type(e, OW_STATS_CONF_STATS_TYPE_NEIGHBOR);
+                empty = false;
+            }
+            else if (strcmp(v, "client") == 0) {
+                ow_stats_conf_entry_set_stats_type(e, OW_STATS_CONF_STATS_TYPE_CLIENT);
+                empty = false;
+            }
+        }
+        else if (strcmp(k, "scan_type") == 0) {
+            if (e == NULL) continue;
+            if (strcmp(v, "on-chan") == 0) {
+                ow_stats_conf_entry_set_scan_type(e, OW_STATS_CONF_SCAN_TYPE_ON_CHAN);
+                empty = false;
+            }
+            else if (strcmp(v, "off-chan") == 0) {
+                ow_stats_conf_entry_set_scan_type(e, OW_STATS_CONF_SCAN_TYPE_OFF_CHAN);
+                empty = false;
+            }
+        }
+        else if (strcmp(k, "radio_type") == 0) {
+            if (e == NULL) continue;
+            if (strcmp(v, "2.4G") == 0) {
+                ow_stats_conf_entry_set_radio_type(e, OW_STATS_CONF_RADIO_TYPE_2G);
+                empty = false;
+            }
+            else if (strcmp(v, "5G") == 0) {
+                ow_stats_conf_entry_set_radio_type(e, OW_STATS_CONF_RADIO_TYPE_5G);
+                empty = false;
+            }
+            else if (strcmp(v, "5GL") == 0) {
+                ow_stats_conf_entry_set_radio_type(e, OW_STATS_CONF_RADIO_TYPE_5GL);
+                empty = false;
+            }
+            else if (strcmp(v, "5GU") == 0) {
+                ow_stats_conf_entry_set_radio_type(e, OW_STATS_CONF_RADIO_TYPE_5GU);
+                empty = false;
+            }
+            else if (strcmp(v, "6G") == 0) {
+                ow_stats_conf_entry_set_radio_type(e, OW_STATS_CONF_RADIO_TYPE_6G);
+                empty = false;
+            }
+        }
+        else if (strcmp(k, "sampling") == 0) {
+            if (e == NULL) continue;
+            ow_stats_conf_entry_set_sampling(e, atoi(v));
+            empty = false;
+        }
+        else if (strcmp(k, "reporting") == 0) {
+            if (e == NULL) continue;
+            ow_stats_conf_entry_set_reporting(e, atoi(v));
+            empty = false;
+        }
+        else if (strcmp(k, "channels") == 0) {
+            const char *word;
+            int max = 32;
+            int chans[max];
+            int n = 0;
+            while (max-- > 0 && (word = strsep(&v, " ,\r\n")) != NULL)
+                chans[n++] = atoi(word);
+            ow_stats_conf_entry_set_channels(e, chans, n);
+            empty = false;
+        }
+    }
+
+    if (e != NULL && empty == true) {
+        ow_stats_conf_entry_reset(e);
+    }
+}
+
+static void
+ow_stats_conf_file_process_path(struct ow_stats_conf_file *cf,
+                                const char *path)
+{
+    NOTE("path='%s'", path);
+    FILE *f = fopen(path, "rb");
+    NOTE("path='%s' file=%p", path, f);
+    if (f == NULL) return;
+    char line[4096];
+    while (fgets(line, sizeof(line), f) != NULL) {
+        ow_stats_conf_file_process_line(cf->conf, line);
+    }
+    fclose(f);
+}
+
+static void
+ow_stats_conf_file_stat_cb(EV_P_ ev_stat *arg, int events)
+{
+    struct ow_stats_conf_file *cf;
+    cf = container_of(arg, struct ow_stats_conf_file, stat);
+    ow_stats_conf_file_process_path(cf, arg->path);
+}
+
+static void
+ow_stats_conf_file_start(EV_P_ const char *path)
+{
+    struct ow_stats_conf_file *cf = CALLOC(1, sizeof(*cf));
+
+    LOGI("ow: stats: conf: file: path='%s'", path);
+    cf->conf = ow_stats_conf_get();
+    cf->loop = EV_A;
+    ev_stat_init(&cf->stat, ow_stats_conf_file_stat_cb, path, 0);
+    ev_stat_start(EV_A_ &cf->stat);
+    ev_unref(EV_A);
+}
+
+OSW_MODULE(ow_stats_conf_file)
+{
+    const char *path = getenv("OW_STATS_CONF_FILE_PATH");
+    if (path == NULL) return NULL;
+    if (strlen(path) == 0) return NULL;
+    OSW_MODULE_LOAD(ow_stats_conf);
+    struct ev_loop *loop = OSW_MODULE_LOAD(osw_ev);
+    ow_stats_conf_file_start(loop, path);
+    return NULL;
+}
Index: core/src/lib/ow/src/ow_steer.c
===================================================================
--- core.orig/src/lib/ow/src/ow_steer.c
+++ core/src/lib/ow/src/ow_steer.c
@@ -1,21 +1,162 @@
 #include <memutil.h>
 #include <ds_dlist.h>
 #include <ds_tree.h>
-#include <osw_ut.h>
+#include <util.h>
+#include <const.h>
 #include <module.h>
+#include <log.h>
+#include <osw_conf.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_bss_map.h>
+#include <osw_timer.h>
+#include <osw_stats.h>
+#include <osw_stats_defs.h>
+#include "ow_steer_sta.h"
+#include "ow_steer_sta_priv.h"
+#include "ow_steer_sta_i.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_stack.h"
 
-#include "ow_steer.h"
+#define OW_STEER_STATS_PERIOD_SEC 0.5
 
 static void
-ow_steer_ut_module_init(void *data)
+ow_steer_mutator_cb(struct osw_conf_mutator *mutator,
+                    struct ds_tree *phy_tree);
+
+static struct ds_dlist g_sta_list = DS_DLIST_INIT(struct ow_steer_sta, node);
+static struct ev_signal g_sigusr1;
+static struct osw_stats_subscriber *g_stats_sub = NULL;
+static struct osw_conf_mutator g_mutator = {
+    .name = __FILE__,
+    .mutate_fn = ow_steer_mutator_cb,
+    .type = OSW_CONF_TAIL,
+};
+
+static void
+ow_steer_sigusr1_cb(EV_P_ ev_signal *arg,
+                    int events)
 {
+    LOGI("ow: steer: steer:");
 
+    /* TODO */
 }
 
 static void
-ow_steer_ut_module_fini(void *data)
+ow_steer_stats_report_cb(enum osw_stats_id id,
+                         const struct osw_tlv *data,
+                         const struct osw_tlv *last,
+                         void *priv)
 {
-    /* nop */
+    const struct osw_stats_defs *stats_defs = osw_stats_defs_lookup(OSW_STATS_STA);
+    const struct osw_tlv_hdr *tb[OSW_STATS_STA_MAX__] = {0};
+    const struct osw_state_vif_info *vif_info;
+    const struct osw_hwaddr *bssid;
+    const struct osw_hwaddr *sta_addr;
+    const char *phy_name;
+    const char *vif_name;
+
+    if (id != OSW_STATS_STA)
+        return;
+
+    osw_tlv_parse(data->data, data->used, stats_defs->tpolicy, tb, OSW_STATS_STA_MAX__);
+
+    if (tb[OSW_STATS_STA_PHY_NAME] == NULL ||
+        tb[OSW_STATS_STA_VIF_NAME] == NULL ||
+        tb[OSW_STATS_STA_MAC_ADDRESS] == NULL)
+        return;
+    if (tb[OSW_STATS_STA_SNR_DB] == NULL &&
+        (tb[OSW_STATS_STA_TX_BYTES] == NULL && tb[OSW_STATS_STA_RX_BYTES] == NULL))
+        return;
+
+    sta_addr = osw_tlv_get_data(tb[OSW_STATS_STA_MAC_ADDRESS]);
+    phy_name = osw_tlv_get_string(tb[OSW_STATS_STA_PHY_NAME]);
+    vif_name = osw_tlv_get_string(tb[OSW_STATS_STA_VIF_NAME]);
+
+    vif_info = osw_state_vif_lookup(phy_name, vif_name);
+    if (vif_info == NULL)
+        return;
+    if (vif_info->drv_state == NULL)
+        return;
+
+    bssid = &vif_info->drv_state->mac_addr;
+
+    if (tb[OSW_STATS_STA_SNR_DB] != NULL) {
+        struct ow_steer_sta *sta;
+        const uint32_t snr_db = osw_tlv_get_u32(tb[OSW_STATS_STA_SNR_DB]);
+
+        ds_dlist_foreach(&g_sta_list, sta) {
+            if (osw_hwaddr_cmp(ow_steer_sta_get_addr(sta), sta_addr) != 0)
+                continue;
+
+            struct ow_steer_policy_stack *policy_stack = ow_steer_sta_get_policy_stack(sta);
+            ow_steer_policy_stack_sta_snr_change(policy_stack, sta_addr, bssid, snr_db);
+        }
+    }
+
+    if (tb[OSW_STATS_STA_TX_BYTES] != NULL || tb[OSW_STATS_STA_RX_BYTES] != NULL) {
+        struct ow_steer_sta *sta;
+        uint64_t data_vol = 0;
+
+        data_vol += tb[OSW_STATS_STA_TX_BYTES] != NULL ? osw_tlv_get_u32(tb[OSW_STATS_STA_TX_BYTES]) : 0;
+        data_vol += tb[OSW_STATS_STA_RX_BYTES] != NULL ? osw_tlv_get_u32(tb[OSW_STATS_STA_RX_BYTES]) : 0;
+
+        ds_dlist_foreach(&g_sta_list, sta) {
+            if (osw_hwaddr_cmp(ow_steer_sta_get_addr(sta), sta_addr) != 0)
+                continue;
+
+            struct ow_steer_policy_stack *policy_stack = ow_steer_sta_get_policy_stack(sta);
+            ow_steer_policy_stack_sta_data_vol_change(policy_stack, sta_addr, bssid, data_vol);
+        }
+    }
 }
 
-MODULE(ow_steer_ut_module, ow_steer_ut_module_init, ow_steer_ut_module_fini);
+static void
+ow_steer_mutator_cb(struct osw_conf_mutator *mutator,
+                    struct ds_tree *phy_tree)
+{
+    assert(mutator != NULL);
+    assert(phy_tree != NULL);
+
+    struct ow_steer_sta *sta;
+    ds_dlist_foreach(&g_sta_list, sta)
+        ow_steer_sta_conf_mutate(sta, phy_tree);
+}
+
+static void
+ow_steer_init(void)
+{
+    ev_signal_init(&g_sigusr1, ow_steer_sigusr1_cb, SIGUSR1);
+    ev_signal_start(EV_DEFAULT_ &g_sigusr1);
+    ev_unref(EV_DEFAULT);
+
+    assert(g_stats_sub == NULL);
+    g_stats_sub = osw_stats_subscriber_alloc();
+    osw_stats_subscriber_set_report_seconds(g_stats_sub, OW_STEER_STATS_PERIOD_SEC);
+    osw_stats_subscriber_set_poll_seconds(g_stats_sub, OW_STEER_STATS_PERIOD_SEC);
+    osw_stats_subscriber_set_report_fn(g_stats_sub, ow_steer_stats_report_cb, NULL);
+    osw_stats_subscriber_set_sta(g_stats_sub, true);
+    osw_stats_register_subscriber(g_stats_sub);
+
+    osw_conf_register_mutator(&g_mutator);
+}
+
+struct ds_dlist*
+ow_steer_get_sta_list(void)
+{
+    return &g_sta_list;
+}
+
+struct osw_conf_mutator*
+ow_steer_get_mutator(void)
+{
+    return &g_mutator;
+}
+
+OSW_MODULE(ow_steer)
+{
+    OSW_MODULE_LOAD(osw_stats);
+    OSW_MODULE_LOAD(osw_conf);
+    ow_steer_init();
+    return NULL;
+}
Index: core/src/lib/ow/src/ow_steer.h
===================================================================
--- core.orig/src/lib/ow/src/ow_steer.h
+++ core/src/lib/ow/src/ow_steer.h
@@ -1,6 +1,19 @@
-#ifndef OSW_STEER_H
-#define OSW_STEER_H
+#ifndef OSW_STEER_H_INCLUDED
+#define OSW_STEER_H_INCLUDED
 
+struct ow_steer;
 
+void
+ow_steer_init(void);
 
-#endif /* OSW_STEER_H */
+struct ow_steer*
+ow_steer_create(void);
+
+void
+ow_steer_free(struct ow_steer *steer);
+
+struct ow_steer_sta*
+ow_steer_get_sta(struct ow_steer *steer,
+                 const struct osw_hwaddr *mac_addr);
+
+#endif /* OSW_STEER_H_INCLUDED */
Index: core/src/lib/ow/src/ow_steer_bm.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_bm.c
@@ -0,0 +1,1541 @@
+#include <string.h>
+#include <memutil.h>
+#include <ds_dlist.h>
+#include <osw_types.h>
+#include <util.h>
+#include <const.h>
+#include <log.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_bss_map.h>
+#include <ow_steer_bm.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_sta.h"
+#include "ow_steer_sta_priv.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_bss_filter.h"
+#include "ow_steer_policy_pre_assoc_counter.h"
+#include "ow_steer_policy_directed_away.h"
+#include "ow_steer_policy_directed_home.h"
+#include "ow_steer_policy_force_kick.h"
+#include "ow_steer_policy_snr_xing.h"
+#include "ow_steer_policy_stack.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_action_acl.h"
+#include "ow_steer_executor_action_btm.h"
+#include "ow_steer_executor_action_deauth.h"
+#include "ow_steer_executor_chain.h"
+
+#define OW_STEER_BM_POLICY_BSS_FILTER_PRIO 0 /* the highest */
+#define OW_STEER_BM_POLICY_FORCE_KICK_PRIO 1
+#define OW_STEER_BM_POLICY_CLIENT_STEERING_PRIO 3
+#define OW_STEER_BM_POLICY_SNR_XING_PRIO 4
+#define OW_STEER_BM_POLICY_PRE_ASSOC_PRIO 5 /* the lowest */
+
+struct ow_steer_bm_observer;
+
+typedef void
+ow_steer_bm_vif_added_fn_t(struct ow_steer_bm_observer *observer,
+                           struct ow_steer_bm_vif *vif);
+
+typedef void
+ow_steer_bm_vif_removed_fn_t(struct ow_steer_bm_observer *observer,
+                             struct ow_steer_bm_vif *vif);
+
+typedef void
+ow_steer_bm_vif_up_fn_t(struct ow_steer_bm_observer *observer,
+                        struct ow_steer_bm_vif *vif);
+
+typedef void
+ow_steer_bm_vif_down_fn_t(struct ow_steer_bm_observer *observer,
+                          struct ow_steer_bm_vif *vif);
+
+typedef void
+ow_steer_bm_neighbor_up_fn_t(struct ow_steer_bm_observer *observer,
+                             struct ow_steer_bm_neighbor *neighbor);
+
+typedef void
+ow_steer_bm_neighbor_down_fn_t(struct ow_steer_bm_observer *observer,
+                               struct ow_steer_bm_neighbor *neighbor);
+
+typedef void
+ow_steer_bm_client_added_fn_t(struct ow_steer_bm_observer *observer,
+                              struct ow_steer_bm_client *client);
+
+typedef void
+ow_steer_bm_client_changed_fn_t(struct ow_steer_bm_observer *observer,
+                                struct ow_steer_bm_client *client);
+
+typedef void
+ow_steer_bm_client_removed_fn_t(struct ow_steer_bm_observer *observer,
+                                struct ow_steer_bm_client *client);
+
+struct ow_steer_bm_observer {
+    ow_steer_bm_vif_added_fn_t *vif_added_fn;
+    ow_steer_bm_vif_removed_fn_t *vif_removed_fn;
+    ow_steer_bm_vif_up_fn_t *vif_up_fn;
+    ow_steer_bm_vif_down_fn_t *vif_down_fn;
+    ow_steer_bm_neighbor_up_fn_t *neighbor_up_fn;
+    ow_steer_bm_neighbor_down_fn_t *neighbor_down_fn;
+    ow_steer_bm_client_added_fn_t *client_added_fn;
+    ow_steer_bm_client_changed_fn_t *client_changed_fn;
+    ow_steer_bm_client_removed_fn_t *client_removed_fn;
+
+    struct ds_dlist_node node;
+};
+
+#define OW_STEER_BM_ATTR_DECL(type, name)   \
+    struct {                                \
+        bool valid;                         \
+        type *next;                         \
+        type *cur;                          \
+    } name;
+
+struct ow_steer_bm_bss;
+
+struct ow_steer_bm_group {
+    char *id;
+    bool removed;
+
+    struct {
+        bool valid;
+        struct ow_steer_policy_bss_filter_config *cur;
+    } bss_filter_policy_config;
+
+    struct ds_tree vif_tree;
+    struct ds_tree sta_tree;
+    struct ds_dlist bss_list;
+    struct ow_steer_bm_observer observer;
+
+    struct ds_tree_node node;
+};
+
+struct ow_steer_bm_vif {
+    struct osw_ifname vif_name;
+    bool removed;
+
+    OW_STEER_BM_ATTR_DECL(const struct osw_state_vif_info, vif_info);
+
+    struct ow_steer_bm_bss *bss;
+    struct ow_steer_bm_group *group;
+    struct ds_tree_node group_node;
+
+    struct ds_tree_node node;
+};
+
+struct ow_steer_bm_neighbor {
+    struct osw_hwaddr bssid;
+    bool removed;
+
+    OW_STEER_BM_ATTR_DECL(struct osw_ifname, vif_name);
+    OW_STEER_BM_ATTR_DECL(uint8_t, channel_number);
+    OW_STEER_BM_ATTR_DECL(uint8_t, op_class);
+    OW_STEER_BM_ATTR_DECL(struct osw_channel, channel);
+    OW_STEER_BM_ATTR_DECL(struct ow_steer_bm_vif, vif);
+
+    struct ow_steer_bm_bss *bss;
+    struct ow_steer_bm_observer observer;
+
+    struct ds_tree_node node;
+};
+
+struct ow_steer_bm_client {
+    struct osw_hwaddr addr;
+    bool removed;
+
+    OW_STEER_BM_ATTR_DECL(unsigned int, lwm);
+    OW_STEER_BM_ATTR_DECL(unsigned int, hwm);
+    OW_STEER_BM_ATTR_DECL(enum ow_steer_bm_client_pref_5g, pref_5g);
+    OW_STEER_BM_ATTR_DECL(enum ow_steer_bm_client_kick_type, kick_type);
+    OW_STEER_BM_ATTR_DECL(bool, kick_upon_idle);
+    struct ow_steer_bm_btm_params *sc_btm_params;
+
+    struct ds_tree sta_tree;
+
+    struct ds_tree_node node;
+};
+
+struct ow_steer_bm_sta {
+    struct osw_hwaddr addr;
+    bool removed;
+
+    struct ow_steer_policy_pre_assoc_counter_config *pre_assoc_cnt_2g_policy_config;
+
+    struct ow_steer_bm_client *client;
+    struct ds_tree_node client_node;
+    struct ow_steer_bm_group *group;
+    struct ds_tree_node group_node;
+
+    struct ds_dlist_node node;
+};
+
+struct ow_steer_bm_bss {
+    struct osw_hwaddr bssid;
+    bool removed;
+
+    struct ow_steer_bm_neighbor *neighbor;
+    struct ow_steer_bm_vif *vif;
+
+    struct osw_bss_entry *bss_entry;
+    struct ow_steer_bm_group *group;
+    struct ds_dlist_node group_node;
+
+    struct ds_dlist_node node;
+};
+
+struct ow_steer_bm_btm_params {
+    OW_STEER_BM_ATTR_DECL(uint8_t, abridged);
+    OW_STEER_BM_ATTR_DECL(uint8_t, bss_term);
+    OW_STEER_BM_ATTR_DECL(uint8_t, btm_max_retries);
+    OW_STEER_BM_ATTR_DECL(uint8_t, btm_retry_interval);
+    OW_STEER_BM_ATTR_DECL(uint8_t, disassoc_imminent);
+    OW_STEER_BM_ATTR_DECL(bool, inc_neigh);
+    OW_STEER_BM_ATTR_DECL(uint8_t, pref);
+    OW_STEER_BM_ATTR_DECL(uint8_t, valid_interval);
+    OW_STEER_BM_ATTR_DECL(bool, inc_self);
+    OW_STEER_BM_ATTR_DECL(struct osw_hwaddr, bssid);
+    OW_STEER_BM_ATTR_DECL(uint32_t, bssid_info);
+    OW_STEER_BM_ATTR_DECL(uint8_t, phy_type);
+    OW_STEER_BM_ATTR_DECL(uint8_t, channel);
+    OW_STEER_BM_ATTR_DECL(uint8_t, op_class);
+};
+
+struct ow_steer_bm_attr_state {
+    bool changed;
+    bool present;
+};
+
+static void
+ow_steer_bm_state_obs_vif_added_cb(struct osw_state_observer *self,
+                                   const struct osw_state_vif_info *vif_info);
+
+static void
+ow_steer_bm_state_obs_vif_changed_cb(struct osw_state_observer *self,
+                                     const struct osw_state_vif_info *vif_info);
+
+static void
+ow_steer_bm_state_obs_vif_removed_cb(struct osw_state_observer *self,
+                                     const struct osw_state_vif_info *vif_info);
+
+static void
+ow_steer_bm_observer_register(struct ow_steer_bm_observer *observer);
+
+static void
+ow_steer_bm_observer_unregister(struct ow_steer_bm_observer *observer);
+
+static struct osw_bss_provider *g_bss_provider = NULL;
+static struct ds_dlist g_observer_list = DS_DLIST_INIT(struct ow_steer_bm_observer, node);
+static struct ds_tree g_vif_tree = DS_TREE_INIT((ds_key_cmp_t*) osw_ifname_cmp, struct ow_steer_bm_vif, node);
+static struct ds_tree g_group_tree = DS_TREE_INIT(ds_str_cmp, struct ow_steer_bm_group, node);
+static struct ds_tree g_neighbor_tree = DS_TREE_INIT((ds_key_cmp_t*) osw_hwaddr_cmp, struct ow_steer_bm_neighbor, node);
+static struct ds_tree g_client_tree = DS_TREE_INIT((ds_key_cmp_t*) osw_hwaddr_cmp, struct ow_steer_bm_client, node);
+static struct ds_dlist g_sta_list = DS_DLIST_INIT(struct ow_steer_bm_sta, node);
+static struct ds_dlist g_bss_list = DS_DLIST_INIT(struct ow_steer_bm_bss, node);
+static struct osw_state_observer g_state_observer = {
+    .name = "ow_steer_bm",
+    .vif_added_fn = ow_steer_bm_state_obs_vif_added_cb,
+    .vif_changed_fn = ow_steer_bm_state_obs_vif_changed_cb,
+    .vif_removed_fn = ow_steer_bm_state_obs_vif_removed_cb,
+};
+static struct osw_timer g_work_timer;
+
+static bool
+ow_steer_bm_vif_is_ready(const struct ow_steer_bm_vif *vif);
+
+static bool
+ow_steer_bm_vif_is_up(const struct ow_steer_bm_vif *vif);
+
+static bool
+ow_steer_bm_neighbor_is_ready(const struct ow_steer_bm_neighbor *neighbor);
+
+static bool
+ow_steer_bm_neighbor_is_up(const struct ow_steer_bm_neighbor *neighbor);
+
+static void
+ow_steer_bm_group_invalidate_bss_filter_policy_config(struct ow_steer_bm_group *group);
+
+#define OW_STEER_BM_MEM_ATTR_FREE(object, attr) \
+    FREE(object->attr.next);                    \
+    FREE(object->attr.cur);                     \
+    object->attr.next = NULL;                   \
+    object->attr.cur = NULL;
+
+#define OW_STEER_BM_MEM_ATTR_SET_BODY(object, attr)                 \
+    ASSERT(object != NULL, "");                                     \
+    if (ow_steer_bm_mem_attr_cmp(object->attr.next, attr) == true)  \
+        return;                                                     \
+                                                                    \
+    object->attr.valid = false;                                     \
+    FREE(object->attr.next);                                        \
+    if (attr != NULL)                                               \
+        object->attr.next = MEMNDUP(attr, sizeof(attr));            \
+                                                                    \
+    ow_steer_bm_schedule_work();
+
+#define OW_STEER_BM_MEM_ATTR_UNSET_BODY(object, attr)   \
+    ASSERT(object != NULL, "");                         \
+    if (object->attr.next == NULL)                      \
+        return;                                         \
+                                                        \
+    object->attr.valid = false;                         \
+    FREE(object->attr.next);                            \
+    object->attr.next = NULL;                           \
+                                                        \
+    ow_steer_bm_schedule_work();
+
+#define OW_STEER_BM_MEM_ATTR_UPDATE(object, attr_name)                  \
+    struct ow_steer_bm_attr_state attr_name ## _state;                  \
+    ow_steer_bm_update_mem_attr_impl((void **) &object->attr_name.cur,  \
+                                     (void **) &object->attr_name.next, \
+                                     &object->attr_name.valid,          \
+                                     &attr_name ## _state,              \
+                                     sizeof(*object->attr_name.cur))
+
+#define OW_STEER_BM_PTR_ATTR_UPDATE(object, attr_name)                          \
+    struct ow_steer_bm_attr_state attr_name ## _state;                          \
+    ow_steer_bm_update_ptr_attr_impl((const void **) &object->attr_name.cur,    \
+                                     (const void **) &object->attr_name.next,   \
+                                     &object->attr_name.valid,                  \
+                                     &attr_name ## _state,                      \
+                                     sizeof(*object->attr_name.cur))
+
+#define ow_steer_bm_mem_attr_cmp(a, b) ow_steer_bm_mem_attr_cmp_impl(a, b, sizeof(*a))
+
+static bool
+ow_steer_bm_mem_attr_cmp_impl(const void *a,
+                              const void *b,
+                              size_t size)
+{
+    if (a != NULL && b != NULL)
+        return memcmp(a, b, size) == 0;
+    else if (a != b)
+        return false;
+    else
+        return true;
+}
+
+static void
+ow_steer_bm_update_mem_attr_impl(void **cur,
+                                 void **next,
+                                 bool *valid,
+                                 struct ow_steer_bm_attr_state *state,
+                                 size_t size)
+{
+    ASSERT(cur != NULL, "");
+    ASSERT(next != NULL, "");
+    ASSERT(valid != NULL, "");
+    ASSERT(state != NULL, "");
+
+    memset(state, 0, sizeof(*state));
+
+    if (*valid == true)
+        goto end;
+
+    *valid = true;
+
+    state->changed = ow_steer_bm_mem_attr_cmp_impl(*cur, *next, size) == false;
+    if (state->changed == false)
+        goto end;
+
+    FREE(*cur);
+    *cur = NULL;
+
+    if (*next == NULL)
+        goto end;
+
+    *cur = MEMNDUP(*next, size);
+
+end:
+    state->present = *cur != NULL;
+}
+
+static void
+ow_steer_bm_update_ptr_attr_impl(const void **cur,
+                                 const void **next,
+                                 bool *valid,
+                                 struct ow_steer_bm_attr_state *state,
+                                 size_t size)
+{
+    ASSERT(cur != NULL, "");
+    ASSERT(next != NULL, "");
+    ASSERT(valid != NULL, "");
+    ASSERT(state != NULL, "");
+
+    memset(state, 0, sizeof(*state));
+
+    if (*valid == true)
+        goto end;
+
+    *valid = true;
+    state->changed = *cur != *next;
+
+    *cur = *next;
+
+end:
+    state->present = *cur != NULL;
+}
+
+static void
+ow_steer_bm_schedule_work(void)
+{
+    osw_timer_arm_at_nsec(&g_work_timer, 0);
+}
+
+static void
+ow_steer_bm_btm_params_free(struct ow_steer_bm_btm_params *btm_params)
+{
+    ASSERT(btm_params != NULL, "");
+
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, abridged);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, bss_term);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, btm_max_retries);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, btm_retry_interval);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, disassoc_imminent);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, inc_neigh);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, pref);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, valid_interval);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, inc_self);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, bssid);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, bssid_info);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, phy_type);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, channel);
+    OW_STEER_BM_MEM_ATTR_FREE(btm_params, op_class);
+    FREE(btm_params);
+}
+
+static void
+ow_steer_bm_bss_update_channel(struct ow_steer_bm_bss *bss,
+                               const struct osw_channel *channel)
+{
+    ASSERT(bss != NULL, "");
+    ASSERT(channel != NULL, "");
+    osw_bss_entry_set_channel(bss->bss_entry, channel);
+}
+
+static void
+ow_steer_bm_bss_unset(struct ow_steer_bm_bss *bss)
+{
+    ASSERT(bss != NULL, "");
+
+    if (bss->removed == true)
+        return;
+
+    bss->removed = true;
+    ow_steer_bm_schedule_work();
+}
+
+static void
+ow_steer_bm_get_bss(struct ow_steer_bm_vif *vif,
+                    struct ow_steer_bm_neighbor *neighbor)
+{
+    ASSERT((neighbor != NULL) != (vif != NULL), ""); /* XOR */
+
+    struct ow_steer_bm_bss *bss = CALLOC(1, sizeof(*bss));
+
+    if (vif != NULL) {
+        if (ow_steer_bm_vif_is_up(vif) == true) {
+            vif->bss->removed = false;
+            return;
+        }
+
+        ASSERT(ow_steer_bm_vif_is_ready(vif) == true, "");
+        memcpy(&bss->bssid, &vif->vif_info.cur->drv_state->mac_addr, sizeof(bss->bssid));
+        bss->vif = vif;
+        bss->bss_entry = osw_bss_map_entry_new(g_bss_provider, &bss->bssid);
+        osw_bss_entry_set_channel(bss->bss_entry, &vif->vif_info.cur->drv_state->u.ap.channel);
+        bss->group = vif->group;
+        ds_dlist_insert_tail(&vif->group->bss_list, bss);
+
+        vif->bss = bss;
+
+        LOGD("ow: steer: bm: bss vif bssid: "OSW_HWADDR_FMT" vif_name: %s added group id: %s",
+             OSW_HWADDR_ARG(&bss->bssid), vif->vif_name.buf, vif->group->id);
+
+        ow_steer_bm_group_invalidate_bss_filter_policy_config(vif->group);
+
+        struct ow_steer_bm_observer *observer;
+        ds_dlist_foreach(&g_observer_list, observer)
+            if (observer->vif_up_fn != NULL)
+                observer->vif_up_fn(observer, vif);
+    }
+
+    if (neighbor != NULL) {
+        if (ow_steer_bm_neighbor_is_up(neighbor) == true) {
+            neighbor->bss->removed = false;
+            return;
+        }
+
+        ASSERT(ow_steer_bm_neighbor_is_ready(neighbor) == true, "");
+        memcpy(&bss->bssid, &neighbor->bssid, sizeof(bss->bssid));
+        bss->neighbor = neighbor;
+        bss->bss_entry = osw_bss_map_entry_new(g_bss_provider, &bss->bssid);
+        osw_bss_entry_set_channel(bss->bss_entry, bss->neighbor->channel.cur);
+        bss->group = neighbor->vif.cur->group;
+        ds_dlist_insert_tail(&bss->group->bss_list, bss);
+
+        neighbor->bss = bss;
+
+        LOGD("ow: steer: bm: bss neighbor bssid: "OSW_HWADDR_FMT" added to group id: %s",
+             OSW_HWADDR_ARG(&bss->bssid), bss->group->id);
+
+        ow_steer_bm_group_invalidate_bss_filter_policy_config(bss->group);
+
+        struct ow_steer_bm_observer *observer;
+        ds_dlist_foreach(&g_observer_list, observer)
+            if (observer->neighbor_up_fn != NULL)
+                observer->neighbor_up_fn(observer, neighbor);
+    }
+
+    ds_dlist_insert_tail(&g_bss_list, bss);
+
+    ow_steer_bm_schedule_work();
+}
+
+static void
+ow_steer_bm_bss_free(struct ow_steer_bm_bss *bss)
+{
+    ASSERT(bss != NULL, "");
+
+    ASSERT((bss->neighbor != NULL) != (bss->vif != NULL), ""); /* XOR */
+    if (bss->neighbor != NULL) {
+        LOGD("ow: steer: bm: bss bssid: "OSW_HWADDR_FMT" removed from neighbor",
+             OSW_HWADDR_ARG(&bss->neighbor->bssid));
+
+        struct ow_steer_bm_observer *observer;
+        ds_dlist_foreach(&g_observer_list, observer)
+            if (observer->neighbor_down_fn != NULL)
+                observer->neighbor_down_fn(observer, bss->neighbor);
+
+        bss->neighbor->bss = NULL;
+    }
+
+    if (bss->vif != NULL) {
+        LOGD("ow: steer: bm: bss bssid: "OSW_HWADDR_FMT" removed from vif vif_name: %s",
+             OSW_HWADDR_ARG(&bss->bssid), bss->vif->vif_name.buf);
+
+        struct ow_steer_bm_observer *observer;
+        ds_dlist_foreach(&g_observer_list, observer)
+            if (observer->vif_down_fn != NULL)
+                observer->vif_down_fn(observer, bss->vif);
+
+        bss->vif->bss = NULL;
+    }
+    ASSERT(bss->bss_entry != NULL, "");
+    osw_bss_map_entry_free(g_bss_provider, bss->bss_entry);
+    ASSERT(bss->group != NULL, "");
+    ds_dlist_remove(&bss->group->bss_list, bss);
+    ow_steer_bm_group_invalidate_bss_filter_policy_config(bss->group);
+    FREE(bss);
+
+    ow_steer_bm_schedule_work();
+}
+
+static void
+ow_steer_bm_sta_create(struct ow_steer_bm_group *group,
+                       struct ow_steer_bm_client *client)
+{
+    ASSERT(group != NULL, "");
+    ASSERT(client != NULL, "");
+
+    struct ow_steer_bm_sta *sta = CALLOC(1, sizeof(*sta));
+    memcpy(&sta->addr, &client->addr, sizeof(sta->addr));
+    ASSERT(ds_tree_find(&client->sta_tree, &sta->addr) == false, "");
+    sta->client = client;
+    ds_tree_insert(&client->sta_tree, sta, &sta->addr);
+    ASSERT(ds_tree_find(&group->sta_tree, &sta->addr) == false, "");
+    sta->group = group;
+    ds_tree_insert(&group->sta_tree, sta, &sta->addr);
+
+    ds_dlist_insert_tail(&g_sta_list, sta);
+
+    LOGD("ow: steer: bm: sta addr: "OSW_HWADDR_FMT" added to group id: %s",
+         OSW_HWADDR_ARG(&client->addr), group->id);
+
+    ow_steer_bm_schedule_work();
+}
+
+static void
+ow_steer_bm_sta_free(struct ow_steer_bm_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    FREE(sta->pre_assoc_cnt_2g_policy_config);
+
+    ASSERT(sta->client != NULL, "");
+    ds_tree_remove(&sta->client->sta_tree, sta);
+    ASSERT(sta->group != NULL, "");
+    ds_tree_remove(&sta->group->sta_tree, sta);
+    FREE(sta);
+}
+
+static void
+ow_steer_bm_vif_set_vif_info(struct ow_steer_bm_vif *vif,
+                             const struct osw_state_vif_info *vif_info)
+{
+    ASSERT(vif != NULL, "");
+
+    if (vif->vif_info.next == vif_info)
+        return;
+
+    vif->vif_info.valid = false;
+    vif->vif_info.next = vif_info;
+
+    ow_steer_bm_schedule_work();
+}
+
+static bool
+ow_steer_bm_vif_is_ready(const struct ow_steer_bm_vif *vif)
+{
+    ASSERT(vif != NULL, "");
+    return vif->vif_info.cur != NULL;
+}
+
+static bool
+ow_steer_bm_vif_is_up(const struct ow_steer_bm_vif *vif)
+{
+    ASSERT(vif != NULL, "");
+    return vif->bss != NULL;
+}
+
+static void
+ow_steer_bm_vif_free(struct ow_steer_bm_vif *vif)
+{
+    ASSERT(vif != NULL, "");
+
+    LOGD("ow: steer: bm: vif vif_name: %s removed from group id: %s", vif->vif_name.buf, vif->group->id);
+
+    struct ow_steer_bm_observer *observer;
+    ds_dlist_foreach(&g_observer_list, observer)
+        if (observer->vif_removed_fn != NULL)
+            observer->vif_removed_fn(observer, vif);
+
+    ASSERT(vif->bss == NULL, "");
+    ASSERT(vif->group != NULL, "");
+    ds_tree_remove(&vif->group->vif_tree, vif);
+    FREE(vif);
+}
+
+static void
+ow_steer_bm_vif_recalc(struct ow_steer_bm_vif *vif)
+{
+    ASSERT(vif != NULL, "");
+
+    OW_STEER_BM_PTR_ATTR_UPDATE(vif, vif_info);
+
+    const bool create_bss = ow_steer_bm_vif_is_up(vif) == false &&
+                            vif_info_state.present == true;
+    if (create_bss == true)
+        ow_steer_bm_get_bss(vif, NULL);
+
+    const bool update_bss = ow_steer_bm_vif_is_up(vif) == true &&
+                            vif_info_state.changed == true &&
+                            vif_info_state.present == true;
+    if (update_bss == true)
+        ow_steer_bm_bss_update_channel(vif->bss, &vif->vif_info.cur->drv_state->u.ap.channel);
+}
+
+static bool
+ow_steer_bm_neighbor_is_ready(const struct ow_steer_bm_neighbor *neighbor)
+{
+    ASSERT(neighbor != NULL, "");
+
+    const bool vif_name_ready = neighbor->vif_name.valid && neighbor->vif_name.cur != NULL;
+    const bool channel_ready = neighbor->channel.valid && neighbor->channel.cur != NULL;
+    const bool vif_present = neighbor->vif.cur != NULL;
+
+    return vif_name_ready &&
+           channel_ready &&
+           vif_present;
+}
+
+static bool
+ow_steer_bm_neighbor_is_up(const struct ow_steer_bm_neighbor *neighbor)
+{
+    ASSERT(neighbor != NULL, "");
+    return neighbor->bss != NULL;
+}
+
+static void
+ow_steer_bm_neighbor_free(struct ow_steer_bm_neighbor *neighbor)
+{
+    ASSERT(neighbor != NULL, "");
+
+    LOGD("ow: steer: bm: neighbor: bssid: "OSW_HWADDR_FMT" removed", OSW_HWADDR_ARG(&neighbor->bssid));
+
+    OW_STEER_BM_MEM_ATTR_FREE(neighbor, vif_name);
+    OW_STEER_BM_MEM_ATTR_FREE(neighbor, channel_number);
+    OW_STEER_BM_MEM_ATTR_FREE(neighbor, op_class);
+    OW_STEER_BM_MEM_ATTR_FREE(neighbor, channel);
+    ASSERT(neighbor->bss == NULL, "");
+    ow_steer_bm_observer_unregister(&neighbor->observer);
+    FREE(neighbor);
+}
+
+static void
+ow_steer_bm_neighbor_set_channel(struct ow_steer_bm_neighbor *neighbor,
+                                 const struct osw_channel *channel)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(neighbor, channel);
+}
+
+static void
+ow_steer_bm_neighbor_set_vif(struct ow_steer_bm_neighbor *neighbor,
+                             struct ow_steer_bm_vif *vif)
+{
+    ASSERT(neighbor != NULL, "");
+
+    if (neighbor->vif.next == vif)
+        return;
+
+    neighbor->vif.valid = false;
+    neighbor->vif.next = vif;
+
+    ow_steer_bm_schedule_work();
+}
+
+static void
+ow_steer_bm_neighbor_recalc(struct ow_steer_bm_neighbor *neighbor)
+{
+    ASSERT(neighbor != NULL, "");
+
+    OW_STEER_BM_MEM_ATTR_UPDATE(neighbor, vif_name);
+    OW_STEER_BM_MEM_ATTR_UPDATE(neighbor, channel_number);
+    OW_STEER_BM_MEM_ATTR_UPDATE(neighbor, op_class);
+    OW_STEER_BM_MEM_ATTR_UPDATE(neighbor, channel);
+    OW_STEER_BM_PTR_ATTR_UPDATE(neighbor, vif);
+
+    const bool invalidate_vif = vif_name_state.changed == true;
+    if (invalidate_vif == true)
+        ow_steer_bm_neighbor_set_vif(neighbor, NULL);
+
+    const bool invalidate_channel = channel_number_state.changed == true ||
+                                    op_class_state.changed == true;
+    if (invalidate_channel == true)
+        ow_steer_bm_neighbor_set_channel(neighbor, NULL);
+
+    const bool invalidate_bss = ow_steer_bm_neighbor_is_up(neighbor) == true &&
+                                (vif_name_state.present == false ||
+                                 channel_number_state.present == false ||
+                                 vif_state.present == false);
+    if (invalidate_bss == true)
+        ow_steer_bm_bss_unset(neighbor->bss);
+
+    const bool lookup_vif = vif_state.present == false &&
+                            vif_name_state.changed == true &&
+                            vif_name_state.present == true;
+    if (lookup_vif == true) {
+        struct ow_steer_bm_vif *vif = ds_tree_find(&g_vif_tree, neighbor->vif_name.cur);
+        if (ow_steer_bm_vif_is_up(vif) == true)
+            ow_steer_bm_neighbor_set_vif(neighbor, vif);
+    }
+
+    const bool create_channel = channel_state.present == false &&
+                                channel_number_state.present == true &&
+                                op_class_state.present == true;
+    if (create_channel == true) {
+        struct osw_channel channel;
+        const bool result = osw_channel_from_op_class(*neighbor->op_class.cur, *neighbor->channel_number.cur, &channel);
+        if (result == true)
+            ow_steer_bm_neighbor_set_channel(neighbor, &channel);
+        else
+            LOGW("ow: steer: bm: neighbor: bssid: "OSW_HWADDR_FMT" op_class/channel: %d/%d is invalid",
+                 OSW_HWADDR_ARG(&neighbor->bssid), *neighbor->op_class.cur, *neighbor->channel_number.cur);
+    }
+
+    const bool create_bss = ow_steer_bm_neighbor_is_up(neighbor) == false &&
+                            ow_steer_bm_neighbor_is_ready(neighbor) == true &&
+                            (vif_name_state.changed == true ||
+                             channel_state.changed == true);
+    if (create_bss == true)
+        ow_steer_bm_get_bss(NULL, neighbor);
+
+    const bool update_bss_channel = ow_steer_bm_neighbor_is_up(neighbor) == true &&
+                                    ow_steer_bm_neighbor_is_ready(neighbor) == true &&
+                                    channel_state.changed == true;
+    if (update_bss_channel == true)
+        ow_steer_bm_bss_update_channel(neighbor->bss, neighbor->channel.cur);
+}
+
+static void
+ow_steer_bm_group_invalidate_bss_filter_policy_config(struct ow_steer_bm_group *group)
+{
+    ASSERT(group != NULL, "");
+    group->bss_filter_policy_config.valid = false;
+    ow_steer_bm_schedule_work();
+}
+
+static bool
+ow_steer_group_recalc_bss_filter_policy_config(struct ow_steer_bm_group *group)
+{
+    ASSERT(group != NULL, "");
+    ASSERT(group->bss_filter_policy_config.valid == false, "");
+
+    group->bss_filter_policy_config.valid = true;
+
+    struct ow_steer_policy_bss_filter_config *policy_config = ow_steer_policy_bss_filter_config_create();
+
+    struct ow_steer_bm_bss *bss;
+    ds_dlist_foreach(&group->bss_list, bss)
+        ow_steer_policy_bss_filter_config_add(policy_config, &bss->bssid);
+
+    if (group->bss_filter_policy_config.cur != NULL) {
+        if (ow_steer_policy_bss_filter_config_cmp(group->bss_filter_policy_config.cur, policy_config) == true) {
+            FREE(policy_config);
+            return false;
+        }
+    }
+
+    FREE(group->bss_filter_policy_config.cur);
+    group->bss_filter_policy_config.cur = policy_config;
+
+    return true;
+}
+
+static void
+ow_steer_bm_group_free(struct ow_steer_bm_group *group)
+{
+    ASSERT(group != NULL, "");
+
+    FREE(group->id);
+    FREE(group->bss_filter_policy_config.cur);
+    ASSERT(ds_tree_is_empty(&group->vif_tree) == true, "");
+    ASSERT(ds_tree_is_empty(&group->sta_tree) == true, "");
+    ASSERT(ds_dlist_is_empty(&group->bss_list) == true, "");
+    ow_steer_bm_observer_unregister(&group->observer);
+    FREE(group);
+}
+
+static void
+ow_steer_bm_group_recalc(struct ow_steer_bm_group *group)
+{
+    ASSERT(group != NULL, "");
+
+    bool bss_filter_policy_config_changed = false;
+    if (group->bss_filter_policy_config.valid == false)
+        bss_filter_policy_config_changed = ow_steer_group_recalc_bss_filter_policy_config(group);
+
+    if (bss_filter_policy_config_changed == false)
+        return;
+
+    struct ow_steer_bm_sta *sta;
+    ds_tree_foreach(&group->sta_tree, sta)
+        /* TODO */;
+}
+
+static void
+ow_steer_bm_client_free(struct ow_steer_bm_client *client)
+{
+    ASSERT(client != NULL, "");
+
+    OW_STEER_BM_MEM_ATTR_FREE(client, lwm);
+    OW_STEER_BM_MEM_ATTR_FREE(client, hwm);
+    OW_STEER_BM_MEM_ATTR_FREE(client, pref_5g);
+    OW_STEER_BM_MEM_ATTR_FREE(client, kick_type);
+    OW_STEER_BM_MEM_ATTR_FREE(client, kick_upon_idle);
+    ow_steer_bm_btm_params_free(client->sc_btm_params);
+    ASSERT(ds_tree_is_empty(&client->sta_tree) == true, "");
+    FREE(client);
+}
+
+static void
+ow_steer_bm_client_recalc(struct ow_steer_bm_client *client)
+{
+    ASSERT(client != NULL, "");
+    /* TODO */
+}
+
+static void
+ow_steer_bm_recalc_vifs(void)
+{
+    struct ow_steer_bm_vif *vif;
+    struct ow_steer_bm_vif *tmp_vif;
+
+    ds_tree_foreach_safe(&g_vif_tree, vif, tmp_vif) {
+        if (vif->removed == true) {
+            ds_tree_remove(&g_vif_tree, vif);
+            ow_steer_bm_vif_free(vif);
+            continue;
+        }
+
+        ow_steer_bm_vif_recalc(vif);
+    }
+}
+
+static void
+ow_steer_bm_recalc_bsses(void)
+{
+    struct ow_steer_bm_bss *bss;
+    struct ow_steer_bm_bss *tmp_bss;
+
+    ds_dlist_foreach_safe(&g_bss_list, bss, tmp_bss) {
+        if (bss->removed == true) {
+            ds_dlist_remove(&g_bss_list, bss);
+            ow_steer_bm_bss_free(bss);
+        }
+    }
+}
+
+static void
+ow_steer_bm_recalc_stas(void)
+{
+    struct ow_steer_bm_sta *sta;
+    struct ow_steer_bm_sta *tmp_sta;
+
+    ds_dlist_foreach_safe(&g_sta_list, sta, tmp_sta) {
+        if (sta->removed == true) {
+            ds_dlist_remove(&g_sta_list, sta);
+            ow_steer_bm_sta_free(sta);
+        }
+    }
+}
+
+static void
+ow_steer_bm_recalc_groups(void)
+{
+    struct ow_steer_bm_group *group;
+    struct ow_steer_bm_group *tmp_group;
+
+    ds_tree_foreach_safe(&g_group_tree, group, tmp_group) {
+        const bool remove = group->removed &&
+                            ds_tree_is_empty(&group->vif_tree) == true &&
+                            ds_tree_is_empty(&group->sta_tree) == true &&
+                            ds_dlist_is_empty(&group->bss_list) == true;
+        if (remove == true) {
+            ds_tree_remove(&g_group_tree, group);
+            ow_steer_bm_group_free(group);
+            continue;
+        }
+
+        ow_steer_bm_group_recalc(group);
+    }
+}
+
+static void
+ow_steer_bm_recalc_neighbors(void)
+{
+    struct ow_steer_bm_neighbor *neighbor;
+    struct ow_steer_bm_neighbor *tmp_neighbor;
+
+    ds_tree_foreach_safe(&g_neighbor_tree, neighbor, tmp_neighbor) {
+        if (neighbor->removed == true) {
+            ds_tree_remove(&g_neighbor_tree, neighbor);
+            ow_steer_bm_neighbor_free(neighbor);
+            continue;
+        }
+
+        ow_steer_bm_neighbor_recalc(neighbor);
+    }
+}
+
+static void
+ow_steer_bm_recalc_clients(void)
+{
+    struct ow_steer_bm_client *client;
+    struct ow_steer_bm_client *tmp_client;
+
+    ds_tree_foreach_safe(&g_client_tree, client, tmp_client) {
+        if (client->removed == true) {
+            ds_tree_remove(&g_client_tree, client);
+            ow_steer_bm_client_free(client);
+            continue;
+        }
+
+        ow_steer_bm_client_recalc(client);
+    }
+}
+
+static void
+ow_steer_bm_work_timer_cb(struct osw_timer *timer)
+{
+    LOGD("ow: steer: bm: do work");
+    ow_steer_bm_recalc_bsses();
+    ow_steer_bm_recalc_stas();
+    ow_steer_bm_recalc_neighbors();
+    ow_steer_bm_recalc_vifs();
+    ow_steer_bm_recalc_clients();
+    ow_steer_bm_recalc_groups();
+}
+
+static void
+ow_steer_bm_state_obs_vif_added_cb(struct osw_state_observer *self,
+                                   const struct osw_state_vif_info *vif_info)
+{
+    ASSERT(vif_info != NULL, "");
+
+    if (WARN_ON(vif_info->vif_name == NULL))
+        return;
+    if (vif_info->drv_state == NULL)
+        return;
+    if (vif_info->drv_state->vif_type != OSW_VIF_AP)
+        return;
+
+    struct osw_ifname vif_name;
+    STRSCPY(vif_name.buf, vif_info->vif_name);
+
+    LOGD("ow: steer: bm: vif: %s appeared", vif_name.buf);
+
+    struct ow_steer_bm_vif *vif = ds_tree_find(&g_vif_tree, &vif_name);
+    if (vif != NULL)
+        ow_steer_bm_vif_set_vif_info(vif, vif_info);
+}
+
+static void
+ow_steer_bm_state_obs_vif_changed_cb(struct osw_state_observer *self,
+                                     const struct osw_state_vif_info *vif_info)
+{
+    ASSERT(vif_info != NULL, "");
+
+    if (WARN_ON(vif_info->vif_name == NULL))
+        return;
+    if (vif_info->drv_state == NULL)
+        return;
+    if (vif_info->drv_state->vif_type != OSW_VIF_AP)
+        return;
+
+    struct osw_ifname vif_name;
+    STRSCPY(vif_name.buf, vif_info->vif_name);
+
+    LOGD("ow: steer: bm: vif: %s changed", vif_name.buf);
+
+    struct ow_steer_bm_vif *vif = ds_tree_find(&g_vif_tree, &vif_name);
+    if (vif != NULL)
+        ow_steer_bm_vif_set_vif_info(vif, vif_info);
+}
+
+static void
+ow_steer_bm_state_obs_vif_removed_cb(struct osw_state_observer *self,
+                                     const struct osw_state_vif_info *vif_info)
+{
+    ASSERT(vif_info != NULL, "");
+
+    if (WARN_ON(vif_info->vif_name == NULL))
+        return;
+
+    struct osw_ifname vif_name;
+    STRSCPY(vif_name.buf, vif_info->vif_name);
+
+    LOGD("ow: steer: bm: vif: %s vanished", vif_name.buf);
+
+    struct ow_steer_bm_vif *vif = ds_tree_find(&g_vif_tree, &vif_name);
+    if (vif != NULL) {
+        ow_steer_bm_vif_set_vif_info(vif, NULL);
+        const bool unset_bss = ow_steer_bm_vif_is_up(vif) == true;
+        if (unset_bss == true)
+            ow_steer_bm_bss_unset(vif->bss);
+    }
+}
+
+static void
+ow_steer_bm_init(void)
+{
+    osw_state_register_observer(&g_state_observer);
+    g_bss_provider = osw_bss_map_register_provider();
+    osw_timer_init(&g_work_timer, ow_steer_bm_work_timer_cb);
+    LOGI("ow: steer: bm: initialized");
+}
+
+static void
+ow_steer_bm_observer_register(struct ow_steer_bm_observer *observer)
+{
+    ASSERT(observer != NULL, "");
+
+    if (observer->vif_added_fn != NULL) {
+        struct ow_steer_bm_vif *vif;
+        ds_tree_foreach(&g_vif_tree, vif)
+            observer->vif_added_fn(observer, vif);
+    }
+
+    if (observer->neighbor_up_fn != NULL) {
+        struct ow_steer_bm_neighbor *neighbor;
+        ds_tree_foreach(&g_neighbor_tree, neighbor)
+            if (ow_steer_bm_neighbor_is_up(neighbor) == true)
+                observer->neighbor_up_fn(observer, neighbor);
+    }
+
+    if (observer->client_added_fn != NULL) {
+        struct ow_steer_bm_client *client;
+        ds_tree_foreach(&g_client_tree, client)
+            observer->client_added_fn(observer, client);
+    }
+
+    ds_dlist_insert_tail(&g_observer_list, observer);
+}
+
+static void
+ow_steer_bm_observer_unregister(struct ow_steer_bm_observer *observer)
+{
+    ASSERT(observer != NULL, "");
+    ds_dlist_remove(&g_observer_list, observer);
+}
+
+static void
+ow_steer_bm_neighbor_vif_added_cb(struct ow_steer_bm_observer *observer,
+                                  struct ow_steer_bm_vif *vif)
+{
+    struct ow_steer_bm_neighbor *neighbor = container_of(observer, struct ow_steer_bm_neighbor, observer);
+    const bool set_vif = neighbor->vif_name.cur != NULL &&
+                         osw_ifname_cmp(neighbor->vif_name.cur, &vif->vif_name) == 0;
+    if (set_vif == true)
+        ow_steer_bm_neighbor_set_vif(neighbor, vif);
+}
+
+static void
+ow_steer_bm_neighbor_vif_removed_cb(struct ow_steer_bm_observer *observer,
+                                    struct ow_steer_bm_vif *vif)
+{
+    struct ow_steer_bm_neighbor *neighbor = container_of(observer, struct ow_steer_bm_neighbor, observer);
+    const bool unset_vif = neighbor->vif_name.cur != NULL &&
+                           osw_ifname_cmp(neighbor->vif_name.cur, &vif->vif_name) == 0;
+    if (unset_vif == true)
+        ow_steer_bm_neighbor_set_vif(neighbor, NULL);
+}
+
+static void
+ow_steer_bm_group_vif_toggled_cb(struct ow_steer_bm_observer *observer,
+                                 struct ow_steer_bm_vif *vif)
+{
+    struct ow_steer_bm_group *self = container_of(observer, struct ow_steer_bm_group, observer);
+    if (self == vif->group)
+        ow_steer_bm_group_invalidate_bss_filter_policy_config(self);
+}
+
+static void
+ow_steer_bm_group_neighbor_toggled_cb(struct ow_steer_bm_observer *observer,
+                                      struct ow_steer_bm_neighbor *neighbor)
+{
+    struct ow_steer_bm_group *self = container_of(observer, struct ow_steer_bm_group, observer);
+    if (self == neighbor->bss->group)
+        ow_steer_bm_group_invalidate_bss_filter_policy_config(self);
+}
+
+static void
+ow_steer_bm_group_client_added_cb(struct ow_steer_bm_observer *observer,
+                                  struct ow_steer_bm_client *client)
+{
+    struct ow_steer_bm_group *group = container_of(observer, struct ow_steer_bm_group, observer);
+    ow_steer_bm_sta_create(group, client);
+}
+
+struct ow_steer_bm_group*
+ow_steer_bm_get_group(const char *id)
+{
+    ASSERT(id != NULL, "");
+
+    struct ow_steer_bm_group *group = ds_tree_find(&g_group_tree, id);
+    if (group != NULL) {
+        group->removed = false;
+        return group;
+    }
+
+    group = CALLOC(1, sizeof(*group));
+    group->id = STRDUP(id);
+    ds_tree_init(&group->vif_tree, (ds_key_cmp_t*) osw_ifname_cmp, struct ow_steer_bm_vif, group_node);
+    ds_tree_init(&group->sta_tree, (ds_key_cmp_t*) osw_hwaddr_cmp, struct ow_steer_bm_sta, group_node);
+    ds_dlist_init(&group->bss_list, struct ow_steer_bm_bss, group_node);
+    group->observer.vif_up_fn = ow_steer_bm_group_vif_toggled_cb;
+    group->observer.vif_down_fn = ow_steer_bm_group_vif_toggled_cb;
+    group->observer.neighbor_up_fn = ow_steer_bm_group_neighbor_toggled_cb;
+    group->observer.neighbor_down_fn = ow_steer_bm_group_neighbor_toggled_cb;
+    group->observer.client_added_fn = ow_steer_bm_group_client_added_cb;
+    ds_tree_insert(&g_group_tree, group, group->id);
+
+    LOGD("ow: steer: bm: group id: %s added", group->id);
+
+    ow_steer_bm_observer_register(&group->observer);
+    ow_steer_bm_schedule_work();
+
+    return group;
+}
+
+void
+ow_steer_bm_group_unset(struct ow_steer_bm_group *group)
+{
+    ASSERT(group != NULL, "");
+
+    if (group->removed == true)
+        return;
+
+    group->removed = true;
+
+    struct ow_steer_bm_vif *vif;
+    ds_tree_foreach(&group->vif_tree, vif)
+        ow_steer_bm_vif_unset(vif);
+
+    ow_steer_bm_schedule_work();
+}
+
+void
+ow_steer_bm_group_reset(struct ow_steer_bm_group *group)
+{
+    ASSERT(group != NULL, "");
+    LOGN("ow: steer: bm: group: TODO %s", __FUNCTION__);
+}
+
+struct ow_steer_bm_vif*
+ow_steer_bm_group_get_vif(struct ow_steer_bm_group *group,
+                          const char *vif_name)
+{
+    ASSERT(group != NULL, "");
+    ASSERT(vif_name != NULL, "");
+
+    struct osw_ifname tmp_vif_name;
+    STRSCPY(tmp_vif_name.buf, vif_name);
+
+    struct ow_steer_bm_vif *vif = ds_tree_find(&g_vif_tree, &tmp_vif_name);
+    if (vif != NULL) {
+        ASSERT(vif->group == group, "");
+        vif->removed = false;
+        return vif;
+    }
+
+    vif = CALLOC(1, sizeof(*vif));
+    memcpy(&vif->vif_name, &tmp_vif_name, sizeof(vif->vif_name));
+    vif->group = group;
+    ds_tree_insert(&group->vif_tree, vif, &vif->vif_name);
+    ds_tree_insert(&g_vif_tree, vif, &vif->vif_name);
+
+    LOGD("ow: steer: bm: vif vif_name: %s added in group id: %s", vif->vif_name.buf, vif->group->id);
+
+    struct ow_steer_bm_observer *observer;
+    ds_dlist_foreach(&g_observer_list, observer)
+        if (observer->vif_added_fn != NULL)
+            observer->vif_added_fn(observer, vif);
+
+    ow_steer_bm_schedule_work();
+
+    return vif;
+}
+
+void
+ow_steer_bm_vif_unset(struct ow_steer_bm_vif *vif)
+{
+    ASSERT(vif != NULL, "");
+
+    if (vif->removed == true)
+        return;
+
+    vif->removed = true;
+    if (vif->bss != NULL)
+        ow_steer_bm_bss_unset(vif->bss);
+
+    ow_steer_bm_schedule_work();
+}
+
+void
+ow_steer_bm_vif_reset(struct ow_steer_bm_vif *vif)
+{
+    ASSERT(vif != NULL, "");
+    LOGN("ow: steer: bm: vif: TODO %s", __FUNCTION__);
+}
+
+struct ow_steer_bm_neighbor*
+ow_steer_bm_get_neighbor(const uint8_t *bssid)
+{
+    ASSERT(bssid != NULL, "");
+
+    struct osw_hwaddr tmp_bssid;
+    memcpy(&tmp_bssid.octet, bssid, sizeof(tmp_bssid.octet));
+
+    struct ow_steer_bm_neighbor *neighbor = ds_tree_find(&g_neighbor_tree, &tmp_bssid);
+    if (neighbor != NULL) {
+        neighbor->removed = false;
+        return neighbor;
+    }
+
+    neighbor = CALLOC(1, sizeof(*neighbor));
+    memcpy(&neighbor->bssid, &tmp_bssid, sizeof(neighbor->bssid));
+    neighbor->observer.vif_added_fn = ow_steer_bm_neighbor_vif_added_cb;
+    neighbor->observer.vif_removed_fn = ow_steer_bm_neighbor_vif_removed_cb;
+    ds_tree_insert(&g_neighbor_tree, neighbor, &neighbor->bssid);
+
+    LOGD("ow: steer: bm: neighbor bssid: "OSW_HWADDR_FMT" added", OSW_HWADDR_ARG(&neighbor->bssid));
+
+    ow_steer_bm_observer_register(&neighbor->observer);
+    ow_steer_bm_schedule_work();
+
+    return neighbor;
+}
+
+void
+ow_steer_bm_neighbor_unset(struct ow_steer_bm_neighbor *neighbor)
+{
+    ASSERT(neighbor != NULL, "");
+
+    if (neighbor->removed == true)
+        return;
+
+    neighbor->removed = true;
+    if (neighbor->bss != NULL)
+        ow_steer_bm_bss_unset(neighbor->bss);
+
+    ow_steer_bm_schedule_work();
+}
+
+void
+ow_steer_bm_neighbor_set(struct ow_steer_bm_neighbor *neighbor)
+{
+    ASSERT(neighbor != NULL, "");
+    LOGN("ow: steer: bm: neighbor: TODO %s", __FUNCTION__);
+}
+
+void
+ow_steer_bm_neighbor_set_vif_name(struct ow_steer_bm_neighbor *neighbor,
+                                  const char *vif_name)
+{
+    ASSERT(neighbor != NULL, "");
+
+    struct osw_ifname tmp_vif_name;
+    memset(&tmp_vif_name, 0, sizeof(tmp_vif_name));
+    STRSCPY(tmp_vif_name.buf, vif_name);
+
+    if (ow_steer_bm_mem_attr_cmp(neighbor->vif_name.next, &tmp_vif_name) == true)
+        return;
+
+    neighbor->vif_name.valid = false;
+    FREE(neighbor->vif_name.next);
+    neighbor->vif_name.next = NULL;
+    if (vif_name != NULL) {
+        neighbor->vif_name.next = CALLOC(1, sizeof(*neighbor->vif_name.next));
+        STRSCPY(neighbor->vif_name.next->buf, vif_name);
+    }
+
+    ow_steer_bm_schedule_work();
+}
+
+void
+ow_steer_bm_neighbor_set_channel_number(struct ow_steer_bm_neighbor *neighbor,
+                                        const uint8_t *channel_number)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(neighbor, channel_number);
+}
+
+void
+ow_steer_bm_neighbor_set_op_class(struct ow_steer_bm_neighbor *neighbor,
+                                  const uint8_t *op_class)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(neighbor, op_class);
+}
+
+struct ow_steer_bm_client*
+ow_steer_bm_get_client(const uint8_t *addr)
+{
+    ASSERT(addr != NULL, "");
+
+    struct osw_hwaddr tmp_addr;
+    memcpy(&tmp_addr.octet, addr, sizeof(tmp_addr.octet));
+
+    struct ow_steer_bm_client *client = ds_tree_find(&g_client_tree, &tmp_addr);
+    if (client != NULL) {
+        client->removed = false;
+        return client;
+    }
+
+    client = CALLOC(1, sizeof(*client));
+    memcpy(&client->addr, &tmp_addr, sizeof(client->addr));
+    ds_tree_init(&client->sta_tree, (ds_key_cmp_t*) osw_hwaddr_cmp, struct ow_steer_bm_sta, client_node);
+    ds_tree_insert(&g_client_tree, client, &client->addr);
+
+    LOGD("ow: steer: bm: client addr: "OSW_HWADDR_FMT" added", OSW_HWADDR_ARG(&client->addr));
+
+    ow_steer_bm_schedule_work();
+
+    struct ow_steer_bm_observer *observer;
+    ds_dlist_foreach(&g_observer_list, observer)
+        if (observer->client_added_fn != NULL)
+            observer->client_added_fn(observer, client);
+
+    return client;
+}
+
+void
+ow_steer_bm_client_unset(struct ow_steer_bm_client *client)
+{
+    ASSERT(client != NULL, "");
+    LOGN("ow: steer: bm: client: TODO %s", __FUNCTION__);
+}
+
+void
+ow_steer_bm_client_reset(struct ow_steer_bm_client *client)
+{
+    ASSERT(client != NULL, "");
+    LOGN("ow: steer: bm: client: TODO %s", __FUNCTION__);
+}
+
+void
+ow_steer_bm_client_set_hwm(struct ow_steer_bm_client *client,
+                           const unsigned int *hwm)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(client, hwm);
+}
+
+void
+ow_steer_bm_client_set_lwm(struct ow_steer_bm_client *client,
+                           const unsigned int *lwm)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(client, lwm);
+}
+
+void
+ow_steer_bm_client_set_pref_5g(struct ow_steer_bm_client *client,
+                               const enum ow_steer_bm_client_pref_5g *pref_5g)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(client, pref_5g);
+}
+
+void
+ow_steer_bm_client_set_kick_type(struct ow_steer_bm_client *client,
+                                  const enum ow_steer_bm_client_kick_type *kick_type)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(client, kick_type);
+}
+
+void
+ow_steer_bm_client_set_kick_upon_idle(struct ow_steer_bm_client *client,
+                                      const bool *kick_upon_idle)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(client, kick_upon_idle);
+}
+
+struct ow_steer_bm_btm_params*
+ow_steer_bm_client_get_sc_btm_params(struct ow_steer_bm_client *client)
+{
+    ASSERT(client != NULL, "");
+
+    if (client->sc_btm_params != NULL)
+        goto end;
+
+    client->sc_btm_params = CALLOC(1, sizeof(*client->sc_btm_params));
+    ow_steer_bm_schedule_work();
+
+end:
+    return client->sc_btm_params;
+}
+
+void
+ow_steer_bm_client_unset_sc_btm_params(struct ow_steer_bm_client *client)
+{
+    ASSERT(client != NULL, "");
+
+    ow_steer_bm_btm_params_free(client->sc_btm_params);
+    client->sc_btm_params = NULL;
+    ow_steer_bm_schedule_work();
+}
+
+void
+ow_steer_bm_btm_params_reset(struct ow_steer_bm_btm_params *btm_params)
+{
+    ASSERT(btm_params != NULL, "");
+    LOGN("ow: steer: bm: btm_params: TODO %s", __FUNCTION__);
+}
+
+void
+ow_steer_bm_btm_params_abridged(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *abridged)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, abridged);
+}
+
+void
+ow_steer_bm_btm_params_bss_term(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *bss_term)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, bss_term);
+}
+
+void
+ow_steer_bm_btm_params_btm_max_retries(struct ow_steer_bm_btm_params *btm_params,
+                                       const uint8_t *btm_max_retries)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, btm_max_retries);
+}
+
+void
+ow_steer_bm_btm_params_btm_retry_interval(struct ow_steer_bm_btm_params *btm_params,
+                                          const uint8_t *btm_retry_interval)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, btm_retry_interval);
+}
+
+void
+ow_steer_bm_btm_params_disassoc_imminent(struct ow_steer_bm_btm_params *btm_params,
+                                         const uint8_t *disassoc_imminent)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, disassoc_imminent);
+}
+
+void
+ow_steer_bm_btm_params_inc_neigh(struct ow_steer_bm_btm_params *btm_params,
+                                 const bool *inc_neigh)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, inc_neigh);
+}
+
+void
+ow_steer_bm_btm_params_pref(struct ow_steer_bm_btm_params *btm_params,
+                            const uint8_t *pref)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, pref);
+}
+
+void
+ow_steer_bm_btm_params_valid_interval(struct ow_steer_bm_btm_params *btm_params,
+                                      const uint8_t *valid_interval)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, valid_interval);
+}
+
+void
+ow_steer_bm_btm_params_inc_self(struct ow_steer_bm_btm_params *btm_params,
+                                const bool *inc_self)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, inc_self);
+}
+
+void
+ow_steer_bm_btm_params_bssid(struct ow_steer_bm_btm_params *btm_params,
+                             const struct osw_hwaddr *bssid)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, bssid);
+}
+
+void
+ow_steer_bm_btm_params_bssid_info(struct ow_steer_bm_btm_params *btm_params,
+                                  const uint32_t *bssid_info)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, bssid_info);
+}
+
+void
+ow_steer_bm_btm_params_phy_type(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *phy_type)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, phy_type);
+}
+
+void
+ow_steer_bm_btm_params_channel(struct ow_steer_bm_btm_params *btm_params,
+                               const uint8_t *channel)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, channel);
+}
+
+void
+ow_steer_bm_btm_params_op_class(struct ow_steer_bm_btm_params *btm_params,
+                                const uint8_t *op_class)
+{
+    OW_STEER_BM_MEM_ATTR_SET_BODY(btm_params, op_class);
+}
+
+OSW_MODULE(ow_steer_bm)
+{
+    OSW_MODULE_LOAD(osw_state);
+    OSW_MODULE_LOAD(osw_bss_map);
+    OSW_MODULE_LOAD(ow_steer);
+    ow_steer_bm_init();
+    return NULL;
+}
+
+#include "ow_steer_bm_ut.c"
Index: core/src/lib/ow/src/ow_steer_bm_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_bm_ut.c
@@ -0,0 +1,906 @@
+#include <osw_ut.h>
+
+struct ow_steer_bm_ut_mem_attr {
+    bool valid;
+    int *next;
+    int *cur;
+};
+
+struct ow_steer_bm_ut_ptr_attr {
+    bool valid;
+    const int *next;
+    const int *cur;
+};
+
+struct ow_steer_bm_ut_object {
+    struct ow_steer_bm_ut_mem_attr mem_attr;
+    struct ow_steer_bm_ut_ptr_attr ptr_attr;
+};
+
+#define OW_STEER_BM_UT_CALL_STATE_OBS(fn, ...) \
+    do { \
+        struct osw_state_observer *i; \
+        ds_dlist_foreach(&g_osw_state_observer_list, i) \
+            if (i->fn != NULL) \
+                i->fn(i, ## __VA_ARGS__); \
+    } while (0)
+
+typedef int
+ow_steer_bm_ut_cmp_fn_t(const void *,
+                        const void *);
+
+static size_t
+ow_steer_bm_ut_ds_dlist_count_all(struct ds_dlist *list,
+                                  const void *data,
+                                  ow_steer_bm_ut_cmp_fn_t *cmp_fn)
+{
+    ASSERT(list != NULL, "");
+    ASSERT(data != NULL, "");
+    ASSERT(cmp_fn != NULL, "");
+
+    void *element;
+    size_t n = 0;
+
+    for (element = ds_dlist_head(list); element != NULL; element = ds_dlist_next(list, element))
+        if (cmp_fn(element, data) == 0)
+            n++;
+
+    return n;
+}
+
+OSW_UT(ow_steer_bm_attr_helpers)
+{
+    struct ow_steer_bm_ut_object object_buf;
+    struct ow_steer_bm_ut_object *object = &object_buf;
+    memset(object, 0, sizeof(*object));
+
+    /*
+     *  Memory (dynamically allocated) attribute
+     */
+    {
+        /* Initial value */
+        OW_STEER_BM_MEM_ATTR_UPDATE(object, mem_attr);
+
+        OSW_UT_EVAL(mem_attr_state.changed == false);
+        OSW_UT_EVAL(mem_attr_state.present == false);
+        OSW_UT_EVAL(object->mem_attr.valid == true);
+        OSW_UT_EVAL(object->mem_attr.next == NULL);
+        OSW_UT_EVAL(object->mem_attr.cur == NULL);
+    }
+
+    {
+        /* Set to 5 */
+        object->mem_attr.valid = false;
+        FREE(object->mem_attr.next);
+        object->mem_attr.next = CALLOC(1, sizeof(*object->mem_attr.next));
+        *object->mem_attr.next = 5;
+
+        OW_STEER_BM_MEM_ATTR_UPDATE(object, mem_attr);
+
+        OSW_UT_EVAL(mem_attr_state.changed == true);
+        OSW_UT_EVAL(mem_attr_state.present == true);
+        OSW_UT_EVAL(object->mem_attr.valid == true);
+        OSW_UT_EVAL(object->mem_attr.next != NULL);
+        OSW_UT_EVAL(*object->mem_attr.next == 5);
+        OSW_UT_EVAL(object->mem_attr.cur != NULL);
+        OSW_UT_EVAL(*object->mem_attr.cur == 5);
+    }
+
+    {
+        /* Set to 13 */
+        object->mem_attr.valid = false;
+        FREE(object->mem_attr.next);
+        object->mem_attr.next = CALLOC(1, sizeof(*object->mem_attr.next));
+        *object->mem_attr.next = 13;
+
+        OW_STEER_BM_MEM_ATTR_UPDATE(object, mem_attr);
+
+        OSW_UT_EVAL(mem_attr_state.changed == true);
+        OSW_UT_EVAL(mem_attr_state.present == true);
+        OSW_UT_EVAL(object->mem_attr.valid == true);
+        OSW_UT_EVAL(object->mem_attr.next != NULL);
+        OSW_UT_EVAL(*object->mem_attr.next == 13);
+        OSW_UT_EVAL(object->mem_attr.cur != NULL);
+        OSW_UT_EVAL(*object->mem_attr.cur == 13);
+    }
+
+    {
+        /* Set to 13 again */
+        object->mem_attr.valid = false;
+        FREE(object->mem_attr.next);
+        object->mem_attr.next = CALLOC(1, sizeof(*object->mem_attr.next));
+        *object->mem_attr.next = 13;
+
+        OW_STEER_BM_MEM_ATTR_UPDATE(object, mem_attr);
+
+        OSW_UT_EVAL(mem_attr_state.changed == false);
+        OSW_UT_EVAL(mem_attr_state.present == true);
+        OSW_UT_EVAL(object->mem_attr.valid == true);
+        OSW_UT_EVAL(object->mem_attr.next != NULL);
+        OSW_UT_EVAL(*object->mem_attr.next == 13);
+        OSW_UT_EVAL(object->mem_attr.cur != NULL);
+        OSW_UT_EVAL(*object->mem_attr.cur == 13);
+    }
+
+    {
+        /* Set to NULL */
+        object->mem_attr.valid = false;
+        FREE(object->mem_attr.next);
+        object->mem_attr.next = NULL;
+
+        OW_STEER_BM_MEM_ATTR_UPDATE(object, mem_attr);
+
+        OSW_UT_EVAL(mem_attr_state.changed == true);
+        OSW_UT_EVAL(mem_attr_state.present == false);
+        OSW_UT_EVAL(object->mem_attr.valid == true);
+        OSW_UT_EVAL(object->mem_attr.next == NULL);
+        OSW_UT_EVAL(object->mem_attr.cur == NULL);
+    }
+
+    /*
+     *  Pointer attribute
+     */
+    {
+        /* Initial value */
+        OW_STEER_BM_PTR_ATTR_UPDATE(object, ptr_attr);
+
+        OSW_UT_EVAL(ptr_attr_state.changed == false);
+        OSW_UT_EVAL(ptr_attr_state.present == false);
+        OSW_UT_EVAL(object->ptr_attr.valid == true);
+        OSW_UT_EVAL(object->ptr_attr.next == NULL);
+        OSW_UT_EVAL(object->ptr_attr.cur == NULL);
+    }
+
+    {
+        /* Set to 0xAAAA */
+        object->ptr_attr.valid = false;
+        object->ptr_attr.next = (const int*) 0xAAAA;
+
+        OW_STEER_BM_PTR_ATTR_UPDATE(object, ptr_attr);
+
+        OSW_UT_EVAL(ptr_attr_state.changed == true);
+        OSW_UT_EVAL(ptr_attr_state.present == true);
+        OSW_UT_EVAL(object->ptr_attr.valid == true);
+        OSW_UT_EVAL(object->ptr_attr.next == (const int*) 0xAAAA);
+        OSW_UT_EVAL(object->ptr_attr.cur == (const int*) 0xAAAA);
+    }
+
+    {
+        /* Set to 0xBBBB */
+        object->ptr_attr.valid = false;
+        object->ptr_attr.next = (const int*) 0xBBBB;
+
+        OW_STEER_BM_PTR_ATTR_UPDATE(object, ptr_attr);
+
+        OSW_UT_EVAL(ptr_attr_state.changed == true);
+        OSW_UT_EVAL(ptr_attr_state.present == true);
+        OSW_UT_EVAL(object->ptr_attr.valid == true);
+        OSW_UT_EVAL(object->ptr_attr.next == (const int*) 0xBBBB);
+        OSW_UT_EVAL(object->ptr_attr.cur == (const int*) 0xBBBB);
+    }
+
+    {
+        /* Set to 0xBBBB again */
+        object->ptr_attr.valid = false;
+        object->ptr_attr.next = (const int*) 0xBBBB;
+
+        OW_STEER_BM_PTR_ATTR_UPDATE(object, ptr_attr);
+
+        OSW_UT_EVAL(ptr_attr_state.changed == false);
+        OSW_UT_EVAL(ptr_attr_state.present == true);
+        OSW_UT_EVAL(object->ptr_attr.valid == true);
+        OSW_UT_EVAL(object->ptr_attr.next == (const int*) 0xBBBB);
+        OSW_UT_EVAL(object->ptr_attr.cur == (const int*) 0xBBBB);
+    }
+
+    {
+        /* Set to NULL */
+        object->ptr_attr.valid = false;
+        object->ptr_attr.next = NULL;
+
+        OW_STEER_BM_PTR_ATTR_UPDATE(object, ptr_attr);
+
+        OSW_UT_EVAL(ptr_attr_state.changed == true);
+        OSW_UT_EVAL(ptr_attr_state.present == false);
+        OSW_UT_EVAL(object->ptr_attr.valid == true);
+        OSW_UT_EVAL(object->ptr_attr.next == NULL);
+        OSW_UT_EVAL(object->ptr_attr.cur == NULL);
+    }
+
+    FREE(object->mem_attr.next);
+    FREE(object->mem_attr.cur);
+}
+
+OSW_UT(ow_steer_bm_case1)
+{
+    /*
+     * Scenario:
+     * - add group
+     * - add VIF
+     * - add neighbor
+     * - VIF goes up
+     * - configure neighbor
+     * - remove VIF
+     */
+    OSW_MODULE_LOAD(ow_steer_bm);
+    osw_ut_time_init();
+
+    extern struct ds_dlist g_osw_state_observer_list;
+
+    const char *group_a_name = "group_a";
+    const struct osw_ifname vif_aa_name = { .buf = { "vif_aa" } };
+    const struct osw_hwaddr vif_aa_name_addr = { .octet = { 0x0,  0x0, 0x0,  0x0, 0x0A, 0x0A } };
+    const struct osw_hwaddr neighbor_aaa_bssid = { .octet = { 0x0,  0x0, 0x0, 0x0A, 0x0A, 0x0A } };
+
+    struct ow_steer_bm_group *group_a = NULL;
+    struct ow_steer_bm_vif *vif_aa = NULL;
+    struct ow_steer_bm_neighbor *neighbor_aaa = NULL;
+
+    /* Group "a" is added */
+    group_a = ow_steer_bm_get_group(group_a_name);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 0);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* VIF "vif_aa" is added */
+    vif_aa = ow_steer_bm_group_get_vif(group_a, vif_aa_name.buf);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_vif_is_ready(vif_aa) == false);
+    OSW_UT_EVAL(ow_steer_bm_vif_is_up(vif_aa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* Neighbor "neighbor_aaa" is added */
+    neighbor_aaa = ow_steer_bm_get_neighbor(neighbor_aaa_bssid.octet);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == false);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* VIF "vif_aa" go up */
+    struct osw_drv_vif_state vif_aa_drv_state = {
+        .mac_addr = vif_aa_name_addr,
+        .vif_type = OSW_VIF_AP,
+    };
+    struct osw_state_vif_info vif_aa_info = {
+        .vif_name = vif_aa_name.buf,
+        .drv_state = &vif_aa_drv_state,
+    };
+    OW_STEER_BM_UT_CALL_STATE_OBS(vif_added_fn, &vif_aa_info);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_vif_is_ready(vif_aa) == true);
+    OSW_UT_EVAL(ow_steer_bm_vif_is_up(vif_aa) == true);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 1);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    /* Neighbor "neighbor_aaa" go up */
+    ow_steer_bm_neighbor_set_vif_name(neighbor_aaa, vif_aa_name.buf);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == false);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 1);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    const uint8_t neighbor_aaa_channel = 1;
+    ow_steer_bm_neighbor_set_channel_number(neighbor_aaa, &neighbor_aaa_channel);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == false);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 1);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    const uint8_t neighbor_aaa_op_class = 83;
+    ow_steer_bm_neighbor_set_op_class(neighbor_aaa, &neighbor_aaa_op_class);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == true);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == true);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 2);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[1], &neighbor_aaa_bssid) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 2);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 2);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    /* VIF "vif_aa" is removed */
+    ow_steer_bm_vif_unset(vif_aa);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == false);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 0);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+}
+
+OSW_UT(ow_steer_bm_case2)
+{
+    /*
+     * Scenario:
+     * - add group
+     * - add VIF
+     * - add neighbor
+     * - VIF goes up
+     * - configure neighbor
+     * - remove group
+     */
+    OSW_MODULE_LOAD(ow_steer_bm);
+    osw_ut_time_init();
+
+    extern struct ds_dlist g_osw_state_observer_list;
+
+    const char *group_a_name = "group_a";
+    const struct osw_ifname vif_aa_name = { .buf = { "vif_aa" } };
+    const struct osw_hwaddr vif_aa_name_addr = { .octet = { 0x0,  0x0, 0x0,  0x0, 0x0A, 0x0A } };
+    const struct osw_hwaddr neighbor_aaa_bssid = { .octet = { 0x0,  0x0, 0x0, 0x0A, 0x0A, 0x0A } };
+
+    struct ow_steer_bm_group *group_a = NULL;
+    struct ow_steer_bm_vif *vif_aa = NULL;
+    struct ow_steer_bm_neighbor *neighbor_aaa = NULL;
+
+    /* Group "a" is added */
+    group_a = ow_steer_bm_get_group(group_a_name);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 0);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* VIF "vif_aa" is added */
+    vif_aa = ow_steer_bm_group_get_vif(group_a, vif_aa_name.buf);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_vif_is_ready(vif_aa) == false);
+    OSW_UT_EVAL(ow_steer_bm_vif_is_up(vif_aa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* Neighbor "neighbor_aaa" is added */
+    neighbor_aaa = ow_steer_bm_get_neighbor(neighbor_aaa_bssid.octet);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == false);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* VIF "vif_aa" go up */
+    struct osw_drv_vif_state vif_aa_drv_state = {
+        .mac_addr = vif_aa_name_addr,
+        .vif_type = OSW_VIF_AP,
+    };
+    struct osw_state_vif_info vif_aa_info = {
+        .vif_name = vif_aa_name.buf,
+        .drv_state = &vif_aa_drv_state,
+    };
+    OW_STEER_BM_UT_CALL_STATE_OBS(vif_added_fn, &vif_aa_info);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_vif_is_ready(vif_aa) == true);
+    OSW_UT_EVAL(ow_steer_bm_vif_is_up(vif_aa) == true);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 1);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    /* Neighbor "neighbor_aaa" go up */
+    ow_steer_bm_neighbor_set_vif_name(neighbor_aaa, vif_aa_name.buf);
+    const uint8_t neighbor_aaa_channel = 1;
+    ow_steer_bm_neighbor_set_channel_number(neighbor_aaa, &neighbor_aaa_channel);
+    const uint8_t neighbor_aaa_op_class = 83;
+    ow_steer_bm_neighbor_set_op_class(neighbor_aaa, &neighbor_aaa_op_class);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == true);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == true);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 2);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[1], &neighbor_aaa_bssid) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 2);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 2);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    /* Group "group_a" is removed */
+    ow_steer_bm_group_unset(group_a);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == false);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == false);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+}
+
+OSW_UT(ow_steer_bm_case3)
+{
+    /*
+     * Scenario:
+     * - add group
+     * - add VIF
+     * - add neighbor
+     * - VIF goes up
+     * - configure neighbor
+     * - VIF goes down
+     */
+    OSW_MODULE_LOAD(ow_steer_bm);
+    osw_ut_time_init();
+
+    extern struct ds_dlist g_osw_state_observer_list;
+
+    const char *group_a_name = "group_a";
+    const struct osw_ifname vif_aa_name = { .buf = { "vif_aa" } };
+    const struct osw_hwaddr vif_aa_name_addr = { .octet = { 0x0,  0x0, 0x0,  0x0, 0x0A, 0x0A } };
+    const struct osw_hwaddr neighbor_aaa_bssid = { .octet = { 0x0,  0x0, 0x0, 0x0A, 0x0A, 0x0A } };
+
+    struct ow_steer_bm_group *group_a = NULL;
+    struct ow_steer_bm_vif *vif_aa = NULL;
+    struct ow_steer_bm_neighbor *neighbor_aaa = NULL;
+
+    /* Group "a" is added */
+    group_a = ow_steer_bm_get_group(group_a_name);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 0);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* VIF "vif_aa" is added */
+    vif_aa = ow_steer_bm_group_get_vif(group_a, vif_aa_name.buf);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_vif_is_ready(vif_aa) == false);
+    OSW_UT_EVAL(ow_steer_bm_vif_is_up(vif_aa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* Neighbor "neighbor_aaa" is added */
+    neighbor_aaa = ow_steer_bm_get_neighbor(neighbor_aaa_bssid.octet);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == false);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 0);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 0);
+
+    /* VIF "vif_aa" go up */
+    struct osw_drv_vif_state vif_aa_drv_state = {
+        .mac_addr = vif_aa_name_addr,
+        .vif_type = OSW_VIF_AP,
+    };
+    struct osw_state_vif_info vif_aa_info = {
+        .vif_name = vif_aa_name.buf,
+        .drv_state = &vif_aa_drv_state,
+    };
+    OW_STEER_BM_UT_CALL_STATE_OBS(vif_added_fn, &vif_aa_info);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_vif_is_ready(vif_aa) == true);
+    OSW_UT_EVAL(ow_steer_bm_vif_is_up(vif_aa) == true);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 1);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    /* Neighbor "neighbor_aaa" go up */
+    ow_steer_bm_neighbor_set_vif_name(neighbor_aaa, vif_aa_name.buf);
+    const uint8_t neighbor_aaa_channel = 1;
+    ow_steer_bm_neighbor_set_channel_number(neighbor_aaa, &neighbor_aaa_channel);
+    const uint8_t neighbor_aaa_op_class = 83;
+    ow_steer_bm_neighbor_set_op_class(neighbor_aaa, &neighbor_aaa_op_class);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_ready(neighbor_aaa) == true);
+    OSW_UT_EVAL(ow_steer_bm_neighbor_is_up(neighbor_aaa) == true);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 2);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &vif_aa_name_addr) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[1], &neighbor_aaa_bssid) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 2);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 2);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &vif_aa_name_addr, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    /* VIF "vif_aa" goes down */
+    OW_STEER_BM_UT_CALL_STATE_OBS(vif_removed_fn, &vif_aa_info);
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(ow_steer_bm_vif_is_ready(vif_aa) == false);
+    OSW_UT_EVAL(ow_steer_bm_vif_is_up(vif_aa) == false);
+
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.valid == true);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur != NULL);
+    OSW_UT_EVAL(group_a->bss_filter_policy_config.cur->bssid_num == 1);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&group_a->bss_filter_policy_config.cur->bssid[0], &neighbor_aaa_bssid) == 0);
+    OSW_UT_EVAL(ds_tree_len(&group_a->vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&group_a->vif_tree, &vif_aa_name) == vif_aa);
+    OSW_UT_EVAL(ds_dlist_len(&group_a->bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&group_a->bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+
+    OSW_UT_EVAL(ds_tree_len(&g_group_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_group_tree, group_a_name) == group_a);
+
+    OSW_UT_EVAL(ds_tree_len(&g_vif_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_vif_tree, &vif_aa_name) == vif_aa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_neighbor_tree) == 1);
+    OSW_UT_EVAL(ds_tree_find(&g_neighbor_tree, &neighbor_aaa_bssid) == neighbor_aaa);
+
+    OSW_UT_EVAL(ds_tree_len(&g_client_tree) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_sta_list) == 0);
+
+    OSW_UT_EVAL(ds_dlist_len(&g_bss_list) == 1);
+    OSW_UT_EVAL(ow_steer_bm_ut_ds_dlist_count_all(&g_bss_list, &neighbor_aaa_bssid, (ow_steer_bm_ut_cmp_fn_t*) osw_hwaddr_cmp) == 1);
+}
Index: core/src/lib/ow/src/ow_steer_candidate_list.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_candidate_list.c
@@ -0,0 +1,299 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <memutil.h>
+#include <const.h>
+#include <log.h>
+#include <module.h>
+#include <osw_ut.h>
+#include <osw_types.h>
+#include <osw_bss_map.h>
+#include "ow_steer_candidate_list.h"
+
+struct ow_steer_candidate {
+    struct osw_hwaddr bssid;
+    enum ow_steer_candidate_preference preference;
+    struct osw_channel channel;
+    unsigned int metric;
+};
+
+struct ow_steer_candidate_list {
+    struct ow_steer_candidate *set;
+    size_t set_size;
+};
+
+static int
+ow_steer_candidate_list_qsort_cmp(const void *a,
+                                  const void *b)
+{
+    const struct ow_steer_candidate *candidate_a = a;
+    const struct ow_steer_candidate *candidate_b = b;
+
+    if (candidate_a->metric < candidate_b->metric)
+        return 1;
+    else if (candidate_a->metric > candidate_b->metric)
+        return -1;
+    else
+        return 0;
+}
+
+static void
+ow_steer_candidate_list_candidate_init(struct ow_steer_candidate *candidate,
+                                       const struct osw_hwaddr *bssid,
+                                       const struct osw_channel *channel)
+{
+    assert(candidate != NULL);
+    assert(channel != NULL);
+
+    memset(candidate, 0, sizeof(*candidate));
+    memcpy(&candidate->bssid, bssid, sizeof(candidate->bssid));
+    memcpy(&candidate->channel, channel, sizeof(candidate->channel));
+}
+
+const char*
+ow_steer_candidate_preference_to_cstr(enum ow_steer_candidate_preference preference)
+{
+    switch(preference) {
+        case OW_STEER_CANDIDATE_PREFERENCE_NONE:
+            return "none";
+        case OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE:
+            return "available";
+        case OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE:
+            return "out of scope";
+        case OW_STEER_CANDIDATE_PREFERENCE_BLOCKED:
+            return "blocked";
+    }
+
+    return "(unknown preference)";
+}
+
+struct ow_steer_candidate_list*
+ow_steer_candidate_list_new(void)
+{
+    return CALLOC(1, sizeof(struct ow_steer_candidate));
+}
+
+void
+ow_steer_candidate_list_free(struct ow_steer_candidate_list *candidate_list)
+{
+    assert(candidate_list != NULL);
+
+    FREE(candidate_list->set);
+    FREE(candidate_list);
+}
+
+struct ow_steer_candidate_list*
+ow_steer_candidate_list_copy(const struct ow_steer_candidate_list *candidate_list)
+{
+    assert(candidate_list != NULL);
+
+    struct ow_steer_candidate_list *copy = CALLOC(1, sizeof(struct ow_steer_candidate));
+
+    if (candidate_list->set_size == 0)
+        return copy;
+
+    copy->set = MEMNDUP(candidate_list->set, candidate_list->set_size * sizeof(struct ow_steer_candidate));
+    copy->set_size = candidate_list->set_size;
+
+    return copy;
+}
+
+bool
+ow_steer_candidate_list_cmp(const struct ow_steer_candidate_list *candidate_list_a,
+                            const struct ow_steer_candidate_list *candidate_list_b)
+{
+    assert(candidate_list_a != NULL);
+    assert(candidate_list_b != NULL);
+
+    if (candidate_list_a->set_size != candidate_list_b->set_size)
+        return false;
+
+    return memcmp(candidate_list_a->set, candidate_list_b->set, candidate_list_a->set_size * sizeof(struct ow_steer_candidate)) == 0;
+}
+
+void
+ow_steer_candidate_list_bss_set(struct ow_steer_candidate_list *candidate_list,
+                                const struct osw_hwaddr *bssid,
+                                const struct osw_channel *channel)
+{
+    assert(candidate_list != NULL);
+    assert(bssid != NULL);
+
+    size_t i = 0;
+    for (i = 0; i < candidate_list->set_size; i++)
+        if (osw_hwaddr_cmp(&candidate_list->set[i].bssid, bssid) == 0)
+            break;
+
+    if (i == candidate_list->set_size) {
+        candidate_list->set_size++;
+        candidate_list->set = REALLOC(candidate_list->set, sizeof(struct ow_steer_candidate) * candidate_list->set_size);
+    }
+
+    ow_steer_candidate_list_candidate_init(&candidate_list->set[i], bssid, channel);
+}
+
+void
+ow_steer_candidate_list_bss_unset(struct ow_steer_candidate_list *candidate_list,
+                                  const struct osw_hwaddr *bssid)
+{
+    assert(candidate_list != NULL);
+    assert(bssid != NULL);
+
+    struct ow_steer_candidate *new_set;
+    size_t new_set_size;
+    size_t new_i = 0;
+    size_t i = 0;
+    bool found = false;
+
+    for (i = 0; i < candidate_list->set_size; i++) {
+        if (osw_hwaddr_cmp(&candidate_list->set[i].bssid, bssid) != 0)
+            continue;
+
+        found = true;
+        break;
+    }
+
+    if (found == false)
+        return;
+
+    new_set_size = candidate_list->set_size - 1;
+    new_set = CALLOC(new_set_size, sizeof(struct ow_steer_candidate));
+
+    for (i = 0; i < candidate_list->set_size; i++) {
+        if (osw_hwaddr_cmp(&candidate_list->set[i].bssid, bssid) == 0)
+            continue;
+
+        new_set[new_i] = candidate_list->set[i];
+        new_i++;
+    }
+
+    FREE(candidate_list->set);
+    candidate_list->set = new_set;
+    candidate_list->set_size = new_set_size;
+}
+
+void
+ow_steer_candidate_list_clear(struct ow_steer_candidate_list *candidate_list)
+{
+    assert(candidate_list != NULL);
+
+    size_t i = 0;
+    for (i = 0; i < candidate_list->set_size; i++) {
+        candidate_list->set[i].preference = OW_STEER_CANDIDATE_PREFERENCE_NONE;
+        candidate_list->set[i].metric = 0;
+    }
+}
+
+struct ow_steer_candidate*
+ow_steer_candidate_list_lookup(struct ow_steer_candidate_list *candidate_list,
+                               const struct osw_hwaddr *bssid)
+{
+    assert(candidate_list != NULL);
+
+    size_t i = 0;
+    for (i = 0; i < candidate_list->set_size; i++)
+        if (osw_hwaddr_cmp(&candidate_list->set[i].bssid, bssid) == 0)
+            return &candidate_list->set[i];
+
+    return NULL;
+}
+
+struct ow_steer_candidate*
+ow_steer_candidate_list_get(struct ow_steer_candidate_list *candidate_list,
+                            size_t index)
+{
+    assert(candidate_list != NULL);
+    assert(index < candidate_list->set_size);
+    return candidate_list->set + index;
+}
+
+const struct ow_steer_candidate*
+ow_steer_candidate_list_const_get(const struct ow_steer_candidate_list *candidate_list,
+                                  size_t index)
+{
+    assert(candidate_list != NULL);
+    assert(index < candidate_list->set_size);
+    return candidate_list->set + index;
+}
+
+size_t
+ow_steer_candidate_list_get_length(const struct ow_steer_candidate_list *candidate_list)
+{
+    assert(candidate_list != NULL);
+    return candidate_list->set_size;
+}
+
+void
+ow_steer_candidate_list_sigusr1_dump(struct ow_steer_candidate_list *candidate_list)
+{
+    assert(candidate_list != NULL);
+
+    size_t i = 0;
+
+    LOGI("ow: steer:       candidates:");
+    for (i = 0; i < candidate_list->set_size; i++)
+        LOGI("ow: steer:         candidate: bssid: "OSW_HWADDR_FMT" preference: %s",
+             OSW_HWADDR_ARG(&candidate_list->set[i].bssid),
+             ow_steer_candidate_preference_to_cstr(candidate_list->set[i].preference));
+}
+
+void
+ow_steer_candidate_list_sort(struct ow_steer_candidate_list *candidate_list)
+{
+    assert(candidate_list != NULL);
+
+    qsort(candidate_list->set, candidate_list->set_size, sizeof (*candidate_list->set),
+          ow_steer_candidate_list_qsort_cmp);
+}
+
+const struct osw_hwaddr*
+ow_steer_candidate_get_bssid(const struct ow_steer_candidate *candidate)
+{
+    assert(candidate != NULL);
+    return &candidate->bssid;
+}
+
+enum ow_steer_candidate_preference
+ow_steer_candidate_get_preference(const struct ow_steer_candidate *candidate)
+{
+    assert(candidate != NULL);
+    return candidate->preference;
+}
+
+void
+ow_steer_candidate_set_preference(struct ow_steer_candidate *candidate,
+                                  enum ow_steer_candidate_preference preference)
+{
+    assert(candidate != NULL);
+
+    if (candidate->preference != OW_STEER_CANDIDATE_PREFERENCE_NONE) {
+        LOGW("ow: steer: candidate: Cannot override "OSW_HWADDR_FMT" preference",
+             OSW_HWADDR_ARG(&candidate->bssid));
+        return;
+    }
+
+    candidate->preference = preference;
+}
+
+void
+ow_steer_candidate_inc_metric(struct ow_steer_candidate *candidate,
+                              unsigned int value)
+{
+    assert(candidate != NULL);
+    candidate->metric += value;
+}
+
+unsigned int
+ow_steer_candidate_get_metric(const struct ow_steer_candidate *candidate)
+{
+    assert(candidate != NULL);
+    return candidate->metric;
+}
+
+const struct osw_channel*
+ow_steer_candidate_get_channel(const struct ow_steer_candidate *candidate)
+{
+    assert(candidate != NULL);
+    return &candidate->channel;
+}
+
+#include "ow_steer_candidate_list_ut.c"
Index: core/src/lib/ow/src/ow_steer_candidate_list.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_candidate_list.h
@@ -0,0 +1,83 @@
+#ifndef OW_STEER_CANDIDATE_LIST_H
+#define OW_STEER_CANDIDATE_LIST_H
+
+struct ow_steer_candidate_list;
+struct ow_steer_candidate;
+
+enum ow_steer_candidate_preference {
+    OW_STEER_CANDIDATE_PREFERENCE_NONE = 0,
+    OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE,
+    OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE,
+    OW_STEER_CANDIDATE_PREFERENCE_BLOCKED,
+};
+
+const char*
+ow_steer_candidate_preference_to_cstr(enum ow_steer_candidate_preference preference);
+
+struct ow_steer_candidate_list*
+ow_steer_candidate_list_new(void);
+
+void
+ow_steer_candidate_list_free(struct ow_steer_candidate_list *candidate_list);
+
+struct ow_steer_candidate_list*
+ow_steer_candidate_list_copy(const struct ow_steer_candidate_list *candidate_list);
+
+bool
+ow_steer_candidate_list_cmp(const struct ow_steer_candidate_list *candidate_list_a,
+                            const struct ow_steer_candidate_list *candidate_list_b);
+
+void
+ow_steer_candidate_list_bss_set(struct ow_steer_candidate_list *candidate_list,
+                                const struct osw_hwaddr *bssid,
+                                const struct osw_channel *channel);
+
+void
+ow_steer_candidate_list_bss_unset(struct ow_steer_candidate_list *candidate_list,
+                                  const struct osw_hwaddr *bssid);
+
+void
+ow_steer_candidate_list_clear(struct ow_steer_candidate_list *candidate_list);
+
+struct ow_steer_candidate*
+ow_steer_candidate_list_lookup(struct ow_steer_candidate_list *candidate_list,
+                               const struct osw_hwaddr *bssid);
+
+struct ow_steer_candidate*
+ow_steer_candidate_list_get(struct ow_steer_candidate_list *candidate_list,
+                            size_t index);
+
+const struct ow_steer_candidate*
+ow_steer_candidate_list_const_get(const struct ow_steer_candidate_list *candidate_list,
+                                  size_t index);
+
+size_t
+ow_steer_candidate_list_get_length(const struct ow_steer_candidate_list *candidate_list);
+
+void
+ow_steer_candidate_list_sigusr1_dump(struct ow_steer_candidate_list *candidate_list);
+
+void
+ow_steer_candidate_list_sort(struct ow_steer_candidate_list *candidate_list);
+
+const struct osw_hwaddr*
+ow_steer_candidate_get_bssid(const struct ow_steer_candidate *candidate);
+
+enum ow_steer_candidate_preference
+ow_steer_candidate_get_preference(const struct ow_steer_candidate *candidate);
+
+void
+ow_steer_candidate_set_preference(struct ow_steer_candidate *candidate,
+                                   enum ow_steer_candidate_preference preference);
+
+void
+ow_steer_candidate_inc_metric(struct ow_steer_candidate *candidate,
+                              unsigned int value);
+
+unsigned int
+ow_steer_candidate_get_metric(const struct ow_steer_candidate *candidate);
+
+const struct osw_channel*
+ow_steer_candidate_get_channel(const struct ow_steer_candidate *candidate);
+
+#endif /* OW_STEER_CANDIDATE_LIST_H */
Index: core/src/lib/ow/src/ow_steer_candidate_list_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_candidate_list_ut.c
@@ -0,0 +1,164 @@
+#include <ev.h>
+#include <module.h>
+#include <osw_ut.h>
+
+static void
+ow_steer_candidate_list_ut_lifecycle_cb(void *data)
+{
+    struct ow_steer_candidate_list *candidates_a = NULL;
+    struct ow_steer_candidate_list *candidates_b = NULL;
+    struct ow_steer_candidate *candidate = NULL;
+    const struct osw_hwaddr bssid_a = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr bssid_b = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    const struct osw_hwaddr bssid_c = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr bssid_d = { .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, }, };
+    const enum ow_steer_candidate_preference pref_a = OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE;
+    const enum ow_steer_candidate_preference pref_b = OW_STEER_CANDIDATE_PREFERENCE_BLOCKED;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+
+    candidates_a = ow_steer_candidate_list_new();
+
+    /* Fill set with A, B and D */
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_a, &channel);
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_b, &channel);
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_d, &channel);
+
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_a) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_b) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_d) != NULL);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_d)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Remove D */
+    ow_steer_candidate_list_bss_unset(candidates_a, &bssid_d);
+
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_a) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_b) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_d) == NULL);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Add C */
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_c, &channel);
+
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_a) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_b) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_c) != NULL);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Set C again */
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_c, &channel);
+
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_a) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_b) != NULL);
+    assert(ow_steer_candidate_list_lookup(candidates_a, &bssid_c) != NULL);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Update preferences, one by one */
+    candidate = ow_steer_candidate_list_lookup(candidates_a, &bssid_a);
+    ow_steer_candidate_set_preference(candidate, pref_a);
+
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == pref_a);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    candidate = ow_steer_candidate_list_lookup(candidates_a, &bssid_c);
+    ow_steer_candidate_set_preference(candidate, pref_b);
+
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == pref_a);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_c)) == pref_b);
+
+    candidate = ow_steer_candidate_list_lookup(candidates_a, &bssid_b);
+    ow_steer_candidate_set_preference(candidate, pref_b);
+
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == pref_a);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == pref_b);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_c)) == pref_b);
+
+    /* Make a copy */
+    candidates_b = ow_steer_candidate_list_copy(candidates_a);
+    assert(ow_steer_candidate_list_cmp(candidates_a, candidates_b) == true);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a)) == pref_a);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b)) == pref_b);
+    assert(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_c)) == pref_b);
+
+    /* Modify source and copy */
+    ow_steer_candidate_list_bss_set(candidates_b, &bssid_d, &channel);
+    assert(ow_steer_candidate_list_cmp(candidates_a, candidates_b) == false);
+
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_d, &channel);
+    assert(ow_steer_candidate_list_cmp(candidates_a, candidates_b) == true);
+
+    /* Fini */
+    ow_steer_candidate_list_free(candidates_a);
+    ow_steer_candidate_list_free(candidates_b);
+}
+
+static void
+ow_steer_candidate_list_ut_metric_cb(void *data)
+{
+    struct ow_steer_candidate_list *candidates = NULL;
+    const struct osw_hwaddr bssid_a = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr bssid_b = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    const struct osw_hwaddr bssid_c = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr bssid_d = { .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, }, };
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+
+    candidates = ow_steer_candidate_list_new();
+
+    /* Fill set with A, B, C and D */
+    ow_steer_candidate_list_bss_set(candidates, &bssid_a, &channel);
+    ow_steer_candidate_list_bss_set(candidates, &bssid_b, &channel);
+    ow_steer_candidate_list_bss_set(candidates, &bssid_c, &channel);
+    ow_steer_candidate_list_bss_set(candidates, &bssid_d, &channel);
+
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_a)) == 0);
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_b)) == 0);
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_c)) == 0);
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_d)) == 0);
+
+    /* Set metrics */
+    ow_steer_candidate_inc_metric(ow_steer_candidate_list_lookup(candidates, &bssid_a), 0);
+    ow_steer_candidate_inc_metric(ow_steer_candidate_list_lookup(candidates, &bssid_b), 2);
+    ow_steer_candidate_inc_metric(ow_steer_candidate_list_lookup(candidates, &bssid_c), 1);
+    ow_steer_candidate_inc_metric(ow_steer_candidate_list_lookup(candidates, &bssid_d), 1);
+
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_a)) == 0);
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_b)) == 2);
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_c)) == 1);
+    assert(ow_steer_candidate_get_metric(ow_steer_candidate_list_lookup(candidates, &bssid_d)) == 1);
+
+    /* Sort metrics, expected order (high->low) B, C, D, A */ /* TODO Handle other possible order: B, D, C, A */
+    ow_steer_candidate_list_sort(candidates);
+
+    assert(ow_steer_candidate_list_get(candidates, 0) == ow_steer_candidate_list_lookup(candidates, &bssid_b));
+    assert(ow_steer_candidate_list_get(candidates, 1) == ow_steer_candidate_list_lookup(candidates, &bssid_c));
+    assert(ow_steer_candidate_list_get(candidates, 2) == ow_steer_candidate_list_lookup(candidates, &bssid_d));
+    assert(ow_steer_candidate_list_get(candidates, 3) == ow_steer_candidate_list_lookup(candidates, &bssid_a));
+
+    /* Fini */
+    ow_steer_candidate_list_free(candidates);
+}
+
+static void
+ow_steer_candidate_list_ut_module_init(void *data)
+{
+    osw_ut_register("ow_steer_candidate_list_ut_lifecycle", ow_steer_candidate_list_ut_lifecycle_cb, NULL);
+    osw_ut_register("ow_steer_candidate_list_ut_metric", ow_steer_candidate_list_ut_metric_cb, NULL);
+}
+
+static void
+ow_steer_candidate_list_ut_module_fini(void *data)
+{
+    /* nop */
+}
+
+MODULE(ow_steer_candidate_list_ut_module,
+       ow_steer_candidate_list_ut_module_init,
+       ow_steer_candidate_list_ut_module_fini);
Index: core/src/lib/ow/src/ow_steer_executor_action.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action.c
@@ -0,0 +1,40 @@
+#include <stdint.h>
+#include <ds_dlist.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_action_i.h"
+
+struct ow_steer_executor_action*
+ow_steer_executor_action_create(const char *name,
+                                const struct ow_steer_executor_action_ops *ops,
+                                void *priv)
+{
+    ASSERT(name != NULL, "");
+    ASSERT(ops != NULL, "");
+
+    struct ow_steer_executor_action *action = CALLOC(1, sizeof(*action));
+
+    action->name = name;
+    memcpy(&action->ops, ops, sizeof(action->ops));
+    action->priv = priv;
+
+    return action;
+}
+
+void
+ow_steer_executor_action_free(struct ow_steer_executor_action *action)
+{
+    ASSERT(action != NULL, "");
+    FREE(action);
+}
+
+void*
+ow_steer_executor_action_get_priv(struct ow_steer_executor_action *action)
+{
+    ASSERT(action != NULL, "");
+    return action->priv;
+}
Index: core/src/lib/ow/src/ow_steer_executor_action.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action.h
@@ -0,0 +1,44 @@
+#ifndef OW_STEER_EXECUTOR_ACTION_H
+#define OW_STEER_EXECUTOR_ACTION_H
+
+enum ow_steer_executor_action_result {
+    OW_STEER_EXECUTOR_ACTION_CONTINUE,
+    OW_STEER_EXECUTOR_ACTION_BREAK,
+};
+
+struct ow_steer_executor_action;
+
+typedef enum ow_steer_executor_action_result
+ow_steer_executor_action_call_fn_t(struct ow_steer_executor_action *action,
+                                   const struct osw_hwaddr *sta_addr,
+                                   const struct ow_steer_candidate_list *candidate_list,
+                                   struct osw_conf_mutator *conf_mutator,
+                                   uint64_t *next_at_nsec);
+
+typedef void
+ow_steer_executor_action_conf_mutate_fn_t(struct ow_steer_executor_action *action,
+                                         const struct osw_hwaddr *sta_addr,
+                                         const struct ow_steer_candidate_list *candidate_list,
+                                         struct ds_tree *phy_tree);
+
+typedef void
+ow_steer_executor_action_reset_fn_t(struct ow_steer_executor_action *action);
+
+struct ow_steer_executor_action_ops {
+    ow_steer_executor_action_call_fn_t *call_fn;
+    ow_steer_executor_action_conf_mutate_fn_t *conf_mutate_fn;
+    ow_steer_executor_action_reset_fn_t *reset_fn;
+};
+
+struct ow_steer_executor_action*
+ow_steer_executor_action_create(const char *name,
+                                const struct ow_steer_executor_action_ops *ops,
+                                void *priv);
+
+void
+ow_steer_executor_action_free(struct ow_steer_executor_action *action);
+
+void*
+ow_steer_executor_action_get_priv(struct ow_steer_executor_action *action);
+
+#endif /* OW_STEER_EXECUTOR_ACTION_H */
Index: core/src/lib/ow/src/ow_steer_executor_action_acl.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_acl.c
@@ -0,0 +1,243 @@
+#include <log.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_mux.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_action_acl.h"
+
+struct ow_steer_executor_action_acl_bssid_entry {
+    struct osw_hwaddr bssid;
+    struct ds_tree_node node;
+};
+
+struct ow_steer_executor_action_acl {
+    struct ow_steer_executor_action *base;
+    struct ds_tree *blocked_bssid_tree;
+};
+
+static struct ds_tree*
+ow_steer_executor_action_acl_blocked_bssid_tree_build(const struct ow_steer_candidate_list *candidate_list)
+{
+    ASSERT(candidate_list != NULL, "");
+
+    struct ds_tree *blocked_bssid_tree = CALLOC(1, sizeof(*blocked_bssid_tree));
+    size_t i = 0;
+
+    ds_tree_init(blocked_bssid_tree, (ds_key_cmp_t*) osw_hwaddr_cmp, struct ow_steer_executor_action_acl_bssid_entry, node);
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        const struct ow_steer_candidate *candidate = ow_steer_candidate_list_const_get(candidate_list, i);
+        const enum ow_steer_candidate_preference preference = ow_steer_candidate_get_preference(candidate);
+        const struct osw_hwaddr *bssid = ow_steer_candidate_get_bssid(candidate);
+        struct ow_steer_executor_action_acl_bssid_entry *entry;
+
+        if (preference != OW_STEER_CANDIDATE_PREFERENCE_BLOCKED)
+            continue;
+
+        entry = CALLOC(1, sizeof(*entry));
+        memcpy(&entry->bssid, bssid, sizeof(entry->bssid));
+        ds_tree_insert(blocked_bssid_tree, entry, &entry->bssid);
+    }
+
+    return blocked_bssid_tree;
+}
+
+static void
+ow_steer_executor_action_acl_blocked_bssid_tree_free(struct ds_tree *blocked_bssid_tree)
+{
+    if (blocked_bssid_tree == NULL)
+        return;
+
+    struct ow_steer_executor_action_acl_bssid_entry *entry;
+    struct ow_steer_executor_action_acl_bssid_entry *tmp;
+
+    ds_tree_foreach_safe(blocked_bssid_tree, entry, tmp) {
+        ds_tree_remove(blocked_bssid_tree, entry);
+        FREE(entry);
+    }
+
+    FREE(blocked_bssid_tree);
+}
+
+static bool
+ow_steer_executor_action_acl_blocked_bssid_tree_cmp(struct ds_tree *blocked_bssid_tree_a,
+                                                    struct ds_tree *blocked_bssid_tree_b)
+{
+    ASSERT(blocked_bssid_tree_a != NULL, "");
+    ASSERT(blocked_bssid_tree_b != NULL, "");
+
+    const size_t tree_a_len = ds_tree_len(blocked_bssid_tree_a);
+    const size_t tree_b_len = ds_tree_len(blocked_bssid_tree_b);
+    struct ow_steer_executor_action_acl_bssid_entry *entry_a;
+    struct ow_steer_executor_action_acl_bssid_entry *entry_b;
+
+    if (tree_a_len != tree_b_len)
+        return false;
+
+    entry_a = ds_tree_head(blocked_bssid_tree_a);
+    entry_b = ds_tree_head(blocked_bssid_tree_b);
+
+    while (entry_a != NULL && entry_b != NULL) {
+        if (osw_hwaddr_cmp(&entry_a->bssid, &entry_b->bssid) != 0)
+            return false;
+
+        entry_a = ds_tree_next(blocked_bssid_tree_a, entry_a);
+        entry_b = ds_tree_next(blocked_bssid_tree_b, entry_b);
+    }
+
+    return true;
+}
+
+static enum ow_steer_executor_action_result
+ow_steer_executor_action_acl_call_fn(struct ow_steer_executor_action *action,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct ow_steer_candidate_list *candidate_list,
+                                     struct osw_conf_mutator *conf_mutator,
+                                     uint64_t *next_at_nsec)
+{
+    struct ow_steer_executor_action_acl *acl_action = ow_steer_executor_action_get_priv(action);
+    struct ds_tree *blocked_bssid_tree = ow_steer_executor_action_acl_blocked_bssid_tree_build(candidate_list);
+    bool result;
+
+    if (acl_action->blocked_bssid_tree == NULL)
+        goto invalidate_conf;
+
+    result = ow_steer_executor_action_acl_blocked_bssid_tree_cmp(acl_action->blocked_bssid_tree, blocked_bssid_tree);
+    if (result == false)
+        goto invalidate_conf;
+
+    ow_steer_executor_action_acl_blocked_bssid_tree_free(blocked_bssid_tree);
+    return OW_STEER_EXECUTOR_ACTION_CONTINUE;
+
+invalidate_conf:
+    osw_conf_invalidate(conf_mutator);
+    ow_steer_executor_action_acl_blocked_bssid_tree_free(acl_action->blocked_bssid_tree);
+    acl_action->blocked_bssid_tree = blocked_bssid_tree;
+    return OW_STEER_EXECUTOR_ACTION_BREAK;
+}
+
+static void
+ow_steer_executor_action_acl_conf_mutate_fn(struct ow_steer_executor_action *action,
+                                            const struct osw_hwaddr *sta_addr,
+                                            const struct ow_steer_candidate_list *candidate_list,
+                                            struct ds_tree *phy_tree)
+{
+    struct ow_steer_executor_action_acl *acl_action = ow_steer_executor_action_get_priv(action);
+    struct osw_conf_phy* phy;
+
+    ds_tree_foreach(phy_tree, phy) {
+        struct osw_conf_vif* vif;
+
+        ds_tree_foreach(&phy->vif_tree, vif) {
+            struct osw_conf_acl *entry = NULL;
+            bool blocked = false;
+
+            if (vif->vif_type != OSW_VIF_AP)
+                continue;
+
+            blocked = ds_tree_find(acl_action->blocked_bssid_tree, &vif->mac_addr) != NULL;
+            switch(vif->u.ap.acl_policy) {
+                case OSW_ACL_NONE:
+                    if (blocked == false)
+                        continue;
+
+                    vif->u.ap.acl_policy = OSW_ACL_DENY_LIST;
+                    /* fall through */
+                case OSW_ACL_DENY_LIST:
+                    entry = ds_tree_find(&vif->u.ap.acl_tree, sta_addr);
+                    if (blocked == true) {
+                        if (entry != NULL)
+                            continue;
+
+                        entry = CALLOC(1, sizeof(*entry));
+                        memcpy(&entry->mac_addr, sta_addr, sizeof(entry->mac_addr));
+                        ds_tree_insert(&vif->u.ap.acl_tree, entry, &entry->mac_addr);
+
+                        LOGD("ow: steer: executor: action: acl: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" blocked: %s acl_policy: %s add sta",
+                             OSW_HWADDR_ARG(sta_addr), OSW_HWADDR_ARG(&vif->mac_addr), blocked == true ? "true" : "false",
+                             osw_acl_policy_to_str(vif->u.ap.acl_policy));
+                    }
+                    else {
+                        if (entry == NULL)
+                            continue;
+
+                        LOGW("ow: steer: executor: action: acl: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" blocked: %s acl_policy: %s sta is already on acl, cannot remove sta",
+                             OSW_HWADDR_ARG(sta_addr), OSW_HWADDR_ARG(&vif->mac_addr), blocked == true ? "true" : "false",
+                             osw_acl_policy_to_str(vif->u.ap.acl_policy));
+                    }
+                    break;
+                case OSW_ACL_ALLOW_LIST:
+                    entry = ds_tree_find(&vif->u.ap.acl_tree, sta_addr);
+                    if (blocked == true) {
+                        if (entry == NULL)
+                            continue;
+
+                        ds_tree_remove(&vif->u.ap.acl_tree, entry);
+
+                        LOGD("ow: steer: executor: action: acl: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" blocked: %s acl_policy: %s remove sta",
+                             OSW_HWADDR_ARG(sta_addr), OSW_HWADDR_ARG(&vif->mac_addr), blocked == true ? "true" : "false",
+                             osw_acl_policy_to_str(vif->u.ap.acl_policy));
+
+                        FREE(entry);
+                    }
+                    else {
+                        if (entry != NULL)
+                            continue;
+
+                        entry = CALLOC(1, sizeof(*entry));
+                        memcpy(&entry->mac_addr, sta_addr, sizeof(entry->mac_addr));
+                        ds_tree_insert(&vif->u.ap.acl_tree, entry, &entry->mac_addr);
+
+                        LOGD("ow: steer: executor: action: acl: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" blocked: %s acl_policy: %s add sta",
+                             OSW_HWADDR_ARG(sta_addr), OSW_HWADDR_ARG(&vif->mac_addr), blocked == true ? "true" : "false",
+                             osw_acl_policy_to_str(vif->u.ap.acl_policy));
+                    }
+                    break;
+            }
+        }
+    }
+}
+
+static void
+ow_steer_executor_action_acl_reset_fn(struct ow_steer_executor_action *action)
+{
+    struct ow_steer_executor_action_acl *acl_action = ow_steer_executor_action_get_priv(action);
+
+    ow_steer_executor_action_acl_blocked_bssid_tree_free(acl_action->blocked_bssid_tree);
+    acl_action->blocked_bssid_tree = NULL;
+}
+
+struct ow_steer_executor_action_acl*
+ow_steer_executor_action_acl_create(void)
+{
+    const struct ow_steer_executor_action_ops ops = {
+        .call_fn = ow_steer_executor_action_acl_call_fn,
+        .conf_mutate_fn = ow_steer_executor_action_acl_conf_mutate_fn,
+        .reset_fn = ow_steer_executor_action_acl_reset_fn,
+    };
+    struct ow_steer_executor_action_acl *acl_action = CALLOC(1, sizeof(*acl_action));
+
+    acl_action->base = ow_steer_executor_action_create("executor_action_acl", &ops, acl_action);
+
+    return acl_action;
+}
+
+void
+ow_steer_executor_action_acl_free(struct ow_steer_executor_action_acl *acl_action)
+{
+    ASSERT(acl_action != NULL, "");
+    ow_steer_executor_action_acl_blocked_bssid_tree_free(acl_action->blocked_bssid_tree);
+    ow_steer_executor_action_free(acl_action->base);
+    FREE(acl_action);
+}
+
+struct ow_steer_executor_action*
+ow_steer_executor_action_acl_get_base(struct ow_steer_executor_action_acl *acl_action)
+{
+    ASSERT(acl_action != NULL, "");
+    return acl_action->base;
+}
+
+#include "ow_steer_executor_action_acl_ut.c"
Index: core/src/lib/ow/src/ow_steer_executor_action_acl.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_acl.h
@@ -0,0 +1,15 @@
+#ifndef OW_STEER_EXECUTOR_ACTION_ACL_H
+#define OW_STEER_EXECUTOR_ACTION_ACL_H
+
+struct ow_steer_executor_action_acl;
+
+struct ow_steer_executor_action_acl*
+ow_steer_executor_action_acl_create(void);
+
+void
+ow_steer_executor_action_acl_free(struct ow_steer_executor_action_acl *acl_action);
+
+struct ow_steer_executor_action*
+ow_steer_executor_action_acl_get_base(struct ow_steer_executor_action_acl *acl_action);
+
+#endif /* OW_STEER_EXECUTOR_ACTION_ACL_H */
Index: core/src/lib/ow/src/ow_steer_executor_action_acl_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_acl_ut.c
@@ -0,0 +1,75 @@
+#include <osw_ut.h>
+
+OSW_UT(ow_steer_executor_action_acl_ut__blocked_bssid_tree_cmp) {
+    struct ow_steer_candidate_list *candidates_a = NULL;
+    struct ow_steer_candidate_list *candidates_b = NULL;
+    struct ow_steer_candidate_list *candidates_c = NULL;
+    struct ds_tree *blocked_bssid_tree_a = NULL;
+    struct ds_tree *blocked_bssid_tree_b = NULL;
+    struct ds_tree *blocked_bssid_tree_c = NULL;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct osw_hwaddr bssid_a = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr bssid_b = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    const struct osw_hwaddr bssid_c = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr bssid_d = { .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, }, };
+    bool result = false;
+
+    /*
+     * Setup
+     */
+    candidates_a = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_a, &channel);
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_b, &channel);
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_c, &channel);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_b), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_c), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+
+    candidates_b = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidates_b, &bssid_b, &channel);
+    ow_steer_candidate_list_bss_set(candidates_b, &bssid_c, &channel);
+    ow_steer_candidate_list_bss_set(candidates_b, &bssid_d, &channel);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_b, &bssid_b), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_b, &bssid_c), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_b, &bssid_d), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+
+    candidates_c = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidates_c, &bssid_b, &channel);
+    ow_steer_candidate_list_bss_set(candidates_c, &bssid_d, &channel);
+    ow_steer_candidate_list_bss_set(candidates_a, &bssid_a, &channel);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_a, &bssid_a), OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_c, &bssid_b), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    ow_steer_candidate_set_preference(ow_steer_candidate_list_lookup(candidates_c, &bssid_d), OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+
+    blocked_bssid_tree_a = ow_steer_executor_action_acl_blocked_bssid_tree_build(candidates_a);
+    blocked_bssid_tree_b = ow_steer_executor_action_acl_blocked_bssid_tree_build(candidates_b);
+    blocked_bssid_tree_c = ow_steer_executor_action_acl_blocked_bssid_tree_build(candidates_c);
+
+    /*
+     * The same trees
+     */
+    result = ow_steer_executor_action_acl_blocked_bssid_tree_cmp(blocked_bssid_tree_a, blocked_bssid_tree_a);
+    OSW_UT_EVAL(result == true);
+
+    /*
+     * Different trees (different content, same length)
+     */
+    result = ow_steer_executor_action_acl_blocked_bssid_tree_cmp(blocked_bssid_tree_a, blocked_bssid_tree_b);
+    OSW_UT_EVAL(result == false);
+
+    /*
+     * Different trees (different content & length)
+     */
+    result = ow_steer_executor_action_acl_blocked_bssid_tree_cmp(blocked_bssid_tree_a, blocked_bssid_tree_c);
+    OSW_UT_EVAL(result == false);
+
+    /*
+     * Cleanup
+     */
+    ow_steer_executor_action_acl_blocked_bssid_tree_free(blocked_bssid_tree_a);
+    ow_steer_executor_action_acl_blocked_bssid_tree_free(blocked_bssid_tree_b);
+    ow_steer_executor_action_acl_blocked_bssid_tree_free(blocked_bssid_tree_c);
+    ow_steer_candidate_list_free(candidates_a);
+    ow_steer_candidate_list_free(candidates_b);
+    ow_steer_candidate_list_free(candidates_c);
+}
Index: core/src/lib/ow/src/ow_steer_executor_action_btm.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_btm.c
@@ -0,0 +1,63 @@
+#include <log.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_mux.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_action_btm.h"
+
+struct ow_steer_executor_action_btm {
+    struct ow_steer_executor_action *base;
+    bool executed;
+};
+
+static enum ow_steer_executor_action_result
+ow_steer_executor_action_btm_call_fn(struct ow_steer_executor_action *action,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct ow_steer_candidate_list *candidate_list,
+                                     struct osw_conf_mutator *mutator,
+                                     uint64_t *next_at_nsec)
+{
+    struct ow_steer_executor_action_btm *btm_action = ow_steer_executor_action_get_priv(action);
+
+    if (btm_action->executed == true)
+        return OW_STEER_EXECUTOR_ACTION_CONTINUE;
+
+    /* TODO */
+
+    btm_action->executed = true;
+
+    return OW_STEER_EXECUTOR_ACTION_BREAK;
+}
+
+static void
+ow_steer_executor_action_btm_reset_fn(struct ow_steer_executor_action *action)
+{
+    ASSERT(action != NULL, "");
+    struct ow_steer_executor_action_btm *btm_action = ow_steer_executor_action_get_priv(action);
+    btm_action->executed = false;
+}
+
+struct ow_steer_executor_action_btm*
+ow_steer_executor_action_btm_create(void)
+{
+    const struct ow_steer_executor_action_ops ops = {
+        .call_fn = ow_steer_executor_action_btm_call_fn,
+        .reset_fn = ow_steer_executor_action_btm_reset_fn,
+    };
+    struct ow_steer_executor_action_btm *btm_action = CALLOC(1, sizeof(*btm_action));
+
+    btm_action->base = ow_steer_executor_action_create("executor_action_btm", &ops, btm_action);
+
+    return btm_action;
+}
+
+void
+ow_steer_executor_action_btm_free(struct ow_steer_executor_action_btm *btm_action)
+{
+    ASSERT(btm_action != NULL, "");
+    ow_steer_executor_action_free(btm_action->base);
+    FREE(btm_action);
+}
Index: core/src/lib/ow/src/ow_steer_executor_action_btm.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_btm.h
@@ -0,0 +1,12 @@
+#ifndef OW_STEER_EXECUTOR_ACTION_BTM_H
+#define OW_STEER_EXECUTOR_ACTION_BTM_H
+
+struct ow_steer_executor_action_btm;
+
+struct ow_steer_executor_action_btm*
+ow_steer_executor_action_btm_create(void);
+
+void
+ow_steer_executor_action_btm_free(struct ow_steer_executor_action_btm *btm_action);
+
+#endif /* OW_STEER_EXECUTOR_ACTION_BTM_H */
Index: core/src/lib/ow/src/ow_steer_executor_action_deauth.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_deauth.c
@@ -0,0 +1,80 @@
+#include <log.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_mux.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_action_deauth.h"
+
+struct ow_steer_executor_action_deauth {
+    struct ow_steer_executor_action *base;
+    bool executed;
+};
+
+#define DOT11_DEAUTH_REASON_CODE_UNSPECIFIED 1
+
+static enum ow_steer_executor_action_result
+ow_steer_executor_action_deauth_call_fn(struct ow_steer_executor_action *action,
+                                        const struct osw_hwaddr *sta_addr,
+                                        const struct ow_steer_candidate_list *candidate_list,
+                                        struct osw_conf_mutator *mutator,
+                                        uint64_t *next_at_nsec)
+{
+    struct ow_steer_executor_action_deauth *deauth_action = ow_steer_executor_action_get_priv(action);
+    const char *phy_name;
+    const char *vif_name;
+    bool result;
+
+    if (deauth_action->executed == true)
+        return OW_STEER_EXECUTOR_ACTION_CONTINUE;
+
+    const struct osw_state_sta_info *sta_info = osw_state_sta_lookup_newest(sta_addr);
+    if (sta_info == NULL) return OW_STEER_EXECUTOR_ACTION_BREAK;
+    if (WARN_ON(sta_info->vif == NULL)) return OW_STEER_EXECUTOR_ACTION_BREAK;
+    if (WARN_ON(sta_info->vif->phy == NULL)) return OW_STEER_EXECUTOR_ACTION_BREAK;
+
+    phy_name = sta_info->vif->phy->phy_name;
+    vif_name = sta_info->vif->vif_name;
+
+    result = osw_mux_request_sta_deauth(phy_name, vif_name, sta_addr, DOT11_DEAUTH_REASON_CODE_UNSPECIFIED);
+    if (result == true)
+        LOGI("ow: steer: executor: action: deauth: sta: "OSW_HWADDR_FMT" issued deauth", OSW_HWADDR_ARG(sta_addr));
+    else
+        LOGW("ow: steer: executor: action: deauth: sta: "OSW_HWADDR_FMT" failed to deauth", OSW_HWADDR_ARG(sta_addr));
+
+    deauth_action->executed = true;
+
+    return OW_STEER_EXECUTOR_ACTION_BREAK;
+}
+
+static void
+ow_steer_executor_action_deauth_reset_fn(struct ow_steer_executor_action *action)
+{
+    ASSERT(action != NULL, "");
+    struct ow_steer_executor_action_deauth *deauth_action = ow_steer_executor_action_get_priv(action);
+    deauth_action->executed = false;
+}
+
+struct ow_steer_executor_action_deauth*
+ow_steer_executor_action_deauth_create(void)
+{
+    const struct ow_steer_executor_action_ops ops = {
+        .call_fn = ow_steer_executor_action_deauth_call_fn,
+        .reset_fn = ow_steer_executor_action_deauth_reset_fn,
+    };
+    struct ow_steer_executor_action_deauth *deauth_action = CALLOC(1, sizeof(*deauth_action));
+
+    deauth_action->base = ow_steer_executor_action_create("executor_action_deauth", &ops, deauth_action);
+
+    return deauth_action;
+}
+
+void
+ow_steer_executor_action_deauth_free(struct ow_steer_executor_action_deauth *deauth_action)
+{
+    ASSERT(deauth_action != NULL, "");
+    ow_steer_executor_action_free(deauth_action->base);
+    FREE(deauth_action);
+}
Index: core/src/lib/ow/src/ow_steer_executor_action_deauth.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_deauth.h
@@ -0,0 +1,12 @@
+#ifndef OW_STEER_EXECUTOR_ACTION_DEAUTH_H
+#define OW_STEER_EXECUTOR_ACTION_DEAUTH_H
+
+struct ow_steer_executor_action_deauth;
+
+struct ow_steer_executor_action_deauth*
+ow_steer_executor_action_deauth_create(void);
+
+void
+ow_steer_executor_action_deauth_free(struct ow_steer_executor_action_deauth *deauth_action);
+
+#endif /* OW_STEER_EXECUTOR_ACTION_DEAUTH_H */
Index: core/src/lib/ow/src/ow_steer_executor_action_i.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_action_i.h
@@ -0,0 +1,12 @@
+#ifndef OW_STEER_EXECUTOR_ACTION_I_H
+#define OW_STEER_EXECUTOR_ACTION_I_H
+
+struct ow_steer_executor_action {
+    const char *name;
+    struct ow_steer_executor_action_ops ops;
+    void *priv;
+
+    struct ds_dlist_node node;
+};
+
+#endif /* OW_STEER_EXECUTOR_ACTION_I_H */
Index: core/src/lib/ow/src/ow_steer_executor_chain.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_chain.c
@@ -0,0 +1,119 @@
+#include <stdint.h>
+#include <log.h>
+#include <ds_dlist.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_action_i.h"
+#include "ow_steer_executor_chain.h"
+
+struct ow_steer_executor_chain {
+    struct ds_dlist action_list;
+};
+
+struct ow_steer_executor_chain*
+ow_steer_executor_chain_create(void)
+{
+    struct ow_steer_executor_chain *executor_chain = CALLOC(1, sizeof(*executor_chain));
+    ds_dlist_init(&executor_chain->action_list, struct ow_steer_executor_action, node);
+    return executor_chain;
+}
+
+void
+ow_steer_executor_chain_free(struct ow_steer_executor_chain *executor_chain)
+{
+    ASSERT(executor_chain != NULL, "");
+
+    ow_steer_executor_chain_reset(executor_chain);
+    FREE(executor_chain);
+}
+
+void
+ow_steer_executor_chain_append(struct ow_steer_executor_chain *executor_chain,
+                               struct ow_steer_executor_action *action)
+{
+    ASSERT(executor_chain != NULL, "");
+    ASSERT(action != NULL, "");
+
+    if (action->ops.reset_fn != NULL)
+        action->ops.reset_fn(action);
+
+    ds_dlist_insert_tail(&executor_chain->action_list, action);
+}
+
+void
+ow_steer_executor_chain_reset(struct ow_steer_executor_chain *executor_chain)
+{
+    ASSERT(executor_chain != NULL, "");
+
+    struct ow_steer_executor_action *action;
+    struct ow_steer_executor_action *tmp;
+
+    ds_dlist_foreach_safe(&executor_chain->action_list, action, tmp) {
+        if (action->ops.reset_fn != NULL)
+            action->ops.reset_fn(action);
+
+        ds_dlist_remove(&executor_chain->action_list, action);
+    }
+}
+
+void
+ow_steer_executor_chain_call(struct ow_steer_executor_chain *executor_chain,
+                             const struct osw_hwaddr *sta_addr,
+                             const struct ow_steer_candidate_list *candidate_list,
+                             struct osw_conf_mutator *conf_mutator,
+                             uint64_t *next_at_nsec)
+{
+    ASSERT(executor_chain != NULL, "");
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(candidate_list != NULL, "");
+    ASSERT(conf_mutator != NULL, "");
+    ASSERT(next_at_nsec != NULL, "");
+
+    struct ow_steer_executor_action *action;
+
+    *next_at_nsec = 0;
+
+    ds_dlist_foreach(&executor_chain->action_list, action) {
+        uint64_t action_next_at_nsec = 0;
+        enum ow_steer_executor_action_result result;
+
+        if (action->ops.call_fn == NULL)
+            continue;
+
+        result = action->ops.call_fn(action, sta_addr, candidate_list, conf_mutator, &action_next_at_nsec);
+
+        if (action_next_at_nsec < *next_at_nsec)
+            *next_at_nsec = action_next_at_nsec;
+
+        switch (result) {
+            case OW_STEER_EXECUTOR_ACTION_CONTINUE:
+                break;
+            case OW_STEER_EXECUTOR_ACTION_BREAK:
+                return;
+        }
+    }
+}
+
+void
+ow_steer_executor_chain_conf_mutate(struct ow_steer_executor_chain *executor_chain,
+                                    const struct osw_hwaddr *sta_addr,
+                                    const struct ow_steer_candidate_list *candidate_list,
+                                    struct ds_tree *phy_tree)
+{
+    ASSERT(executor_chain != NULL, "");
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(candidate_list != NULL, "");
+    ASSERT(phy_tree != NULL, "");
+
+    struct ow_steer_executor_action *action;
+
+    ds_dlist_foreach(&executor_chain->action_list, action)
+        if (action->ops.conf_mutate_fn != NULL)
+            action->ops.conf_mutate_fn(action, sta_addr, candidate_list, phy_tree);
+}
+
+#include "ow_steer_executor_chain_ut.c"
Index: core/src/lib/ow/src/ow_steer_executor_chain.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_chain.h
@@ -0,0 +1,32 @@
+#ifndef OW_STEER_EXECUTOR_CHAIN_H
+#define OW_STEER_EXECUTOR_CHAIN_H
+
+struct ow_steer_executor_chain;
+
+struct ow_steer_executor_chain*
+ow_steer_executor_chain_create(void);
+
+void
+ow_steer_executor_chain_free(struct ow_steer_executor_chain *executor_chain);
+
+void
+ow_steer_executor_chain_append(struct ow_steer_executor_chain *executor_chain,
+                               struct ow_steer_executor_action *action);
+
+void
+ow_steer_executor_chain_reset(struct ow_steer_executor_chain *executor_chain);
+
+void
+ow_steer_executor_chain_call(struct ow_steer_executor_chain *executor_chain,
+                             const struct osw_hwaddr *sta_mac,
+                             const struct ow_steer_candidate_list *candidate_list,
+                             struct osw_conf_mutator *conf_mutator,
+                             uint64_t *next_at_nsec);
+
+void
+ow_steer_executor_chain_conf_mutate(struct ow_steer_executor_chain *executor_chain,
+                                    const struct osw_hwaddr *sta_mac,
+                                    const struct ow_steer_candidate_list *candidate_list,
+                                    struct ds_tree *phy_tree);
+
+#endif /* OW_STEER_EXECUTOR_CHAIN_H */
Index: core/src/lib/ow/src/ow_steer_executor_chain_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_chain_ut.c
@@ -0,0 +1,168 @@
+#include <osw_ut.h>
+
+static void
+ow_steer_executor_chain_ut_action_conf_mutate(struct ow_steer_executor_action *action,
+                                              const struct osw_hwaddr *sta_addr,
+                                              const struct ow_steer_candidate_list *candidate_list,
+                                              struct ds_tree *phy_tree)
+{
+    ASSERT(action != NULL, "");
+    ASSERT(action->priv != NULL, "");
+
+    unsigned int *cnt = action->priv;
+    *cnt = *cnt + 1;
+}
+
+static enum ow_steer_executor_action_result
+ow_steer_executor_chain_ut_action_call_continue(struct ow_steer_executor_action *action,
+                                                const struct osw_hwaddr *sta_addr,
+                                                const struct ow_steer_candidate_list *candidate_list,
+                                                struct osw_conf_mutator *conf_mutator,
+                                                uint64_t *next_at_nsec)
+{
+    ASSERT(action != NULL, "");
+    ASSERT(action->priv != NULL, "");
+
+    unsigned int *cnt = action->priv;
+    *cnt = *cnt + 1;
+    return OW_STEER_EXECUTOR_ACTION_CONTINUE;
+}
+
+static enum ow_steer_executor_action_result
+ow_steer_executor_chain_ut_action_call_break(struct ow_steer_executor_action *action,
+                                             const struct osw_hwaddr *sta_addr,
+                                             const struct ow_steer_candidate_list *candidate_list,
+                                             struct osw_conf_mutator *conf_mutator,
+                                             uint64_t *next_at_nsec)
+{
+    ASSERT(action != NULL, "");
+    ASSERT(action->priv != NULL, "");
+
+    unsigned int *cnt = action->priv;
+    *cnt = *cnt + 1;
+    return OW_STEER_EXECUTOR_ACTION_BREAK;
+}
+
+OSW_UT(ow_steer_executor_chain_call)
+{
+    const struct osw_hwaddr sta_addr = {
+        .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA },
+    };
+    struct ow_steer_executor_action_ops continue_ops = {
+        .call_fn = ow_steer_executor_chain_ut_action_call_continue,
+    };
+    struct ow_steer_executor_action_ops break_ops = {
+        .call_fn = ow_steer_executor_chain_ut_action_call_break,
+    };
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_executor_action* action_continue1;
+    struct ow_steer_executor_action* action_continue2;
+    struct ow_steer_executor_action* action_break1;
+    struct ow_steer_executor_chain *executor_chain;
+    struct osw_conf_mutator conf_mutator;
+    unsigned int action_continue1_call_cnt;
+    unsigned int action_continue2_call_cnt;
+    unsigned int action_break1_call_cnt;
+    uint64_t next_at_nsec;
+
+    /*
+     * Setup
+     */
+    candidate_list = ow_steer_candidate_list_new();
+    executor_chain = ow_steer_executor_chain_create();
+    action_continue1 = ow_steer_executor_action_create("action_continue1", &continue_ops, &action_continue1_call_cnt);
+    action_continue2 = ow_steer_executor_action_create("action_continue2", &continue_ops, &action_continue2_call_cnt);
+    action_break1 = ow_steer_executor_action_create("action_break1", &break_ops, &action_break1_call_cnt);
+    action_continue1_call_cnt = 0;
+    action_continue2_call_cnt = 0;
+    action_break1_call_cnt = 0;
+    next_at_nsec = 0;
+
+    /*
+     * Actions:
+     * - action_continue1
+     * - action_continue2
+     */
+    ow_steer_executor_chain_reset(executor_chain);
+
+    ow_steer_executor_chain_append(executor_chain, action_continue1);
+    ow_steer_executor_chain_append(executor_chain, action_continue2);
+    ow_steer_executor_chain_call(executor_chain, &sta_addr, candidate_list, &conf_mutator, &next_at_nsec);
+
+    OSW_UT_EVAL(action_continue1_call_cnt == 1);
+    OSW_UT_EVAL(action_continue2_call_cnt == 1);
+    OSW_UT_EVAL(action_break1_call_cnt == 0);
+    OSW_UT_EVAL(action_break1_call_cnt == 0);
+    OSW_UT_EVAL(next_at_nsec == 0);
+
+    /*
+     * Actions:
+     * - action_continue1
+     * - action_break1
+     * - action_continue2 (it shouldn't be called)
+     */
+    ow_steer_executor_chain_reset(executor_chain);
+
+    ow_steer_executor_chain_append(executor_chain, action_continue1);
+    ow_steer_executor_chain_append(executor_chain, action_break1);
+    ow_steer_executor_chain_append(executor_chain, action_continue2);
+    ow_steer_executor_chain_call(executor_chain, &sta_addr, candidate_list, &conf_mutator, &next_at_nsec);
+
+    OSW_UT_EVAL(action_continue1_call_cnt == 2);
+    OSW_UT_EVAL(action_continue2_call_cnt == 1);
+    OSW_UT_EVAL(action_break1_call_cnt == 1);
+    OSW_UT_EVAL(next_at_nsec == 0);
+
+    /*
+     * Cleanup
+     */
+    ow_steer_executor_chain_free(executor_chain);
+    ow_steer_candidate_list_free(candidate_list);
+}
+
+OSW_UT(ow_steer_executor_chain_mutate)
+{
+    const struct osw_hwaddr sta_addr = {
+        .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA },
+    };
+    struct ow_steer_executor_action_ops continue_ops = {
+        .conf_mutate_fn = ow_steer_executor_chain_ut_action_conf_mutate,
+    };
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_executor_action* action1;
+    struct ow_steer_executor_action* action2;
+    struct ow_steer_executor_chain *executor_chain;
+    struct ds_tree phy_tree;
+    unsigned int action1_mutate_cnt;
+    unsigned int action2_mutate_cnt;
+
+    /*
+     * Setup
+     */
+    candidate_list = ow_steer_candidate_list_new();
+    executor_chain = ow_steer_executor_chain_create();
+    action1 = ow_steer_executor_action_create("action1", &continue_ops, &action1_mutate_cnt);
+    action2 = ow_steer_executor_action_create("action2", &continue_ops, &action2_mutate_cnt);
+    action1_mutate_cnt = 0;
+    action2_mutate_cnt = 0;
+
+    /*
+     * Actions:
+     * - action1
+     * - action2
+     */
+    ow_steer_executor_chain_reset(executor_chain);
+
+    ow_steer_executor_chain_append(executor_chain, action1);
+    ow_steer_executor_chain_append(executor_chain, action2);
+    ow_steer_executor_chain_conf_mutate(executor_chain, &sta_addr, candidate_list, &phy_tree);
+
+    OSW_UT_EVAL(action1_mutate_cnt == 1);
+    OSW_UT_EVAL(action2_mutate_cnt == 1);
+
+    /*
+     * Cleanup
+     */
+    ow_steer_executor_chain_free(executor_chain);
+    ow_steer_candidate_list_free(candidate_list);
+}
Index: core/src/lib/ow/src/ow_steer_executor_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_executor_ut.c
@@ -0,0 +1,123 @@
+#include <osw_ut.h>
+
+struct ow_steer_executor_ut_cnts {
+    unsigned int deauth_kick_success_cnt;
+    unsigned int deauth_kick_fail_cnt;
+};
+
+static struct ow_steer_executor_ut_cnts g_kick_cnts;
+
+static bool
+ow_steer_executor_ut_deauth_success_cb(const char *phy_name,
+                                       const char *vif_name,
+                                       const struct osw_hwaddr *mac_addr,
+                                       int dot11_reason_code)
+{
+    g_kick_cnts.deauth_kick_success_cnt++;
+    return true;
+}
+
+static bool
+ow_steer_executor_ut_deauth_fail_cb(const char *phy_name,
+                                    const char *vif_name,
+                                    const struct osw_hwaddr *mac_addr,
+                                    int dot11_reason_code)
+{
+    g_kick_cnts.deauth_kick_fail_cnt++;
+    return false;
+}
+
+OSW_UT(ow_steer_executor_legacy_kick) {
+    /* See osw_util_ut.c for more details on these assoq req ies */
+    const uint8_t legacy_assoq_req_ies[] = {
+        0x31, 0x04, 0x05, 0x00, 0x00, 0x08, 0x74, 0x65, 0x73, 0x74, 0x2d, 0x73, 0x61, 0x65, 0x01, 0x08,
+        0x02, 0x04, 0x0b, 0x16, 0x0c, 0x12, 0x18, 0x24, 0x32, 0x04, 0x30, 0x48, 0x60, 0x6c, 0x30, 0x14,
+        0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f,
+        0xac, 0x08, 0x00, 0x00, 0x2d, 0x1a, 0x3c, 0x10, 0x1b, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x7f, 0x0a, 0x04, 0x00, 0x02, 0x02, 0x01, 0x40, 0x00, 0x40, 0x00, 0x01, 0x3b, 0x15, 0x51, 0x51,
+        0x52, 0x53, 0x54, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+        0x80, 0x81, 0x82, 0xdd, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00
+    };
+
+    struct osw_hwaddr sta_addr = { .octet = { 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa } };
+    struct osw_drv_vif_state drv_vif_state = {
+        .mac_addr = { .octet = { 0xac, 0x4d, 0x56, 0x53, 0xd2, 0x1b }, },
+        .enabled = true,
+        .vif_type = OSW_VIF_AP,
+    };
+    struct osw_state_phy_info phy = {
+        .phy_name = "phy0",
+    };
+    struct osw_state_vif_info vif = {
+        .vif_name = "vif0",
+        .phy = &phy,
+        .drv_state = &drv_vif_state,
+    };
+    struct osw_state_sta_info sta_info = {
+        .mac_addr = &sta_addr,
+        .vif = &vif,
+        .assoc_req_ies = &legacy_assoq_req_ies,
+        .assoc_req_ies_len = sizeof(legacy_assoq_req_ies),
+    };
+
+    struct ow_steer_candidate_list *candidate_list = ow_steer_candidate_list_new();
+    struct ow_steer_executor *executor = ow_steer_executor_create(&sta_addr, candidate_list);
+    struct ow_steer_candidate *candidate;
+
+    /*
+     * Setup internal bits
+     */
+    osw_ut_time_init();
+    memset(&g_kick_cnts, 0, sizeof(g_kick_cnts));
+
+    OSW_UT_EVAL(executor != NULL);
+
+    /*
+     * Deauth (aka legacy) kick
+     */
+    executor->sta_deauth_fn = ow_steer_executor_ut_deauth_success_cb;
+
+    /* Connect + successfull deauth*/
+    ow_steer_executor_set_sta_info(executor, &sta_info);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_success_cnt == 0);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_fail_cnt == 0);
+
+    /* Mark current BSS as blocked */
+    ow_steer_candidate_list_bss_set(candidate_list, &drv_vif_state.mac_addr);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &drv_vif_state.mac_addr);
+    ow_steer_candidate_set_preference(candidate, OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+
+    ow_steer_executor_recalc(executor);
+    osw_ut_time_advance(0);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_success_cnt == 1);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_fail_cnt == 0);
+
+    /* Disconnect */
+    ow_steer_executor_set_sta_info(executor, NULL);
+
+    /* Recalc, nothing should happen */
+    ow_steer_executor_recalc(executor);
+    osw_ut_time_advance(0);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_success_cnt == 1);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_fail_cnt == 0);
+
+    /* Reconnect + kick fails -> retries */
+    ow_steer_executor_set_sta_info(executor, &sta_info);
+
+    executor->sta_deauth_fn = ow_steer_executor_ut_deauth_fail_cb;
+    ow_steer_executor_recalc(executor);
+    osw_ut_time_advance(0);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_success_cnt == 1);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_fail_cnt == 1);
+
+    ow_steer_executor_recalc(executor);
+    osw_ut_time_advance(OSW_TIME_SEC(OSW_STEER_EXECUTOR_KICK_RETRY_PERIOD_SEC));
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_success_cnt == 1);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_fail_cnt == 2);
+
+    ow_steer_executor_recalc(executor);
+    osw_ut_time_advance(OSW_TIME_SEC(OSW_STEER_EXECUTOR_KICK_RETRY_PERIOD_SEC));
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_success_cnt == 1);
+    OSW_UT_EVAL(g_kick_cnts.deauth_kick_fail_cnt == 3);
+}
Index: core/src/lib/ow/src/ow_steer_policy.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy.c
@@ -0,0 +1,168 @@
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <memutil.h>
+#include <log.h>
+#include <util.h>
+#include <osw_state.h>
+#include <osw_types.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_sta.h"
+#include "ow_steer_policy_stack.h"
+#include "ow_steer_policy_i.h"
+
+struct ow_steer_policy*
+ow_steer_policy_create(const char *name,
+                       unsigned int priority,
+                       const struct osw_hwaddr *sta_addr,
+                       const struct ow_steer_policy_ops *ops,
+                       const struct ow_steer_policy_mediator *mediator,
+                       void *priv)
+{
+    assert(name != NULL);
+    assert(sta_addr != NULL);
+    assert(ops != NULL);
+    assert(mediator != NULL);
+
+    const struct osw_hwaddr wildcard_bssid = OSW_HWADDR_BROADCAST;
+    struct ow_steer_policy *policy = CALLOC(1, sizeof(*policy));
+
+    policy->name = STRDUP(name);
+    policy->priority = priority;
+    memcpy(&policy->sta_addr, sta_addr, sizeof(policy->sta_addr));
+    memcpy(&policy->bssid, &wildcard_bssid, sizeof(policy->bssid));
+    memcpy(&policy->ops, ops, sizeof(policy->ops));
+    memcpy(&policy->mediator, mediator, sizeof(policy->mediator));
+    policy->priv = priv;
+    policy->prefix = strfmt("ow: steer: policy: %s [sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT"]:",
+                            name, OSW_HWADDR_ARG(sta_addr), OSW_HWADDR_ARG(&wildcard_bssid));
+
+    return policy;
+}
+
+void
+ow_steer_policy_free(struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    FREE(policy->name);
+    FREE(policy->prefix);
+    FREE(policy);
+}
+
+void*
+ow_steer_policy_get_priv(struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    return policy->priv;
+}
+
+const struct osw_hwaddr*
+ow_steer_policy_get_sta_addr(const struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    return &policy->sta_addr;
+}
+
+const struct osw_hwaddr*
+ow_steer_policy_get_bssid(const struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    return &policy->bssid;
+}
+
+void
+ow_steer_policy_set_bssid(struct ow_steer_policy *policy,
+                          const struct osw_hwaddr *bssid)
+{
+    assert(policy != NULL);
+    assert(bssid != NULL);
+
+    memcpy(&policy->bssid, bssid, sizeof(policy->bssid));
+
+    FREE(policy->prefix);
+    policy->prefix = strfmt("ow: steer: policy: %s [sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT"]:",
+                            policy->name, OSW_HWADDR_ARG(&policy->sta_addr), OSW_HWADDR_ARG(bssid));
+}
+
+const char*
+ow_steer_policy_get_name(const struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    return policy->name;
+}
+
+const char*
+ow_steer_policy_get_prefix(const struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    return policy->prefix;
+}
+
+void
+ow_steer_policy_set_active(struct ow_steer_policy *policy,
+                           bool active)
+{
+    assert(policy != NULL);
+
+    if (policy->active == active)
+        return;
+
+    policy->active = active;
+    ow_steer_policy_schedule_stack_recalc(policy);
+}
+
+unsigned int
+ow_steer_policy_get_priority(const struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    return policy->priority;
+}
+
+bool
+ow_steer_policy_get_active(const struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+    return policy->active;
+}
+
+void
+ow_steer_policy_schedule_stack_recalc(struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+
+    if (WARN_ON(policy->mediator.sched_recalc_stack_fn == NULL))
+        return;
+
+    policy->mediator.sched_recalc_stack_fn(policy, policy->mediator.priv);
+}
+
+void
+ow_steer_policy_trigger_executor(struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+
+    if (WARN_ON(policy->active == false))
+        return;
+
+    if (policy->mediator.trigger_executor_fn == NULL)
+        return;
+
+    policy->mediator.trigger_executor_fn(policy, policy->mediator.priv);
+}
+
+void
+ow_steer_policy_dismiss_executor(struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+
+    if (WARN_ON(policy->active == false))
+        return;
+
+    if (policy->mediator.dismiss_executor_fn == NULL)
+        return;
+
+    policy->mediator.dismiss_executor_fn(policy, policy->mediator.priv);
+}
+
+#include "ow_steer_policy_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy.h
@@ -0,0 +1,102 @@
+#ifndef OW_STEER_POLICY_H
+#define OW_STEER_POLICY_H
+
+struct ow_steer_policy;
+
+typedef void
+ow_steer_policy_sigusr1_dump_fn_t(struct ow_steer_policy *policy);
+
+typedef void
+ow_steer_policy_recalc_fn_t(struct ow_steer_policy *policy,
+                            struct ow_steer_candidate_list *candidate_list);
+
+typedef void
+ow_steer_policy_sta_connected_fn_t(struct ow_steer_policy *policy,
+                                   const struct osw_state_sta_info *sta_info);
+
+typedef void
+ow_steer_policy_sta_disconnected_fn_t(struct ow_steer_policy *policy,
+                                      const struct osw_state_sta_info *sta_info);
+
+typedef void
+ow_steer_policy_vif_probe_req_t(struct ow_steer_policy *policy,
+                                const struct osw_state_vif_info *vif_info,
+                                const struct osw_drv_report_vif_probe_req *probe_req);
+
+typedef void
+ow_steer_policy_sta_snr_change_fn_t(struct ow_steer_policy *policy,
+                                    const struct osw_hwaddr *bssid,
+                                    uint32_t snr_db);
+
+typedef void
+ow_steer_policy_sta_data_vol_change_fn_t(struct ow_steer_policy *policy,
+                                         const struct osw_hwaddr *bssid,
+                                         uint64_t data_vol_bytes);
+
+typedef void
+ow_steer_policy_mediator_sched_recalc_stack_fn_t(struct ow_steer_policy *policy,
+                                                 void *mediator_priv);
+
+typedef bool
+ow_steer_policy_mediator_trigger_executor_fn_t(struct ow_steer_policy *policy,
+                                               void *mediator_priv);
+
+typedef void
+ow_steer_policy_mediator_dismiss_executor_fn_t(struct ow_steer_policy *policy,
+                                               void *mediator_priv);
+
+struct ow_steer_policy_ops {
+    ow_steer_policy_sigusr1_dump_fn_t *sigusr1_dump_fn;
+    ow_steer_policy_recalc_fn_t *recalc_fn;
+
+    /* osw state observer */
+    ow_steer_policy_sta_connected_fn_t *sta_connected_fn;
+    ow_steer_policy_sta_disconnected_fn_t *sta_disconnected_fn;
+    ow_steer_policy_vif_probe_req_t *vif_probe_req_fn;
+
+    /* osw stats */
+    ow_steer_policy_sta_snr_change_fn_t *sta_snr_change_fn;
+    ow_steer_policy_sta_data_vol_change_fn_t *sta_data_vol_change_fn;
+};
+
+struct ow_steer_policy_mediator {
+    ow_steer_policy_mediator_sched_recalc_stack_fn_t *sched_recalc_stack_fn;
+    ow_steer_policy_mediator_trigger_executor_fn_t *trigger_executor_fn;
+    ow_steer_policy_mediator_dismiss_executor_fn_t *dismiss_executor_fn;
+    void *priv;
+};
+
+struct ow_steer_policy*
+ow_steer_policy_create(const char *name,
+                       unsigned int priority,
+                       const struct osw_hwaddr *sta_addr,
+                       const struct ow_steer_policy_ops *ops,
+                       const struct ow_steer_policy_mediator *mediator,
+                       void *priv);
+
+void
+ow_steer_policy_free(struct ow_steer_policy *policy);
+
+void*
+ow_steer_policy_get_priv(struct ow_steer_policy *policy);
+
+const struct osw_hwaddr*
+ow_steer_policy_get_sta_addr(const struct ow_steer_policy *policy);
+
+const struct osw_hwaddr*
+ow_steer_policy_get_bssid(const struct ow_steer_policy *policy);
+
+void
+ow_steer_policy_set_bssid(struct ow_steer_policy *policy,
+                          const struct osw_hwaddr *bssid);
+
+const char*
+ow_steer_policy_get_name(const struct ow_steer_policy *policy);
+
+unsigned int
+ow_steer_policy_get_priority(const struct ow_steer_policy *policy);
+
+bool
+ow_steer_policy_get_active(const struct ow_steer_policy *policy);
+
+#endif /* OW_STEER_POLICY_H */
Index: core/src/lib/ow/src/ow_steer_policy_band_filter.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_band_filter.c
@@ -0,0 +1,168 @@
+#include <ds_tree.h>
+#include <memutil.h>
+#include <log.h>
+#include <module.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_policy_i.h"
+#include "ow_steer_policy_band_filter.h"
+
+struct ow_steer_policy_band_filter_entry {
+    enum osw_band band;
+    struct ds_tree_node node;
+};
+
+struct ow_steer_policy_band_filter {
+    struct ow_steer_policy *base;
+    struct ds_tree allowed_band_tree;
+};
+
+static const char *g_policy_name = "band_filter";
+
+static void
+ow_steer_policy_band_filter_recalc_cb(struct ow_steer_policy *policy,
+                                      struct ow_steer_candidate_list *candidate_list)
+{
+    assert(policy != NULL);
+    assert(candidate_list != NULL);
+
+    struct ow_steer_policy_band_filter *filter_policy = ow_steer_policy_get_priv(policy);
+    struct ow_steer_policy_band_filter_entry *entry;
+    size_t i = 0;
+
+    LOGD("%s recalc candidates", ow_steer_policy_get_prefix(policy));
+
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        struct ow_steer_candidate *candidate = ow_steer_candidate_list_get(candidate_list, i);
+        const struct osw_hwaddr *candidate_bssid = ow_steer_candidate_get_bssid(candidate);
+        const struct osw_channel *channel = ow_steer_candidate_get_channel(candidate);
+        enum ow_steer_candidate_preference preference = ow_steer_candidate_get_preference(candidate);
+        enum osw_band band = osw_freq_to_band(channel->control_freq_mhz);
+        bool allowed = false;
+
+        if (WARN_ON(band == OSW_BAND_UNDEFINED))
+            goto decision;
+
+        if (preference != OW_STEER_CANDIDATE_PREFERENCE_NONE) {
+            allowed = true;
+            goto decision;
+        }
+
+        entry = ds_tree_find(&filter_policy->allowed_band_tree, &band);
+        if (entry != NULL) {
+            allowed = true;
+            goto decision;
+        }
+
+        decision:
+            if (allowed == false)
+                ow_steer_candidate_set_preference(candidate, OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+            preference = ow_steer_candidate_get_preference(candidate);
+            LOGD("%s bandid: "OSW_HWADDR_FMT" band: %s preference: %s", ow_steer_policy_get_prefix(policy),
+                 OSW_HWADDR_ARG(candidate_bssid), osw_band_to_str(band),
+                 ow_steer_candidate_preference_to_cstr(preference));
+     }
+}
+
+static void
+ow_steer_policy_band_filter_sigusr1_dump_cb(struct ow_steer_policy *policy)
+{
+    ASSERT(policy != NULL, "");
+
+    struct ow_steer_policy_band_filter *filter_policy = ow_steer_policy_get_priv(policy);
+    struct ow_steer_policy_band_filter_entry *entry;
+
+    ds_tree_foreach(&filter_policy->allowed_band_tree, entry)
+        LOGI("ow: steer:           allowed band: %s", osw_band_to_str(entry->band));
+}
+
+struct ow_steer_policy_band_filter*
+ow_steer_policy_band_filter_create(unsigned int priority,
+                                  const struct osw_hwaddr *sta_addr,
+                                  const struct ow_steer_policy_mediator *mediator)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(mediator != NULL, "");
+
+    const struct ow_steer_policy_ops ops = {
+        .sigusr1_dump_fn = ow_steer_policy_band_filter_sigusr1_dump_cb,
+        .recalc_fn = ow_steer_policy_band_filter_recalc_cb,
+    };
+
+    struct ow_steer_policy_band_filter *filter_policy = CALLOC(1, sizeof(*filter_policy));
+    filter_policy->base = ow_steer_policy_create(g_policy_name, priority, sta_addr, &ops, mediator, filter_policy);
+    ds_tree_init(&filter_policy->allowed_band_tree, (ds_key_cmp_t*) ds_int_cmp, struct ow_steer_policy_band_filter_entry, node);
+
+    /*
+     * FIXME
+     * Silently (wihout policy stack recalc) activate policy.
+     */
+    filter_policy->base->active = true;
+
+    return filter_policy;
+}
+
+void
+ow_steer_policy_band_filter_allow_band(struct ow_steer_policy_band_filter *filter_policy,
+                                       enum osw_band band)
+{
+    ASSERT(filter_policy != NULL, "");
+    ASSERT(band != OSW_BAND_UNDEFINED, "");
+
+    struct ow_steer_policy_band_filter_entry *entry;
+
+    if (ds_tree_find(&filter_policy->allowed_band_tree, &band) != NULL)
+        return;
+
+    entry = CALLOC(1, sizeof(*entry));
+    entry->band = band;
+    ds_tree_insert(&filter_policy->allowed_band_tree, entry, &entry->band);
+
+    ow_steer_policy_schedule_stack_recalc(filter_policy->base);
+}
+
+void
+ow_steer_policy_band_filter_clear(struct ow_steer_policy_band_filter *filter_policy)
+{
+    ASSERT(filter_policy != NULL, "");
+
+    struct ow_steer_policy_band_filter_entry *entry;
+    struct ow_steer_policy_band_filter_entry *tmp;
+
+    ds_tree_foreach_safe(&filter_policy->allowed_band_tree, entry, tmp) {
+        ds_tree_remove(&filter_policy->allowed_band_tree, entry);
+        FREE(entry);
+    }
+
+    ow_steer_policy_schedule_stack_recalc(filter_policy->base);
+}
+
+void
+ow_steer_policy_band_filter_free(struct ow_steer_policy_band_filter *filter_policy)
+{
+    ASSERT(filter_policy != NULL, "");
+
+    struct ow_steer_policy_band_filter_entry *entry;
+    struct ow_steer_policy_band_filter_entry *tmp;
+
+    ds_tree_foreach_safe(&filter_policy->allowed_band_tree, entry, tmp) {
+        ds_tree_remove(&filter_policy->allowed_band_tree, entry);
+        FREE(entry);
+    }
+
+    ow_steer_policy_free(filter_policy->base);
+    FREE(filter_policy);
+}
+
+struct ow_steer_policy*
+ow_steer_policy_band_filter_get_base(struct ow_steer_policy_band_filter *filter_policy)
+{
+    ASSERT(filter_policy != NULL, "");
+    return filter_policy->base;
+}
+
+#include "ow_steer_policy_band_filter_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_band_filter.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_band_filter.h
@@ -0,0 +1,24 @@
+#ifndef OW_STEER_POLICY_BAND_FILTER_H
+#define OW_STEER_POLICY_BAND_FILTER_H
+
+struct ow_steer_policy_band_filter;
+
+struct ow_steer_policy_band_filter*
+ow_steer_policy_band_filter_create(unsigned int priority,
+                                   const struct osw_hwaddr *sta_addr,
+                                   const struct ow_steer_policy_mediator *mediator);
+
+void
+ow_steer_policy_band_filter_allow_band(struct ow_steer_policy_band_filter *filter_policy,
+                                       enum osw_band band);
+
+void
+ow_steer_policy_band_filter_clear(struct ow_steer_policy_band_filter *filter_policy);
+
+void
+ow_steer_policy_band_filter_free(struct ow_steer_policy_band_filter *filter_policy);
+
+struct ow_steer_policy*
+ow_steer_policy_band_filter_get_base(struct ow_steer_policy_band_filter *filter_policy);
+
+#endif /* OW_STEER_POLICY_BAND_FILTER_H */
Index: core/src/lib/ow/src/ow_steer_policy_band_filter_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_band_filter_ut.c
@@ -0,0 +1,93 @@
+#include <osw_ut.h>
+#include "ow_steer_policy_i.h"
+
+static void
+ow_steer_policy_band_filter_ut_mediator_sched_stack_recalc(struct ow_steer_policy *policy,
+                                                          void *priv)
+{
+    OSW_UT_EVAL(priv != NULL);
+    unsigned int *cnt = priv;
+    *cnt = *cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_band_filter_ut_typical_case)
+{
+    const struct osw_hwaddr bssid_2g = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA }, };
+    const struct osw_hwaddr bssid_5g = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB }, };
+    const struct osw_hwaddr bssid_6g = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC }, };
+    const struct osw_hwaddr addr = { .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD }, };
+    const struct osw_channel channel_2g = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct osw_channel channel_5g = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 5745, };
+    const struct osw_channel channel_6g = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 5995, };
+    struct ow_steer_policy_band_filter *filter_policy = NULL;
+    struct ow_steer_candidate_list *candidate_list = NULL;
+    unsigned int schedule_recalc_cnt = 0;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_band_filter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_2g, &channel_2g);
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_5g, &channel_5g);
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_6g, &channel_6g);
+
+    filter_policy = ow_steer_policy_band_filter_create(0, &addr, &mediator);
+    OSW_UT_EVAL(filter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    /* Block all bands by default */
+    ow_steer_candidate_list_clear(candidate_list);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_2g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_5g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_6g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+    /* Only 5 GHz passes through policy */
+    ow_steer_candidate_list_clear(candidate_list);
+    ow_steer_policy_band_filter_allow_band(filter_policy, OSW_BAND_5GHZ);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_2g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_5g)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_6g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+    /* Allowing 5 GHz band again shiuldn't have any effect */
+    ow_steer_candidate_list_clear(candidate_list);
+    ow_steer_policy_band_filter_allow_band(filter_policy, OSW_BAND_5GHZ);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_2g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_5g)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_6g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+    /* Add 6 GHz to to allowed bands set */
+    ow_steer_candidate_list_clear(candidate_list);
+    ow_steer_policy_band_filter_allow_band(filter_policy, OSW_BAND_6GHZ);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_2g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_5g)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_6g)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* All bands are filtered out by policy */
+    ow_steer_candidate_list_clear(candidate_list);
+    ow_steer_policy_band_filter_clear(filter_policy);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_2g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_5g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_6g)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+}
Index: core/src/lib/ow/src/ow_steer_policy_bss_filter.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_bss_filter.c
@@ -0,0 +1,234 @@
+#include <ds_tree.h>
+#include <memutil.h>
+#include <log.h>
+#include <module.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_policy_i.h"
+#include "ow_steer_policy_bss_filter.h"
+
+struct ow_steer_policy_bss_filter {
+    struct ow_steer_policy *base;
+    struct ow_steer_policy_bss_filter_config *config;
+};
+
+static const char *g_policy_name = "bss_filter";
+
+static void
+ow_steer_policy_bss_filter_reset(struct ow_steer_policy_bss_filter *filter_policy)
+{
+    ASSERT(filter_policy != NULL, "");
+
+    ow_steer_policy_bss_filter_config_free(filter_policy->config);
+    filter_policy->config = NULL;
+
+    ow_steer_policy_schedule_stack_recalc(filter_policy->base);
+}
+
+static bool
+ow_steer_policy_bss_filter_config_lookup_bssid(const struct ow_steer_policy_bss_filter_config *config,
+                                               const struct osw_hwaddr *bssid)
+{
+    ASSERT(config != NULL, "");
+    ASSERT(bssid != NULL, "");
+
+    size_t i;
+    for (i = 0; i < config->bssid_num; i++)
+        if (osw_hwaddr_cmp(&config->bssid[i], bssid) == 0)
+            return true;
+
+    return false;
+}
+
+static void
+ow_steer_policy_bss_filter_recalc_cb(struct ow_steer_policy *policy,
+                                     struct ow_steer_candidate_list *candidate_list)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(candidate_list != NULL, "");
+
+    struct ow_steer_policy_bss_filter *filter_policy = ow_steer_policy_get_priv(policy);
+    size_t i = 0;
+
+    LOGD("%s recalc candidates", ow_steer_policy_get_prefix(policy));
+
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        struct ow_steer_candidate *candidate = ow_steer_candidate_list_get(candidate_list, i);
+        const struct osw_hwaddr *candidate_bssid = ow_steer_candidate_get_bssid(candidate);
+
+        enum ow_steer_candidate_preference preference = ow_steer_candidate_get_preference(candidate);
+        if (preference != OW_STEER_CANDIDATE_PREFERENCE_NONE)
+            continue;
+
+        if (filter_policy->config != NULL)
+            if (ow_steer_policy_bss_filter_config_lookup_bssid(filter_policy->config, candidate_bssid) == true)
+                continue;
+
+        ow_steer_candidate_set_preference(candidate, OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+        preference = ow_steer_candidate_get_preference(candidate);
+        LOGD("%s bssid: "OSW_HWADDR_FMT" preference: %s", ow_steer_policy_get_prefix(policy),
+             OSW_HWADDR_ARG(candidate_bssid), ow_steer_candidate_preference_to_cstr(preference));
+     }
+}
+
+static void
+ow_steer_policy_bss_filter_sigusr1_dump_cb(struct ow_steer_policy *policy)
+{
+    ASSERT(policy != NULL, "");
+
+    struct ow_steer_policy_bss_filter *filter_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_bss_filter_config *config = filter_policy->config;
+
+    if (config == NULL)
+        return;
+
+    size_t i;
+    for (i = 0; i < config->bssid_num; i++)
+        LOGI("ow: steer:           allowed bssid: "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&config->bssid[i]));
+}
+
+struct ow_steer_policy_bss_filter*
+ow_steer_policy_bss_filter_create(unsigned int priority,
+                                  const struct osw_hwaddr *sta_addr,
+                                  const struct ow_steer_policy_mediator *mediator)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(mediator != NULL, "");
+
+    const struct ow_steer_policy_ops ops = {
+        .sigusr1_dump_fn = ow_steer_policy_bss_filter_sigusr1_dump_cb,
+        .recalc_fn = ow_steer_policy_bss_filter_recalc_cb,
+    };
+
+    struct ow_steer_policy_bss_filter *filter_policy = CALLOC(1, sizeof(*filter_policy));
+    filter_policy->base = ow_steer_policy_create(g_policy_name, priority, sta_addr, &ops, mediator, filter_policy);
+
+    /*
+     * FIXME
+     * Silently (wihout policy stack recalc) activate policy.
+     */
+    filter_policy->base->active = true;
+
+    return filter_policy;
+}
+
+void
+ow_steer_policy_bss_filter_set_config(struct ow_steer_policy_bss_filter *filter_policy,
+                                      struct ow_steer_policy_bss_filter_config *config)
+{
+    ASSERT(filter_policy != NULL, "");
+
+    if (config == NULL) {
+        ow_steer_policy_bss_filter_reset(filter_policy);
+        return;
+    }
+
+    ASSERT(config->bssid_num > 0, "");
+    if (filter_policy->config == NULL) {
+        filter_policy->config = config;
+        ow_steer_policy_schedule_stack_recalc(filter_policy->base);
+        return;
+    }
+
+    if (filter_policy->config->bssid_num == config->bssid_num &&
+        memcmp(filter_policy->config->bssid, config->bssid, sizeof(*config->bssid) * config->bssid_num) == 0)
+    {
+        ow_steer_policy_bss_filter_config_free(config);
+        return;
+    }
+
+    ow_steer_policy_bss_filter_config_free(filter_policy->config);
+    filter_policy->config = config;
+
+    ow_steer_policy_schedule_stack_recalc(filter_policy->base);
+}
+
+void
+ow_steer_policy_bss_filter_free(struct ow_steer_policy_bss_filter *filter_policy)
+{
+    ASSERT(filter_policy != NULL, "");
+
+    ow_steer_policy_bss_filter_config_free(filter_policy->config);
+    ow_steer_policy_free(filter_policy->base);
+    FREE(filter_policy);
+}
+
+struct ow_steer_policy*
+ow_steer_policy_bss_filter_get_base(struct ow_steer_policy_bss_filter *filter_policy)
+{
+    ASSERT(filter_policy != NULL, "");
+    return filter_policy->base;
+}
+
+struct ow_steer_policy_bss_filter_config*
+ow_steer_policy_bss_filter_config_create(void)
+{
+    return CALLOC(1, sizeof(struct ow_steer_policy_bss_filter_config));
+}
+
+void
+ow_steer_policy_bss_filter_config_add(struct ow_steer_policy_bss_filter_config *config,
+                                      const struct osw_hwaddr* bssid)
+{
+    ASSERT(config != NULL, "");
+    ASSERT(bssid != NULL, "");
+
+    const size_t new_bssid_num = config->bssid_num + 1;
+    struct osw_hwaddr* new_bssid = CALLOC(new_bssid_num, sizeof(*config->bssid));
+
+    size_t i;
+    for (i = 0; i < config->bssid_num; i++) {
+        const int result = osw_hwaddr_cmp(&config->bssid[i], bssid);
+        if (result < 0)
+            memcpy(&new_bssid[i], &config->bssid[i], sizeof(*bssid));
+        else if (result == 0)
+            goto drop_new_bssid;
+        else
+            break;
+    }
+
+    size_t j = i;
+    memcpy(&new_bssid[j], bssid, sizeof(*bssid));
+
+    for (j = j + 1; j < new_bssid_num; j++, i++)
+        memcpy(&new_bssid[j], &config->bssid[i], sizeof(*bssid));
+
+    FREE(config->bssid);
+    config->bssid = new_bssid;
+    config->bssid_num = new_bssid_num;
+
+    return;
+
+drop_new_bssid:
+    FREE(new_bssid);
+    return;
+}
+
+bool
+ow_steer_policy_bss_filter_config_cmp(const struct ow_steer_policy_bss_filter_config *a,
+                                      const struct ow_steer_policy_bss_filter_config *b)
+{
+    ASSERT(a != NULL, "");
+    ASSERT(b != NULL, "");
+
+    if (a->bssid_num != b->bssid_num)
+        return false;
+
+    return memcmp(a->bssid, b->bssid, a->bssid_num * sizeof(*a->bssid)) == 0;
+}
+
+void
+ow_steer_policy_bss_filter_config_free(struct ow_steer_policy_bss_filter_config *config)
+{
+    if (config == NULL)
+        return;
+
+    FREE(config->bssid);
+    FREE(config);
+}
+
+#include "ow_steer_policy_bss_filter_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_bss_filter.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_bss_filter.h
@@ -0,0 +1,41 @@
+#ifndef OW_STEER_POLICY_BSS_FILTER_H
+#define OW_STEER_POLICY_BSS_FILTER_H
+
+struct ow_steer_policy_bss_filter_config {
+    /* Whitelist */
+    struct osw_hwaddr *bssid;
+    size_t bssid_num;
+};
+
+struct ow_steer_policy_bss_filter;
+
+struct ow_steer_policy_bss_filter*
+ow_steer_policy_bss_filter_create(unsigned int priority,
+                                  const struct osw_hwaddr *sta_addr,
+                                  const struct ow_steer_policy_mediator *mediator);
+
+void
+ow_steer_policy_bss_filter_set_config(struct ow_steer_policy_bss_filter *filter_policy,
+                                      struct ow_steer_policy_bss_filter_config *config);
+
+void
+ow_steer_policy_bss_filter_free(struct ow_steer_policy_bss_filter *filter_policy);
+
+struct ow_steer_policy*
+ow_steer_policy_bss_filter_get_base(struct ow_steer_policy_bss_filter *filter_policy);
+
+struct ow_steer_policy_bss_filter_config*
+ow_steer_policy_bss_filter_config_create(void);
+
+void
+ow_steer_policy_bss_filter_config_add(struct ow_steer_policy_bss_filter_config *config,
+                                      const struct osw_hwaddr* bssid);
+
+bool
+ow_steer_policy_bss_filter_config_cmp(const struct ow_steer_policy_bss_filter_config *a,
+                                      const struct ow_steer_policy_bss_filter_config *b);
+
+void
+ow_steer_policy_bss_filter_config_free(struct ow_steer_policy_bss_filter_config *config);
+
+#endif /* OW_STEER_POLICY_BSS_FILTER_H */
Index: core/src/lib/ow/src/ow_steer_policy_bss_filter_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_bss_filter_ut.c
@@ -0,0 +1,246 @@
+#include <osw_ut.h>
+#include "ow_steer_policy_i.h"
+
+static void
+ow_steer_policy_bss_filter_ut_mediator_sched_stack_recalc(struct ow_steer_policy *policy,
+                                                          void *priv)
+{
+    OSW_UT_EVAL(priv != NULL);
+    unsigned int *cnt = priv;
+    *cnt = *cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_bss_filter_config_ut_fill)
+{
+    const struct osw_hwaddr addr_a = { .octet = { 0xa } };
+    const struct osw_hwaddr addr_b = { .octet = { 0xb } };
+    const struct osw_hwaddr addr_c = { .octet = { 0xc } };
+    const struct osw_hwaddr addr_d = { .octet = { 0xd } };
+    const struct osw_hwaddr addr_e = { .octet = { 0xe } };
+    struct ow_steer_policy_bss_filter_config *config = NULL;
+
+    config = ow_steer_policy_bss_filter_config_create();
+    OSW_UT_EVAL(config != NULL);
+
+    /* Expected order: addr_b */
+    ow_steer_policy_bss_filter_config_add(config, &addr_b);
+
+    OSW_UT_EVAL(config->bssid != NULL);
+    OSW_UT_EVAL(config->bssid_num == 1);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[0], &addr_b) == 0);
+
+    /* Expected order: addr_b, addr_d */
+    ow_steer_policy_bss_filter_config_add(config, &addr_d);
+
+    OSW_UT_EVAL(config->bssid != NULL);
+    OSW_UT_EVAL(config->bssid_num == 2);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[0], &addr_b) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[1], &addr_d) == 0);
+
+    /* Expected order: addr_b, addr_c, addr_d */
+    ow_steer_policy_bss_filter_config_add(config, &addr_c);
+
+    OSW_UT_EVAL(config->bssid != NULL);
+    OSW_UT_EVAL(config->bssid_num == 3);
+    LOGI(OSW_HWADDR_FMT, OSW_HWADDR_ARG(&config->bssid[0]));
+    LOGI(OSW_HWADDR_FMT, OSW_HWADDR_ARG(&config->bssid[1]));
+    LOGI(OSW_HWADDR_FMT, OSW_HWADDR_ARG(&config->bssid[2]));
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[0], &addr_b) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[1], &addr_c) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[2], &addr_d) == 0);
+
+    /* Expected order: addr_a, addr_b, addr_c, addr_d */
+    ow_steer_policy_bss_filter_config_add(config, &addr_a);
+
+    OSW_UT_EVAL(config->bssid != NULL);
+    OSW_UT_EVAL(config->bssid_num == 4);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[0], &addr_a) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[1], &addr_b) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[2], &addr_c) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[3], &addr_d) == 0);
+
+    /* Expected order: addr_a, addr_b, addr_c, addr_d, addr_e */
+    ow_steer_policy_bss_filter_config_add(config, &addr_e);
+
+    OSW_UT_EVAL(config->bssid != NULL);
+    OSW_UT_EVAL(config->bssid_num == 5);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[0], &addr_a) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[1], &addr_b) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[2], &addr_c) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[3], &addr_d) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[4], &addr_e) == 0);
+
+    /* Re-add all addresses, expect no changes */
+    ow_steer_policy_bss_filter_config_add(config, &addr_a);
+    ow_steer_policy_bss_filter_config_add(config, &addr_b);
+    ow_steer_policy_bss_filter_config_add(config, &addr_c);
+    ow_steer_policy_bss_filter_config_add(config, &addr_d);
+    ow_steer_policy_bss_filter_config_add(config, &addr_e);
+
+    OSW_UT_EVAL(config->bssid != NULL);
+    OSW_UT_EVAL(config->bssid_num == 5);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[0], &addr_a) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[1], &addr_b) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[2], &addr_c) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[3], &addr_d) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(&config->bssid[4], &addr_e) == 0);
+
+    ow_steer_policy_bss_filter_config_free(config);
+}
+
+OSW_UT(ow_steer_policy_bss_filter_config_ut_cmp)
+{
+    const struct osw_hwaddr addr_a = { .octet = { 0xa } };
+    const struct osw_hwaddr addr_b = { .octet = { 0xb } };
+    const struct osw_hwaddr addr_c = { .octet = { 0xc } };
+    const struct osw_hwaddr addr_d = { .octet = { 0xd } };
+
+    struct ow_steer_policy_bss_filter_config *config_a = NULL;
+    struct ow_steer_policy_bss_filter_config *config_b = NULL;
+    struct ow_steer_policy_bss_filter_config *config_c = NULL;
+    struct ow_steer_policy_bss_filter_config *config_d = NULL;
+
+    config_a = ow_steer_policy_bss_filter_config_create();
+    config_b = ow_steer_policy_bss_filter_config_create();
+    config_c = ow_steer_policy_bss_filter_config_create();
+    config_d = ow_steer_policy_bss_filter_config_create();
+
+    /* Fill configs, A & B are the same */
+    ow_steer_policy_bss_filter_config_add(config_a, &addr_a);
+    ow_steer_policy_bss_filter_config_add(config_a, &addr_b);
+    ow_steer_policy_bss_filter_config_add(config_a, &addr_c);
+
+    ow_steer_policy_bss_filter_config_add(config_b, &addr_a);
+    ow_steer_policy_bss_filter_config_add(config_b, &addr_b);
+    ow_steer_policy_bss_filter_config_add(config_b, &addr_c);
+
+    ow_steer_policy_bss_filter_config_add(config_c, &addr_a);
+    ow_steer_policy_bss_filter_config_add(config_c, &addr_b);
+
+    ow_steer_policy_bss_filter_config_add(config_d, &addr_b);
+    ow_steer_policy_bss_filter_config_add(config_d, &addr_c);
+    ow_steer_policy_bss_filter_config_add(config_d, &addr_d);
+
+    /* Compare (all cases) */
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_a, config_a) == true);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_a, config_b) == true);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_a, config_c) == false);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_a, config_d) == false);
+
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_b, config_a) == true);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_b, config_b) == true);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_b, config_c) == false);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_b, config_d) == false);
+
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_c, config_a) == false);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_c, config_b) == false);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_c, config_c) == true);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_c, config_d) == false);
+
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_d, config_a) == false);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_d, config_b) == false);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_d, config_c) == false);
+    OSW_UT_EVAL(ow_steer_policy_bss_filter_config_cmp(config_d, config_d) == true);
+
+    ow_steer_policy_bss_filter_config_free(config_a);
+    ow_steer_policy_bss_filter_config_free(config_b);
+    ow_steer_policy_bss_filter_config_free(config_c);
+    ow_steer_policy_bss_filter_config_free(config_d);
+}
+
+OSW_UT(ow_steer_policy_bss_filter_ut_typical_case)
+{
+    const struct osw_hwaddr bssid_a = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA }, };
+    const struct osw_hwaddr bssid_b = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB }, };
+    const struct osw_hwaddr bssid_c = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC }, };
+    const struct osw_hwaddr addr = { .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD }, };
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    struct ow_steer_policy_bss_filter_config *config = NULL;
+    struct ow_steer_policy_bss_filter *filter_policy = NULL;
+    struct ow_steer_candidate_list *candidate_list = NULL;
+    unsigned int schedule_recalc_cnt = 0;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_bss_filter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_a, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_b, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_c, &channel);
+
+    filter_policy = ow_steer_policy_bss_filter_create(0, &addr, &mediator);
+    OSW_UT_EVAL(filter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    /* Block all BSSIDs by default */
+    ow_steer_candidate_list_clear(candidate_list);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+    /* Only BSS B passes through policy */
+    ow_steer_candidate_list_clear(candidate_list);
+    config = CALLOC(1, sizeof(*config));
+    config->bssid = CALLOC(1, sizeof(*config->bssid));
+    config->bssid_num = 1;
+    memcpy(&config->bssid[0], &bssid_b, sizeof(*config->bssid));
+    ow_steer_policy_bss_filter_set_config(filter_policy, config);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+    /* Allowing BSS B again shiuldn't have any effect */
+    ow_steer_candidate_list_clear(candidate_list);
+
+    config = CALLOC(1, sizeof(*config));
+    config->bssid = CALLOC(1, sizeof(*config->bssid));
+    config->bssid_num = 1;
+    memcpy(&config->bssid[0], &bssid_b, sizeof(*config->bssid));
+    ow_steer_policy_bss_filter_set_config(filter_policy, config);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+    /* Allow BSS A and B */
+    ow_steer_candidate_list_clear(candidate_list);
+
+    config = CALLOC(1, sizeof(*config));
+    config->bssid = CALLOC(2, sizeof(*config->bssid));
+    config->bssid_num = 2;
+    memcpy(&config->bssid[0], &bssid_a, sizeof(*config->bssid));
+    memcpy(&config->bssid[1], &bssid_b, sizeof(*config->bssid));
+    ow_steer_policy_bss_filter_set_config(filter_policy, config);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+
+    /* All BSSIDs are filtered out by policy */
+    ow_steer_candidate_list_clear(candidate_list);
+
+    ow_steer_policy_bss_filter_set_config(filter_policy, NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+
+    filter_policy->base->ops.recalc_fn(filter_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_a)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_b)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(ow_steer_candidate_list_lookup(candidate_list, &bssid_c)) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+}
Index: core/src/lib/ow/src/ow_steer_policy_directed_away.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_directed_away.c
@@ -0,0 +1,164 @@
+#include <log.h>
+#include <util.h>
+#include <const.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_state.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_policy_directed_away.h"
+
+struct ow_steer_policy_directed_away_state {
+    struct osw_timer enforce_timer;
+};
+
+struct ow_steer_policy_directed_away {
+    struct ow_steer_policy *base;
+    struct ow_steer_policy_directed_away_config config;
+    struct ow_steer_policy_directed_away_state state;
+};
+
+static const char *g_policy_name = "ow_steer_policy_directed_away";
+
+static void
+ow_steer_policy_directed_away_enforce_timer_sb(struct osw_timer *timer)
+{
+    assert(timer != NULL);
+
+    struct ow_steer_policy_directed_away_state *state = container_of(timer, struct ow_steer_policy_directed_away_state, enforce_timer);
+    struct ow_steer_policy_directed_away *away_policy = container_of(state, struct ow_steer_policy_directed_away, state);
+
+    LOGI("%s enforce period finished", ow_steer_policy_get_prefix(away_policy->base));
+    ow_steer_policy_schedule_stack_recalc(away_policy->base);
+}
+
+static void
+ow_steer_policy_directed_away_recalc_cb(struct ow_steer_policy *policy,
+                                        struct ow_steer_candidate_list *candidate_list)
+{
+    assert(policy != NULL);
+    assert(candidate_list != NULL);
+
+    struct ow_steer_policy_directed_away *away_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_directed_away_state *state = &away_policy->state;
+    size_t i = 0;
+
+    if (osw_timer_is_armed(&state->enforce_timer) == false)
+        return;
+
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        struct ow_steer_candidate *candidate = ow_steer_candidate_list_get(candidate_list, i);
+        const struct osw_hwaddr *candidate_bssid = ow_steer_candidate_get_bssid(candidate);
+        const enum ow_steer_candidate_preference candidate_preference = ow_steer_candidate_get_preference(candidate);
+
+        switch (candidate_preference) {
+            case OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE:
+            case OW_STEER_CANDIDATE_PREFERENCE_BLOCKED:
+                break;
+            case OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE:
+                LOGW("%s bssid: "OSW_HWADDR_FMT" preference: %s cannot override preference and set to blocked",
+                     ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(candidate_bssid),
+                     ow_steer_candidate_preference_to_cstr(ow_steer_candidate_get_preference(candidate)));
+                break;
+            case OW_STEER_CANDIDATE_PREFERENCE_NONE:
+                ow_steer_candidate_set_preference(candidate, OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+                LOGD("%s bssid: "OSW_HWADDR_FMT" preference: %s",
+                     ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(candidate_bssid),
+                     ow_steer_candidate_preference_to_cstr(ow_steer_candidate_get_preference(candidate)));
+                break;
+        }
+    }
+}
+
+static void
+ow_steer_policy_directed_away_sigusr1_dump_cb(struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+
+    struct ow_steer_policy_directed_away *away_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_directed_away_config *config = &away_policy->config;
+    const struct ow_steer_policy_directed_away_state *state = &away_policy->state;
+    const uint64_t now_nsec = osw_time_mono_clk();
+    const char *enforce_timer_buf = NULL;
+
+    LOGI("ow: steer:           config:");
+    LOGI("ow: steer:             enforce_sec: %u", config->enforce_sec);
+
+    enforce_timer_buf = osw_timer_is_armed(&state->enforce_timer) == true ?
+        strfmta("%.2lf sec remaining", OSW_TIME_TO_DBL(osw_timer_get_remaining_nsec(&state->enforce_timer, now_nsec))) : "inactive";
+
+    LOGI("ow: steer:           state:");
+    LOGI("ow: steer:             enforce_timer: %s", enforce_timer_buf);
+}
+
+struct ow_steer_policy_directed_away*
+ow_steer_policy_directed_away_create(unsigned int priority,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct ow_steer_policy_mediator *mediator)
+{
+    assert(sta_addr != NULL);
+    assert(mediator != NULL);
+
+    const struct ow_steer_policy_ops ops = {
+        .sigusr1_dump_fn = ow_steer_policy_directed_away_sigusr1_dump_cb,
+        .recalc_fn = ow_steer_policy_directed_away_recalc_cb,
+    };
+
+    struct ow_steer_policy_directed_away *away_policy = CALLOC(1, sizeof(*away_policy));
+
+    away_policy->base = ow_steer_policy_create(g_policy_name, priority, sta_addr, &ops, mediator, away_policy);
+    osw_timer_init(&away_policy->state.enforce_timer, ow_steer_policy_directed_away_enforce_timer_sb);
+
+    return away_policy;
+}
+
+void
+ow_steer_policy_directed_away_free(struct ow_steer_policy_directed_away *away_policy)
+{
+    assert(away_policy != NULL);
+
+    ow_steer_policy_free(away_policy->base);
+    osw_timer_disarm(&away_policy->state.enforce_timer);
+    FREE(away_policy);
+}
+
+struct ow_steer_policy*
+ow_steer_policy_directed_away_get_base(struct ow_steer_policy_directed_away *away_policy)
+{
+    assert(away_policy != NULL);
+    return away_policy->base;
+}
+
+void
+ow_steer_policy_directed_away_set_config(struct ow_steer_policy_directed_away *away_policy,
+                                         const struct ow_steer_policy_directed_away_config *config)
+{
+    assert(away_policy != NULL);
+
+    const uint64_t tstamp_nsec = osw_time_mono_clk() + OSW_TIME_SEC(away_policy->config.enforce_sec);
+    struct ow_steer_policy_directed_away_state *state = &away_policy->state;
+
+    if (config != NULL && memcmp(&away_policy->config, config, sizeof(away_policy->config)) == 0)
+        return;
+
+    LOGI("%s config changed", ow_steer_policy_get_prefix(away_policy->base));
+
+    if (config != NULL)
+        memcpy(&away_policy->config, config, sizeof(away_policy->config));
+
+    if (osw_timer_is_armed(&state->enforce_timer) == true) {
+        osw_timer_disarm(&state->enforce_timer);
+        LOGI("%s stop enforce timer", ow_steer_policy_get_prefix(away_policy->base));
+    }
+
+    osw_timer_arm_at_nsec(&state->enforce_timer, tstamp_nsec);
+    LOGI("%s start enforce timer, duration: %u seconds", ow_steer_policy_get_prefix(away_policy->base),
+         away_policy->config.enforce_sec);
+
+    ow_steer_policy_set_active(away_policy->base, config != NULL);
+}
+
+#include "ow_steer_policy_directed_away_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_directed_away.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_directed_away.h
@@ -0,0 +1,25 @@
+#ifndef OW_STEER_POLICY_DIRECTED_AWAY_H
+#define OW_STEER_POLICY_DIRECTED_AWAY_H
+
+struct ow_steer_policy_directed_away_config {
+    unsigned int enforce_sec;
+};
+
+struct ow_steer_policy_directed_away;
+
+struct ow_steer_policy_directed_away*
+ow_steer_policy_directed_away_create(unsigned int priority,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct ow_steer_policy_mediator *mediator);
+
+void
+ow_steer_policy_directed_away_free(struct ow_steer_policy_directed_away *away_policy);
+
+struct ow_steer_policy*
+ow_steer_policy_directed_away_get_base(struct ow_steer_policy_directed_away *away_policy);
+
+void
+ow_steer_policy_directed_away_set_config(struct ow_steer_policy_directed_away *away_policy,
+                                         const struct ow_steer_policy_directed_away_config *config);
+
+#endif /* OW_STEER_POLICY_DIRECTED_AWAY_H */
Index: core/src/lib/ow/src/ow_steer_policy_directed_away_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_directed_away_ut.c
@@ -0,0 +1,96 @@
+#include <ds_tree.h>
+#include <osw_bss_map.h>
+#include <osw_time.h>
+#include <osw_ut.h>
+#include "ow_steer_policy_i.h"
+#include "ow_steer_sta_i.h"
+
+static void
+ow_steer_policy_directed_away_ut_mediator_sched_stack_recalc(struct ow_steer_policy *policy,
+                                                             void *priv)
+{
+    OSW_UT_EVAL(priv != NULL);
+    unsigned int *cnt = priv;
+    *cnt = *cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_directed_away) {
+    struct osw_hwaddr vif0_addr = {
+        .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, },
+    };
+    struct osw_hwaddr vif1_addr = {
+        .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, },
+    };
+    struct osw_hwaddr vif2_addr = {
+        .octet = { 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, },
+    };
+    struct osw_hwaddr sta_addr = {
+        .octet = { 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF },
+    };
+    struct ow_steer_policy_directed_away_config config = {
+        .enforce_sec = 60,
+    };
+    const struct osw_channel channel = {
+        .width = OSW_CHANNEL_20MHZ,
+        .control_freq_mhz = 2412,
+    };
+
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_candidate *candidate;
+    struct ow_steer_policy_directed_away *away_policy;
+    unsigned int schedule_recalc_cnt;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_directed_away_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+
+    /*
+     * Setup common things
+     */
+    osw_time_set_mono_clk(0);
+    osw_time_set_wall_clk(0);
+    schedule_recalc_cnt = 0;
+
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &vif0_addr, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &vif1_addr, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &vif2_addr, &channel);
+
+    away_policy = ow_steer_policy_directed_away_create(1, &sta_addr, &mediator);
+
+    /*
+     * Run policy
+     */
+    ow_steer_policy_directed_away_set_config(away_policy, &config);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    away_policy->base->ops.recalc_fn(away_policy->base, candidate_list);
+
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif0_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif1_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif2_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+
+    /*
+     * Check if away_policy disables after enforce period
+     */
+    osw_timer_core_dispatch(OSW_TIME_SEC(60));
+
+    ow_steer_candidate_list_clear(candidate_list);
+    away_policy->base->ops.recalc_fn(away_policy->base, candidate_list);
+
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif0_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif1_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif2_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+}
Index: core/src/lib/ow/src/ow_steer_policy_directed_home.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_directed_home.c
@@ -0,0 +1,190 @@
+#include <log.h>
+#include <util.h>
+#include <const.h>
+#include <memutil.h>
+#include <osw_types.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_state.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_policy_directed_home.h"
+
+struct ow_steer_policy_directed_home_state {
+    struct osw_timer enforce_timer;
+};
+
+struct ow_steer_policy_directed_home {
+    struct ow_steer_policy *base;
+    struct ow_steer_policy_directed_home_config config;
+    struct ow_steer_policy_directed_home_state state;
+};
+
+static const char *g_policy_name = "ow_steer_policy_directed_home";
+
+static void
+ow_steer_policy_directed_home_enforce_timer_sb(struct osw_timer *timer)
+{
+    assert(timer != NULL);
+
+    struct ow_steer_policy_directed_home_state *state = container_of(timer, struct ow_steer_policy_directed_home_state, enforce_timer);
+    struct ow_steer_policy_directed_home *home_policy = container_of(state, struct ow_steer_policy_directed_home, state);
+
+    LOGI("%s enforce period finished", ow_steer_policy_get_prefix(home_policy->base));
+    ow_steer_policy_schedule_stack_recalc(home_policy->base);
+}
+
+static bool
+ow_steer_policy_directed_home_is_candidate_allowed(const struct ow_steer_policy_directed_home_config *config,
+                                                   const struct ow_steer_candidate *candidate)
+{
+    assert(config != NULL);
+    assert(candidate != NULL);
+
+    const struct osw_hwaddr *candidate_bssid = ow_steer_candidate_get_bssid(candidate);
+    size_t i = 0;
+
+    for (i = 0; i < config->allowed_bssids_len; i++)
+        if (osw_hwaddr_cmp(candidate_bssid, &config->allowed_bssids[i]) == 0)
+            return true;
+
+    return false;
+}
+
+static void
+ow_steer_policy_directed_home_recalc_cb(struct ow_steer_policy *policy,
+                                        struct ow_steer_candidate_list *candidate_list)
+{
+    assert(policy != NULL);
+    assert(candidate_list != NULL);
+
+    struct ow_steer_policy_directed_home *home_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_directed_home_config *config = &home_policy->config;
+    const struct ow_steer_policy_directed_home_state *state = &home_policy->state;
+    size_t i = 0;
+
+    if (osw_timer_is_armed(&state->enforce_timer) == false)
+        return;
+
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        struct ow_steer_candidate *candidate = ow_steer_candidate_list_get(candidate_list, i);
+        const struct osw_hwaddr *candidate_bssid = ow_steer_candidate_get_bssid(candidate);
+        const enum ow_steer_candidate_preference candidate_preference = ow_steer_candidate_get_preference(candidate);
+
+        switch (candidate_preference) {
+            case OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE:
+            case OW_STEER_CANDIDATE_PREFERENCE_BLOCKED:
+                continue;
+            case OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE:
+                LOGW("%s bssid: "OSW_HWADDR_FMT" preference: %s cannot override preference and set to blocked",
+                     ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(candidate_bssid),
+                     ow_steer_candidate_preference_to_cstr(ow_steer_candidate_get_preference(candidate)));
+                continue;
+            case OW_STEER_CANDIDATE_PREFERENCE_NONE:
+                break;
+        }
+
+        if (ow_steer_policy_directed_home_is_candidate_allowed(config, candidate) == false)
+            ow_steer_candidate_set_preference(candidate, OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+
+        LOGD("%s bssid: "OSW_HWADDR_FMT" preference: %s",
+             ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(candidate_bssid),
+             ow_steer_candidate_preference_to_cstr(ow_steer_candidate_get_preference(candidate)));
+    }
+}
+
+static void
+ow_steer_policy_directed_home_sigusr1_dump_cb(struct ow_steer_policy *policy)
+{
+    assert(policy != NULL);
+
+    struct ow_steer_policy_directed_home *home_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_directed_home_config *config = &home_policy->config;
+    const struct ow_steer_policy_directed_home_state *state = &home_policy->state;
+    const uint64_t now_nsec = osw_time_mono_clk();
+    const char *enforce_timer_buf = NULL;
+    size_t i;
+
+    LOGI("ow: steer:           config:");
+    LOGI("ow: steer:             enforce_sec: %u", config->enforce_sec);
+
+    enforce_timer_buf = osw_timer_is_armed(&state->enforce_timer) == true ?
+        strfmta("%.2lf sec remaining", OSW_TIME_TO_DBL(osw_timer_get_remaining_nsec(&state->enforce_timer, now_nsec))) : "inactive";
+
+    LOGI("ow: steer:             allowed bssids:");
+    for (i = 0; i < config->allowed_bssids_len; i++)
+        LOGI("ow: steer:               "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&config->allowed_bssids[i]));
+
+    LOGI("ow: steer:           state:");
+    LOGI("ow: steer:             enforce_timer: %s", enforce_timer_buf);
+}
+
+struct ow_steer_policy_directed_home*
+ow_steer_policy_directed_home_create(unsigned int priority,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct ow_steer_policy_mediator *mediator)
+{
+    assert(sta_addr != NULL);
+    assert(mediator != NULL);
+
+    const struct ow_steer_policy_ops ops = {
+        .sigusr1_dump_fn = ow_steer_policy_directed_home_sigusr1_dump_cb,
+        .recalc_fn = ow_steer_policy_directed_home_recalc_cb,
+    };
+
+    struct ow_steer_policy_directed_home *home_policy = CALLOC(1, sizeof(*home_policy));
+
+    home_policy->base = ow_steer_policy_create(g_policy_name, priority, sta_addr, &ops, mediator, home_policy);
+    osw_timer_init(&home_policy->state.enforce_timer, ow_steer_policy_directed_home_enforce_timer_sb);
+
+    return home_policy;
+}
+
+void
+ow_steer_policy_directed_home_free(struct ow_steer_policy_directed_home *home_policy)
+{
+    assert(home_policy != NULL);
+
+    ow_steer_policy_free(home_policy->base);
+    osw_timer_disarm(&home_policy->state.enforce_timer);
+    FREE(home_policy);
+}
+
+struct ow_steer_policy*
+ow_steer_policy_directed_home_get_base(struct ow_steer_policy_directed_home *home_policy)
+{
+    assert(home_policy != NULL);
+    return home_policy->base;
+}
+
+void
+ow_steer_policy_directed_home_set_config(struct ow_steer_policy_directed_home *home_policy,
+                                         const struct ow_steer_policy_directed_home_config *config)
+{
+    assert(home_policy != NULL);
+
+    struct ow_steer_policy_directed_home_state *state = &home_policy->state;
+
+    if (config != NULL && memcmp(&home_policy->config, config, sizeof(home_policy->config)) == 0)
+        return;
+
+    LOGI("%s config changed", ow_steer_policy_get_prefix(home_policy->base));
+
+    if (config != NULL)
+        memcpy(&home_policy->config, config, sizeof(home_policy->config));
+
+    if (osw_timer_is_armed(&state->enforce_timer) == true) {
+        osw_timer_disarm(&state->enforce_timer);
+        LOGI("%s stop enforce timer", ow_steer_policy_get_prefix(home_policy->base));
+    }
+
+    const uint64_t tstamp_nsec = osw_time_mono_clk() + OSW_TIME_SEC(home_policy->config.enforce_sec);
+    osw_timer_arm_at_nsec(&state->enforce_timer, tstamp_nsec);
+    LOGI("%s start enforce timer, duration: %u seconds", ow_steer_policy_get_prefix(home_policy->base),
+         home_policy->config.enforce_sec);
+
+    ow_steer_policy_set_active(home_policy->base, config != NULL);
+}
+
+#include "ow_steer_policy_directed_home_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_directed_home.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_directed_home.h
@@ -0,0 +1,29 @@
+#ifndef OW_STEER_POLICY_DIRECTED_HOME_H
+#define OW_STEER_POLICY_DIRECTED_HOME_H
+
+#define OW_STEER_POLICY_DIRECTED_HOME_ALLOWED_BSSIDS_SIZE 8
+
+struct ow_steer_policy_directed_home_config {
+    unsigned int enforce_sec;
+    struct osw_hwaddr allowed_bssids[OW_STEER_POLICY_DIRECTED_HOME_ALLOWED_BSSIDS_SIZE];
+    size_t allowed_bssids_len;
+};
+
+struct ow_steer_policy_directed_home;
+
+struct ow_steer_policy_directed_home*
+ow_steer_policy_directed_home_create(unsigned int priority,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct ow_steer_policy_mediator *mediator);
+
+void
+ow_steer_policy_directed_home_free(struct ow_steer_policy_directed_home *home_policy);
+
+struct ow_steer_policy*
+ow_steer_policy_directed_home_get_base(struct ow_steer_policy_directed_home *home_policy);
+
+void
+ow_steer_policy_directed_home_set_config(struct ow_steer_policy_directed_home *home_policy,
+                                         const struct ow_steer_policy_directed_home_config *config);
+
+#endif /* OW_STEER_POLICY_DIRECTED_HOME_H */
Index: core/src/lib/ow/src/ow_steer_policy_directed_home_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_directed_home_ut.c
@@ -0,0 +1,102 @@
+#include <ds_tree.h>
+#include <osw_bss_map.h>
+#include <osw_time.h>
+#include <osw_ut.h>
+#include "ow_steer_policy_i.h"
+#include "ow_steer_sta_i.h"
+#include "ow_steer_policy_stack.h"
+
+static void
+ow_steer_policy_directed_home_ut_mediator_sched_stack_recalc(struct ow_steer_policy *policy,
+                                                             void *priv)
+{
+    OSW_UT_EVAL(priv != NULL);
+    unsigned int *cnt = priv;
+    *cnt = *cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_directed_home) {
+    struct osw_hwaddr vif0_addr = {
+        .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, },
+    };
+    struct osw_hwaddr vif1_addr = {
+        .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, },
+    };
+    struct osw_hwaddr vif2_addr = {
+        .octet = { 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, },
+    };
+    struct osw_hwaddr sta_addr = {
+        .octet = { 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF },
+    };
+    struct ow_steer_policy_directed_home_config config = {
+        .enforce_sec = 60,
+        .allowed_bssids = {
+            { .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, }, /* vif1_addr */ },
+            { .octet = { 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, }, /* vif2_addr */ },
+        },
+        .allowed_bssids_len = 2,
+    };
+    const struct osw_channel channel = {
+        .width = OSW_CHANNEL_20MHZ,
+        .control_freq_mhz = 2412,
+    };
+
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_candidate *candidate;
+    struct ow_steer_policy_directed_home *home_policy;
+    unsigned int schedule_recalc_cnt;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_directed_home_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+
+    /*
+     * Setup common things
+     */
+    osw_time_set_mono_clk(0);
+    osw_time_set_wall_clk(0);
+    schedule_recalc_cnt = 0;
+
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &vif0_addr, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &vif1_addr, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &vif2_addr, &channel);
+
+    home_policy = ow_steer_policy_directed_home_create(1, &sta_addr, &mediator);
+
+    /*
+     * Run policy
+     */
+    ow_steer_policy_directed_home_set_config(home_policy, &config);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    home_policy->base->ops.recalc_fn(home_policy->base, candidate_list);
+
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif0_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif1_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif2_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+
+    /*
+     * Check if policy disables after enforce period
+     */
+    osw_timer_core_dispatch(OSW_TIME_SEC(60));
+
+    ow_steer_candidate_list_clear(candidate_list);
+    home_policy->base->ops.recalc_fn(home_policy->base, candidate_list);
+
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif0_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif1_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &vif2_addr);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate) == 0);
+}
Index: core/src/lib/ow/src/ow_steer_policy_force_kick.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_force_kick.c
@@ -0,0 +1,153 @@
+#include <ds_tree.h>
+#include <memutil.h>
+#include <const.h>
+#include <util.h>
+#include <log.h>
+#include <module.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_policy_i.h"
+#include "ow_steer_policy_force_kick.h"
+
+struct ow_steer_policy_force_kick {
+    struct ow_steer_policy *base;
+    struct ow_steer_policy_force_kick_config config;
+    struct osw_timer enforce_timer;
+};
+
+static const char *g_policy_name = "force_kick";
+
+static void
+ow_steer_policy_force_kick_recalc_cb(struct ow_steer_policy *policy,
+                                     struct ow_steer_candidate_list *candidate_list)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(candidate_list != NULL, "");
+
+    size_t i;
+
+    LOGD("%s recalc candidates", ow_steer_policy_get_prefix(policy));
+
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        struct ow_steer_candidate *candidate = ow_steer_candidate_list_get(candidate_list, i);
+        const struct osw_hwaddr *candidate_bssid = ow_steer_candidate_get_bssid(candidate);
+        const enum ow_steer_candidate_preference preference = ow_steer_candidate_get_preference(candidate);
+
+        if (preference == OW_STEER_CANDIDATE_PREFERENCE_NONE)
+            ow_steer_candidate_set_preference(candidate, OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+
+        LOGD("%s bssid: "OSW_HWADDR_FMT" preference: %s", ow_steer_policy_get_prefix(policy),
+             OSW_HWADDR_ARG(candidate_bssid), ow_steer_candidate_preference_to_cstr(preference));
+     }
+}
+
+static void
+ow_steer_policy_force_kick_sigusr1_dump_cb(struct ow_steer_policy *policy)
+{
+    ASSERT(policy != NULL, "");
+
+    struct ow_steer_policy_force_kick *force_policy = ow_steer_policy_get_priv(policy);
+    const uint64_t now_nsec = osw_time_mono_clk();
+    const char *enforce_timer_buf;
+
+    LOGI("ow: steer:           config");
+    LOGI("ow: steer:             duration: %lf nsec", OSW_TIME_TO_DBL(force_policy->config.duration_nsec));
+
+    enforce_timer_buf = osw_timer_is_armed(&force_policy->enforce_timer) == true?
+        strfmta("%.2lf sec remaining", OSW_TIME_TO_DBL(osw_timer_get_remaining_nsec(&force_policy->enforce_timer, now_nsec))) : "inactive";
+
+    LOGI("ow: steer:           enforce_timer: %s", enforce_timer_buf);
+}
+
+static void
+ow_steer_policy_force_kick_enforce_timer_cb(struct osw_timer *timer)
+{
+    struct ow_steer_policy_force_kick *force_policy = container_of(timer, struct ow_steer_policy_force_kick, enforce_timer);
+
+    LOGI("%s enforce period finished", ow_steer_policy_get_prefix(force_policy->base));
+    osw_timer_disarm(&force_policy->enforce_timer);
+    ow_steer_policy_set_active(force_policy->base, false);
+}
+
+static void
+ow_steer_policy_force_kick_sta_disconnected_cb(struct ow_steer_policy *policy,
+                                               const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_policy_force_kick *force_policy = ow_steer_policy_get_priv(policy);
+
+    LOGI("%s sta disconnected, cancel enforce period", ow_steer_policy_get_prefix(force_policy->base));
+    osw_timer_disarm(&force_policy->enforce_timer);
+    ow_steer_policy_set_active(force_policy->base, false);
+}
+
+struct ow_steer_policy_force_kick*
+ow_steer_policy_force_kick_create(unsigned int priority,
+                                  const struct osw_hwaddr *sta_addr,
+                                  const struct ow_steer_policy_mediator *mediator)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(mediator != NULL, "");
+
+    const struct ow_steer_policy_ops ops = {
+        .sigusr1_dump_fn = ow_steer_policy_force_kick_sigusr1_dump_cb,
+        .recalc_fn = ow_steer_policy_force_kick_recalc_cb,
+        .sta_disconnected_fn = ow_steer_policy_force_kick_sta_disconnected_cb,
+    };
+
+    struct ow_steer_policy_force_kick *force_policy = CALLOC(1, sizeof(*force_policy));
+    force_policy->base = ow_steer_policy_create(g_policy_name, priority, sta_addr, &ops, mediator, force_policy);
+    osw_timer_init(&force_policy->enforce_timer, ow_steer_policy_force_kick_enforce_timer_cb);
+
+    return force_policy;
+}
+
+void
+ow_steer_policy_force_kick_free(struct ow_steer_policy_force_kick *force_policy)
+{
+    ASSERT(force_policy != NULL, "");
+
+    osw_timer_disarm(&force_policy->enforce_timer);
+    ow_steer_policy_free(force_policy->base);
+    FREE(force_policy);
+}
+
+struct ow_steer_policy*
+ow_steer_policy_force_kick_get_base(struct ow_steer_policy_force_kick *force_policy)
+{
+    ASSERT(force_policy != NULL, "");
+    return force_policy->base;
+}
+
+void
+ow_steer_policy_force_kick_set_config(struct ow_steer_policy_force_kick *force_policy,
+                                      const struct ow_steer_policy_force_kick_config *config)
+{
+    ASSERT(force_policy != NULL, "");
+
+    if (osw_timer_is_armed(&force_policy->enforce_timer) == true)
+        return;
+
+    if (config == NULL)
+        return;
+
+    LOGI("%s config changed", ow_steer_policy_get_prefix(force_policy->base));
+
+    memcpy(&force_policy->config, config, sizeof(force_policy->config));
+    ow_steer_policy_set_active(force_policy->base, config != NULL);
+
+    const uint64_t duration_nsec = osw_time_mono_clk() + force_policy->config.duration_nsec;
+    osw_timer_arm_at_nsec(&force_policy->enforce_timer, duration_nsec);
+
+    LOGI("%s duration: %.2lf sec, starting enforce period", ow_steer_policy_get_prefix(force_policy->base),
+         OSW_TIME_TO_DBL(force_policy->config.duration_nsec));
+}
+
+#include "ow_steer_policy_force_kick_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_force_kick.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_force_kick.h
@@ -0,0 +1,25 @@
+#ifndef OW_STEER_POLICY_FORCE_KICK_H
+#define OW_STEER_POLICY_FORCE_KICK_H
+
+struct ow_steer_policy_force_kick_config {
+    uint64_t duration_nsec;
+};
+
+struct ow_steer_policy_force_kick;
+
+struct ow_steer_policy_force_kick*
+ow_steer_policy_force_kick_create(unsigned int priority,
+                                  const struct osw_hwaddr *sta_addr,
+                                  const struct ow_steer_policy_mediator *mediator);
+
+void
+ow_steer_policy_force_kick_free(struct ow_steer_policy_force_kick *force_policy);
+
+struct ow_steer_policy*
+ow_steer_policy_force_kick_get_base(struct ow_steer_policy_force_kick *force_policy);
+
+void
+ow_steer_policy_force_kick_set_config(struct ow_steer_policy_force_kick *force_policy,
+                                      const struct ow_steer_policy_force_kick_config *config);
+
+#endif /* OW_STEER_POLICY_FORCE_KICK_H */
Index: core/src/lib/ow/src/ow_steer_policy_force_kick_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_force_kick_ut.c
@@ -0,0 +1,120 @@
+#include <osw_ut.h>
+#include "ow_steer_policy_i.h"
+
+static void
+ow_steer_policy_force_kick_ut_mediator_sched_stack_recalc(struct ow_steer_policy *policy,
+                                                          void *priv)
+{
+    OSW_UT_EVAL(priv != NULL);
+    unsigned int *cnt = priv;
+    *cnt = *cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_force_kick_ut_typical_case)
+{
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct osw_hwaddr bssid_a = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr bssid_b = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    const struct osw_hwaddr bssid_c = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr bssid_d = { .octet = { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, }, };
+    const struct osw_hwaddr sta_addr = { .octet = { 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, }, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_force_kick_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_force_kick_config config = {
+        .duration_nsec = 0,
+    };
+    struct ow_steer_policy_force_kick *force_policy;
+    struct ow_steer_policy *policy;
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_candidate *candidate_a;
+    struct ow_steer_candidate *candidate_b;
+    struct ow_steer_candidate *candidate_c;
+    struct ow_steer_candidate *candidate_d;
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_a, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_b, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_c, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid_d, &channel);
+    candidate_a = ow_steer_candidate_list_lookup(candidate_list, &bssid_a);
+    candidate_b = ow_steer_candidate_list_lookup(candidate_list, &bssid_b);
+    candidate_c = ow_steer_candidate_list_lookup(candidate_list, &bssid_c);
+    candidate_d = ow_steer_candidate_list_lookup(candidate_list, &bssid_d);
+
+    force_policy = ow_steer_policy_force_kick_create(1, &sta_addr, &mediator);
+    policy = ow_steer_policy_force_kick_get_base(force_policy);
+
+    /* Disabled force kick */
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+    OSW_UT_EVAL(ow_steer_policy_get_active(policy) == false);
+
+    /* Trigger force kick for 5 seconds */
+    ow_steer_candidate_list_clear(candidate_list);
+    ow_steer_candidate_set_preference(candidate_a, OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    ow_steer_candidate_set_preference(candidate_b, OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+    ow_steer_candidate_set_preference(candidate_c, OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    ow_steer_candidate_set_preference(candidate_d, OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    config.duration_nsec = OSW_TIME_SEC(5);
+    ow_steer_policy_force_kick_set_config(force_policy, &config);
+
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+    OSW_UT_EVAL(ow_steer_policy_get_active(policy) == true);
+
+    force_policy->base->ops.recalc_fn(force_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_a) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_b) == OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_c) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_d) == OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+
+    /* Recalculation in the middle of enforce period */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+    OSW_UT_EVAL(ow_steer_policy_get_active(policy) == true);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    ow_steer_candidate_set_preference(candidate_a, OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    ow_steer_candidate_set_preference(candidate_b, OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+    ow_steer_candidate_set_preference(candidate_c, OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    ow_steer_candidate_set_preference(candidate_d, OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    force_policy->base->ops.recalc_fn(force_policy->base, candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_a) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_b) == OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_c) == OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_d) == OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+
+    /* Go to the end of enforce period */
+    osw_ut_time_advance(OSW_TIME_SEC(4));
+
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    OSW_UT_EVAL(ow_steer_policy_get_active(policy) == false);
+
+    /* Triggered force kick policy cannot be stopped (unless it's freed) */
+    config.duration_nsec = OSW_TIME_SEC(5);
+    ow_steer_policy_force_kick_set_config(force_policy, &config);
+
+    osw_ut_time_advance(OSW_TIME_SEC(2));
+
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    OSW_UT_EVAL(ow_steer_policy_get_active(policy) == true);
+
+    ow_steer_policy_force_kick_set_config(force_policy, NULL);
+
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    OSW_UT_EVAL(ow_steer_policy_get_active(policy) == true);
+
+    config.duration_nsec = OSW_TIME_SEC(10);
+    ow_steer_policy_force_kick_set_config(force_policy, &config);
+
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    OSW_UT_EVAL(ow_steer_policy_get_active(policy) == true);
+}
Index: core/src/lib/ow/src/ow_steer_policy_i.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_i.h
@@ -0,0 +1,21 @@
+#ifndef OW_STEER_POLICY_I_H
+#define OW_STEER_POLICY_I_H
+
+typedef void
+ow_steer_policy_schedule_recalc_fn_t(void *priv);
+
+struct ow_steer_policy {
+    bool active;
+    char *name;
+    struct osw_hwaddr sta_addr;
+    struct osw_hwaddr bssid;
+    unsigned int priority;
+    void *priv;
+    struct ow_steer_policy_ops ops;
+    struct ow_steer_policy_mediator mediator;
+    char *prefix;
+
+    struct ds_dlist_node stack_node;
+};
+
+#endif /* OW_STEER_POLICY_I_H */
Index: core/src/lib/ow/src/ow_steer_policy_pre_assoc_counter.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_pre_assoc_counter.c
@@ -0,0 +1,372 @@
+#include <math.h>
+#include <const.h>
+#include <ds_tree.h>
+#include <memutil.h>
+#include <log.h>
+#include <util.h>
+#include <osw_types.h>
+#include <osw_drv_common.h>
+#include <osw_time.h>
+#include <osw_timer.h>
+#include <osw_state.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_policy_pre_assoc_counter.h"
+
+struct ow_steer_policy_pre_assoc_counter_persistent_state {
+    unsigned int allowed_vif_active_connect_cnt;
+};
+
+struct ow_steer_policy_pre_assoc_counter_volatile_state {
+    unsigned int backoff_connect_cnt;
+    unsigned int reject_cnt;
+    struct osw_timer reject_timer;
+    struct osw_timer backoff_timer;
+};
+
+struct ow_steer_policy_pre_assoc_counter {
+    struct ow_steer_policy *base;
+    struct ow_steer_policy_pre_assoc_counter_config config;
+
+    struct ow_steer_policy_pre_assoc_counter_persistent_state pstate;
+    struct ow_steer_policy_pre_assoc_counter_volatile_state vstate;
+};
+
+static const char *g_policy_name = "pre_assoc_counter";
+
+static void
+ow_steer_policy_pre_assoc_counter_reset_volatile_state(struct ow_steer_policy_pre_assoc_counter *counter_policy)
+{
+    ASSERT(counter_policy != NULL, "");
+
+    const struct ow_steer_policy_pre_assoc_counter_config *config = &counter_policy->config;
+    struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = &counter_policy->vstate;
+
+    osw_timer_disarm(&vstate->reject_timer);
+    osw_timer_disarm(&vstate->backoff_timer);
+    vstate->reject_cnt = 0;
+
+    LOGI("%s bssid: "OSW_HWADDR_FMT" reset", ow_steer_policy_get_prefix(counter_policy->base), OSW_HWADDR_ARG(&config->bssid));
+
+    ow_steer_policy_schedule_stack_recalc(counter_policy->base);
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_sigusr1_dump_cb(struct ow_steer_policy *policy)
+{
+    ASSERT(policy != NULL, "");
+
+    const struct ow_steer_policy_pre_assoc_counter *counter_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_pre_assoc_counter_config *config = &counter_policy->config;
+    const struct ow_steer_policy_pre_assoc_counter_persistent_state *pstate = &counter_policy->pstate;
+    const struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = &counter_policy->vstate;
+    const uint64_t now_nsec = osw_time_mono_clk();
+    const char *reject_timer_buf;
+    const char *backoff_timer_buf;
+
+    LOGI("ow: steer:           config:");
+    LOGI("ow: steer:             bssid: "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&config->bssid));
+    LOGI("ow: steer:             reject_limit: %u", config->reject_limit);
+    LOGI("ow: steer:             reject_timeout_sec: %u", config->reject_timeout_sec);
+    LOGI("ow: steer:             backoff_timeout_sec: %u", config->backoff_timeout_sec);
+    LOGI("ow: steer:             backoff_exp_base: %u", config->backoff_exp_base);
+    switch (config->condition.type) {
+        case OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_ALWAYS:
+            LOGI("ow: steer:             type: always");
+            break;
+        case OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_THRESHOLD_SNR:
+            LOGI("ow: steer:             type: threshold snr");
+            LOGI("ow: steer:               threshold_snr: %u", config->condition.params.hwm.threshold_snr);
+            break;
+    }
+
+    reject_timer_buf = osw_timer_is_armed(&vstate->reject_timer) == true?
+        strfmta("%.2lf sec remaining", OSW_TIME_TO_DBL(osw_timer_get_remaining_nsec(&vstate->reject_timer, now_nsec))) : "inactive";
+    backoff_timer_buf = osw_timer_is_armed(&vstate->backoff_timer) == true?
+        strfmta("%.2lf sec remaining", OSW_TIME_TO_DBL(osw_timer_get_remaining_nsec(&vstate->backoff_timer, now_nsec))) : "inactive";
+
+    LOGI("ow: steer:           state:");
+    LOGI("ow: steer:             allowed_vif_active_connect_cnt: %u", pstate->allowed_vif_active_connect_cnt);
+    LOGI("ow: steer:             backoff_connect_cnt: %u", vstate->backoff_connect_cnt);
+    LOGI("ow: steer:             reject_cnt: %u", vstate->reject_cnt);
+    LOGI("ow: steer:             reject_timer: %s", reject_timer_buf);
+    LOGI("ow: steer:             backoff_timer: %s", backoff_timer_buf);
+}
+
+static double
+ow_steer_policy_pre_assoc_counter_compute_backoff_timeout(struct ow_steer_policy_pre_assoc_counter *counter_policy)
+{
+    ASSERT(counter_policy != NULL, "");
+
+    const struct ow_steer_policy_pre_assoc_counter_config *config = &counter_policy->config;
+    const struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = &counter_policy->vstate;
+    const unsigned int power = MIN(vstate->backoff_connect_cnt, 10u); /* FIXME Old BM had max 10 */
+    const unsigned int base = config->backoff_exp_base;
+
+    return config->backoff_timeout_sec * pow(base, power);
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_reject_timer_cb(struct osw_timer *timer)
+{
+    struct ow_steer_policy_pre_assoc_counter *counter_policy = container_of(timer, struct ow_steer_policy_pre_assoc_counter, vstate.reject_timer);
+    LOGI("%s bssid: "OSW_HWADDR_FMT" rejecting finished", ow_steer_policy_get_prefix(counter_policy->base), OSW_HWADDR_ARG(&counter_policy->config.bssid));
+    ow_steer_policy_pre_assoc_counter_reset_volatile_state(counter_policy);
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_backoff_timer_cb(struct osw_timer *timer)
+{
+    struct ow_steer_policy_pre_assoc_counter *counter_policy = container_of(timer, struct ow_steer_policy_pre_assoc_counter, vstate.backoff_timer);
+    LOGI("%s bssid: "OSW_HWADDR_FMT" backoff finished", ow_steer_policy_get_prefix(counter_policy->base), OSW_HWADDR_ARG(&counter_policy->config.bssid));
+    ow_steer_policy_pre_assoc_counter_reset_volatile_state(counter_policy);
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_sta_connected_cb(struct ow_steer_policy *policy,
+                                                   const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_policy_pre_assoc_counter *counter_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_pre_assoc_counter_config *config = &counter_policy->config;
+    struct ow_steer_policy_pre_assoc_counter_persistent_state *pstate = &counter_policy->pstate;
+    struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = &counter_policy->vstate;
+    const struct osw_hwaddr *bssid = &sta_info->vif->drv_state->mac_addr;
+
+    if (osw_timer_is_armed(&vstate->backoff_timer) == true) {
+        vstate->backoff_connect_cnt++;
+        LOGI("%s bssid: "OSW_HWADDR_FMT" sta connected during backoff", ow_steer_policy_get_prefix(counter_policy->base),
+             OSW_HWADDR_ARG(&config->bssid));
+    }
+    else {
+        if (osw_hwaddr_cmp(&config->bssid, bssid) == 0) {
+            LOGW("%s bssid: "OSW_HWADDR_FMT" sta connected to blocked vif", ow_steer_policy_get_prefix(counter_policy->base),
+                 OSW_HWADDR_ARG(&counter_policy->config.bssid));
+        }
+        else {
+            pstate->allowed_vif_active_connect_cnt++;
+            LOGD("%s bssid: "OSW_HWADDR_FMT" sta connected to allowed vif", ow_steer_policy_get_prefix(counter_policy->base),
+                 OSW_HWADDR_ARG(bssid));
+        }
+    }
+
+    ow_steer_policy_pre_assoc_counter_reset_volatile_state(counter_policy);
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_sta_disconnected_cb(struct ow_steer_policy *policy,
+                                                      const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_policy_pre_assoc_counter *counter_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_pre_assoc_counter_config *config = &counter_policy->config;
+    struct ow_steer_policy_pre_assoc_counter_persistent_state *pstate = &counter_policy->pstate;
+    const struct osw_hwaddr *bssid = &sta_info->vif->drv_state->mac_addr;
+
+    if (osw_hwaddr_cmp(&config->bssid, bssid) == 0) {
+        LOGD("%s bssid: "OSW_HWADDR_FMT" sta disconnected from blocked vif", ow_steer_policy_get_prefix(counter_policy->base),
+             OSW_HWADDR_ARG(&counter_policy->config.bssid));
+    }
+    else {
+        LOGD("%s bssid: "OSW_HWADDR_FMT" sta disconnected from allowed vif", ow_steer_policy_get_prefix(counter_policy->base),
+             OSW_HWADDR_ARG(bssid));
+
+        if (WARN_ON(pstate->allowed_vif_active_connect_cnt == 0))
+            return;
+
+        pstate->allowed_vif_active_connect_cnt--;
+        if (pstate->allowed_vif_active_connect_cnt > 0)
+            return;
+    }
+
+    ow_steer_policy_pre_assoc_counter_reset_volatile_state(counter_policy);
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_vif_probe_req_cb(struct ow_steer_policy *policy,
+                                                   const struct osw_state_vif_info *vif_info,
+                                                   const struct osw_drv_report_vif_probe_req *probe_req)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(vif_info != NULL, "");
+    ASSERT(probe_req != NULL, "");
+
+    struct ow_steer_policy_pre_assoc_counter *counter_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_pre_assoc_counter_config *config = &counter_policy->config;
+    const struct ow_steer_policy_pre_assoc_counter_persistent_state *pstate = &counter_policy->pstate;
+    struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = &counter_policy->vstate;
+    const struct osw_hwaddr *bssid = &vif_info->drv_state->mac_addr;
+    double backoff_timeout_sec;
+
+    if (pstate->allowed_vif_active_connect_cnt > 0) {
+        LOGD("%s bssid: "OSW_HWADDR_FMT" probe req type: %s snr: %u, ignored, sta is already connected",
+             ow_steer_policy_get_prefix(counter_policy->base), OSW_HWADDR_ARG(&config->bssid),
+             probe_req->ssid.len > 0 ? "direct" : "wildcard", probe_req->snr);
+        return;
+    }
+
+    if (osw_hwaddr_cmp(&config->bssid, bssid) != 0)
+        return;
+
+    if (osw_timer_is_armed(&vstate->backoff_timer) == true) {
+        LOGD("%s bssid: "OSW_HWADDR_FMT" ignore probe req, backoff in progress", ow_steer_policy_get_prefix(counter_policy->base),
+             OSW_HWADDR_ARG(&config->bssid));
+        return;
+    }
+
+    if (vstate->reject_cnt == 0) {
+        WARN_ON(osw_timer_is_armed(&vstate->reject_timer));
+        osw_timer_arm_at_nsec(&vstate->reject_timer, osw_time_mono_clk() + OSW_TIME_SEC(config->reject_timeout_sec));
+
+        LOGI("%s bssid: "OSW_HWADDR_FMT" rejecting started", ow_steer_policy_get_prefix(counter_policy->base), OSW_HWADDR_ARG(&config->bssid));
+    }
+
+    vstate->reject_cnt++;
+
+    LOGD("%s bssid: "OSW_HWADDR_FMT" probe req type: %s snr: %u, reject limit: %u/%u", ow_steer_policy_get_prefix(counter_policy->base), OSW_HWADDR_ARG(&config->bssid),
+         probe_req->ssid.len > 0 ? "direct" : "wildcard", probe_req->snr, vstate->reject_cnt, config->reject_limit);
+
+    /* Check backoff connfition */
+    switch (config->condition.type) {
+        case OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_ALWAYS:
+            /* nop */
+            break;
+        case OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_THRESHOLD_SNR:
+            if (probe_req->snr < config->condition.params.hwm.threshold_snr) {
+                LOGI("%s bssid: "OSW_HWADDR_FMT" probe req snr: %u below threshold: %u, backoff started", ow_steer_policy_get_prefix(counter_policy->base),
+                     OSW_HWADDR_ARG(&config->bssid), probe_req->snr, config->condition.params.hwm.threshold_snr);
+                goto start_backoff;
+            }
+            break;
+    }
+
+    if (vstate->reject_cnt >= config->reject_limit) {
+        LOGI("%s bssid: "OSW_HWADDR_FMT" reached reject limit %u/%u, backoff started", ow_steer_policy_get_prefix(counter_policy->base),
+             OSW_HWADDR_ARG(&config->bssid), config->reject_limit, config->reject_limit);
+        goto start_backoff;
+    }
+
+    return;
+
+    start_backoff:
+        backoff_timeout_sec = ow_steer_policy_pre_assoc_counter_compute_backoff_timeout(counter_policy);
+        osw_timer_arm_at_nsec(&vstate->backoff_timer, osw_time_mono_clk() + OSW_TIME_SEC(backoff_timeout_sec));
+
+        ow_steer_policy_schedule_stack_recalc(counter_policy->base);
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_recalc_cb(struct ow_steer_policy *policy,
+                                            struct ow_steer_candidate_list *candidate_list)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(candidate_list != NULL, "");
+
+    struct ow_steer_policy_pre_assoc_counter *counter_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_pre_assoc_counter_config *config = &counter_policy->config;
+    struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = &counter_policy->vstate;
+    struct ow_steer_candidate *candidate;
+    enum ow_steer_candidate_preference preference;
+
+    LOGD("%s recalc candidates", ow_steer_policy_get_prefix(policy));
+
+    candidate = ow_steer_candidate_list_lookup(candidate_list, &config->bssid);
+    if (candidate == NULL) {
+        LOGW("%s candidate bssid: "OSW_HWADDR_FMT" is missing", ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(&config->bssid));
+        return;
+    }
+
+    preference = ow_steer_candidate_get_preference(candidate);
+    if (preference != OW_STEER_CANDIDATE_PREFERENCE_NONE) {
+        LOGD("%s bssid: "OSW_HWADDR_FMT" preference already set", ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(&config->bssid));
+        return;
+    }
+
+    if (osw_timer_is_armed(&vstate->backoff_timer) == false)
+        preference = OW_STEER_CANDIDATE_PREFERENCE_BLOCKED;
+
+    ow_steer_candidate_set_preference(candidate, preference);
+
+    LOGD("%s bssid: "OSW_HWADDR_FMT" preference: %s", ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(&config->bssid),
+         ow_steer_candidate_preference_to_cstr(preference));
+}
+
+struct ow_steer_policy_pre_assoc_counter*
+ow_steer_policy_pre_assoc_counter_create(unsigned int priority,
+                                         const struct osw_hwaddr *sta_addr,
+                                         const struct ow_steer_policy_mediator *mediator)
+{
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(mediator != NULL, "");
+
+    const struct ow_steer_policy_ops ops = {
+        .sigusr1_dump_fn = ow_steer_policy_pre_assoc_counter_sigusr1_dump_cb,
+        .recalc_fn = ow_steer_policy_pre_assoc_counter_recalc_cb,
+        .sta_connected_fn = ow_steer_policy_pre_assoc_counter_sta_connected_cb,
+        .sta_disconnected_fn = ow_steer_policy_pre_assoc_counter_sta_disconnected_cb,
+        .vif_probe_req_fn = ow_steer_policy_pre_assoc_counter_vif_probe_req_cb,
+    };
+
+    struct ow_steer_policy_pre_assoc_counter *counter_policy = NULL;
+    struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = NULL;
+
+    counter_policy = CALLOC(1, sizeof(*counter_policy));
+    vstate = &counter_policy->vstate;
+    osw_timer_init(&vstate->reject_timer, ow_steer_policy_pre_assoc_counter_reject_timer_cb);
+    osw_timer_init(&vstate->backoff_timer, ow_steer_policy_pre_assoc_counter_backoff_timer_cb);
+    counter_policy->base = ow_steer_policy_create(g_policy_name, priority, sta_addr, &ops, mediator, counter_policy);
+
+    return counter_policy;
+}
+
+void
+ow_steer_policy_pre_assoc_counter_set_config(struct ow_steer_policy_pre_assoc_counter *counter_policy,
+                                             struct ow_steer_policy_pre_assoc_counter_config *config)
+{
+    ASSERT(counter_policy != NULL, "");
+
+    if (config == NULL) {
+        ow_steer_policy_pre_assoc_counter_reset_volatile_state(counter_policy);
+        ow_steer_policy_set_active(counter_policy->base, false);
+        return;
+    }
+
+    if (memcmp(&counter_policy->config, config, sizeof(counter_policy->config)) == 0)
+        return;
+
+    LOGI("%s config changed", ow_steer_policy_get_prefix(counter_policy->base));
+
+    memcpy(&counter_policy->config, config, sizeof(counter_policy->config));
+    FREE(config);
+
+    ow_steer_policy_pre_assoc_counter_reset_volatile_state(counter_policy);
+    ow_steer_policy_set_active(counter_policy->base, true);
+}
+
+void
+ow_steer_policy_pre_assoc_counter_free(struct ow_steer_policy_pre_assoc_counter *counter_policy)
+{
+    ASSERT(counter_policy != NULL, "");
+
+    struct ow_steer_policy_pre_assoc_counter_volatile_state *vstate = &counter_policy->vstate;
+
+    osw_timer_disarm(&vstate->reject_timer);
+    osw_timer_disarm(&vstate->backoff_timer);
+
+    ow_steer_policy_free(counter_policy->base);
+    FREE(counter_policy);
+}
+
+struct ow_steer_policy*
+ow_steer_policy_pre_assoc_counter_get_base(struct ow_steer_policy_pre_assoc_counter *counter_policy)
+{
+    ASSERT(counter_policy != NULL, "");
+    return counter_policy->base;
+}
+
+#include "ow_steer_policy_pre_assoc_counter_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_pre_assoc_counter.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_pre_assoc_counter.h
@@ -0,0 +1,44 @@
+#ifndef OW_STEER_POLICY_PRE_ASSOC_COUNTER_H
+#define OW_STEER_POLICY_PRE_ASSOC_COUNTER_H
+
+enum ow_steer_policy_pre_assoc_counter_reject_type {
+    OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_ALWAYS = 0,
+    OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_THRESHOLD_SNR,
+};
+
+struct ow_steer_policy_pre_assoc_counter_reject_hwm {
+    unsigned int threshold_snr;
+};
+
+struct ow_steer_policy_pre_assoc_counter_reject_condition {
+    enum ow_steer_policy_pre_assoc_counter_reject_type type;
+    union {
+        struct ow_steer_policy_pre_assoc_counter_reject_hwm hwm;
+    } params;
+};
+
+struct ow_steer_policy_pre_assoc_counter_config {
+    struct osw_hwaddr bssid;
+    unsigned int reject_limit;
+    unsigned int reject_timeout_sec;
+    unsigned int backoff_timeout_sec;
+    unsigned int backoff_exp_base;
+    struct ow_steer_policy_pre_assoc_counter_reject_condition condition;
+};
+
+struct ow_steer_policy_pre_assoc_counter*
+ow_steer_policy_pre_assoc_counter_create(unsigned int priority,
+                                         const struct osw_hwaddr *sta_addr,
+                                         const struct ow_steer_policy_mediator *mediator);
+
+void
+ow_steer_policy_pre_assoc_counter_set_config(struct ow_steer_policy_pre_assoc_counter *counter_policy,
+                                             struct ow_steer_policy_pre_assoc_counter_config *config);
+
+void
+ow_steer_policy_pre_assoc_counter_free(struct ow_steer_policy_pre_assoc_counter *counter_policy);
+
+struct ow_steer_policy*
+ow_steer_policy_pre_assoc_counter_get_base(struct ow_steer_policy_pre_assoc_counter *counter_policy);
+
+#endif /* OW_STEER_POLICY_PRE_ASSOC_COUNTER_H */
Index: core/src/lib/ow/src/ow_steer_policy_pre_assoc_counter_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_pre_assoc_counter_ut.c
@@ -0,0 +1,612 @@
+#include <osw_ut.h>
+#include <osw_conf.h>
+#include "ow_steer_policy_i.h"
+
+struct ow_steer_policy_pre_assoc_counter_ut_ctx {
+    struct osw_drv_vif_state drv_vif_state_0;
+    struct osw_state_vif_info vif_0;
+    struct osw_drv_vif_state drv_vif_state_1;
+    struct osw_state_vif_info vif_1;
+    struct osw_state_sta_info sta_info;
+    struct osw_drv_report_vif_probe_req probe_req;
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_policy_pre_assoc_counter_config config;
+};
+
+static struct ow_steer_policy_pre_assoc_counter_ut_ctx*
+ow_steer_policy_pre_assoc_counter_ut_ctx_get(void)
+{
+    static struct ow_steer_policy_pre_assoc_counter_ut_ctx ctx = {
+        .drv_vif_state_0 = {
+            .mac_addr = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, },
+        },
+        .vif_0 = {
+            .vif_name = "vif_0",
+            .drv_state = &ctx.drv_vif_state_0,
+        },
+        .drv_vif_state_1 = {
+            .mac_addr = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, },
+        },
+        .vif_1 = {
+            .vif_name = "vif_1",
+            .drv_state = &ctx.drv_vif_state_1,
+        },
+        .sta_info = {
+            .vif = &ctx.vif_1,
+        },
+        .probe_req = {
+            .sta_addr = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, },
+        },
+        .config = {
+            .bssid = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, },
+            .reject_limit = 3,
+            .reject_timeout_sec = 120,
+            .backoff_timeout_sec = 60,
+            .backoff_exp_base = 3,
+        },
+    };
+
+    ctx.candidate_list = ow_steer_candidate_list_new();
+
+    return &ctx;
+}
+
+static void
+ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc(struct ow_steer_policy *policy,
+                                                                  void *priv)
+{
+    OSW_UT_EVAL(priv != NULL);
+    unsigned int *cnt = priv;
+    *cnt = *cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_pre_assoc_counter_ut_always_success_steer)
+{
+    struct ow_steer_policy_pre_assoc_counter_ut_ctx *ctx = ow_steer_policy_pre_assoc_counter_ut_ctx_get();
+    ctx->config.condition.type = OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_ALWAYS;
+
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_pre_assoc_counter *counter_policy;
+    struct ow_steer_candidate *candidate_0 = NULL;
+    struct ow_steer_candidate *candidate_1 = NULL;
+
+    /* Setup */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    counter_policy = ow_steer_policy_pre_assoc_counter_create(0, &ctx->probe_req.sta_addr, &mediator);
+    OSW_UT_EVAL(counter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_pre_assoc_counter_set_config(counter_policy, MEMNDUP(&ctx->config, sizeof(ctx->config)));
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    /* Start */
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* STA sends few probes first */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* STA connects to second VIF (preferred) */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_1;
+    counter_policy->base->ops.sta_connected_fn(counter_policy->base, &ctx->sta_info);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+}
+
+OSW_UT(ow_steer_policy_pre_assoc_counter_ut_always_backoff_connect_blocked_vif)
+{
+    struct ow_steer_policy_pre_assoc_counter_ut_ctx *ctx = ow_steer_policy_pre_assoc_counter_ut_ctx_get();
+    ctx->config.condition.type = OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_ALWAYS;
+
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_pre_assoc_counter *counter_policy;
+    struct ow_steer_candidate *candidate_0 = NULL;
+    struct ow_steer_candidate *candidate_1 = NULL;
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    counter_policy = ow_steer_policy_pre_assoc_counter_create(0, &ctx->probe_req.sta_addr, &mediator);
+    OSW_UT_EVAL(counter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_pre_assoc_counter_set_config(counter_policy, MEMNDUP(&ctx->config, sizeof(ctx->config)));
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    /* STA many few probes to initiate backoff */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* STA connects to first (blocked) VIF */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    counter_policy->base->ops.sta_connected_fn(counter_policy->base, &ctx->sta_info);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+}
+
+OSW_UT(ow_steer_policy_pre_assoc_counter_ut_always_backoff_connect_preferred_vif)
+{
+    struct ow_steer_policy_pre_assoc_counter_ut_ctx *ctx = ow_steer_policy_pre_assoc_counter_ut_ctx_get();
+    ctx->config.condition.type = OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_ALWAYS;
+
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_pre_assoc_counter *counter_policy;
+    struct ow_steer_candidate *candidate_0 = NULL;
+    struct ow_steer_candidate *candidate_1 = NULL;
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    counter_policy = ow_steer_policy_pre_assoc_counter_create(0, &ctx->probe_req.sta_addr, &mediator);
+    OSW_UT_EVAL(counter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_pre_assoc_counter_set_config(counter_policy, MEMNDUP(&ctx->config, sizeof(ctx->config)));
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    /* STA sends few probes to initiate backoff */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* STA connects to second VIF (preferred) */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_1;
+    counter_policy->base->ops.sta_connected_fn(counter_policy->base, &ctx->sta_info);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+}
+
+OSW_UT(ow_steer_policy_pre_assoc_counter_ut_always_backoff_no_connect)
+{
+    struct ow_steer_policy_pre_assoc_counter_ut_ctx *ctx = ow_steer_policy_pre_assoc_counter_ut_ctx_get();
+    ctx->config.condition.type = OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_ALWAYS;
+
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_pre_assoc_counter *counter_policy;
+    struct ow_steer_candidate *candidate_0 = NULL;
+    struct ow_steer_candidate *candidate_1 = NULL;
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    counter_policy = ow_steer_policy_pre_assoc_counter_create(0, &ctx->probe_req.sta_addr, &mediator);
+    OSW_UT_EVAL(counter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_pre_assoc_counter_set_config(counter_policy, MEMNDUP(&ctx->config, sizeof(ctx->config)));
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    /* STA many few probes to initiate backoff */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    /* STA sends few probes to initiate backoff */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Wait until backoff expire */
+    osw_ut_time_advance(OSW_TIME_SEC(60));
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Start sending probes again */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+}
+
+OSW_UT(ow_steer_policy_pre_assoc_counter_ut_threshold_snr_success_steer)
+{
+    struct ow_steer_policy_pre_assoc_counter_ut_ctx *ctx = ow_steer_policy_pre_assoc_counter_ut_ctx_get();
+    ctx->config.condition.type = OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_THRESHOLD_SNR;
+    ctx->config.condition.params.hwm.threshold_snr = 35;
+
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_pre_assoc_counter *counter_policy;
+    struct ow_steer_candidate *candidate_0 = NULL;
+    struct ow_steer_candidate *candidate_1 = NULL;
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    counter_policy = ow_steer_policy_pre_assoc_counter_create(0, &ctx->probe_req.sta_addr, &mediator);
+    OSW_UT_EVAL(counter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_pre_assoc_counter_set_config(counter_policy, MEMNDUP(&ctx->config, sizeof(ctx->config)));
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    /* STA sends few probes first */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->probe_req.snr = 38;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* STA connects to second VIF (preferred) */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_1;
+    counter_policy->base->ops.sta_connected_fn(counter_policy->base, &ctx->sta_info);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+}
+
+OSW_UT(ow_steer_policy_pre_assoc_counter_ut_threshold_snr_enter_backoff)
+{
+    struct ow_steer_policy_pre_assoc_counter_ut_ctx *ctx = ow_steer_policy_pre_assoc_counter_ut_ctx_get();
+    ctx->config.condition.type = OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_THRESHOLD_SNR;
+    ctx->config.condition.params.hwm.threshold_snr = 35;
+
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_pre_assoc_counter *counter_policy;
+    struct ow_steer_candidate *candidate_0 = NULL;
+    struct ow_steer_candidate *candidate_1 = NULL;
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    counter_policy = ow_steer_policy_pre_assoc_counter_create(0, &ctx->probe_req.sta_addr, &mediator);
+    OSW_UT_EVAL(counter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_pre_assoc_counter_set_config(counter_policy, MEMNDUP(&ctx->config, sizeof(ctx->config)));
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    /* STA sends few probes first */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Backoff should start with this probe req */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->probe_req.snr = 32;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->probe_req.snr = 31;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+}
+
+OSW_UT(ow_steer_policy_pre_assoc_counter_ut_dormant_when_connected_to_desired_band)
+{
+    struct ow_steer_policy_pre_assoc_counter_ut_ctx *ctx = ow_steer_policy_pre_assoc_counter_ut_ctx_get();
+    ctx->config.condition.type = OW_STEER_POLICY_PRE_ASSOC_COUNTER_REJECT_THRESHOLD_SNR;
+    ctx->config.condition.params.hwm.threshold_snr = 35;
+
+    unsigned int schedule_recalc_cnt = 0;
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_pre_assoc_counter_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_pre_assoc_counter *counter_policy;
+    struct ow_steer_candidate *candidate_0 = NULL;
+    struct ow_steer_candidate *candidate_1 = NULL;
+
+    /* Setup internal bits */
+    osw_ut_time_init();
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr, &channel);
+    ow_steer_candidate_list_bss_set(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr, &channel);
+    candidate_0 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_0.mac_addr);
+    candidate_1 = ow_steer_candidate_list_lookup(ctx->candidate_list, &ctx->drv_vif_state_1.mac_addr);
+
+    counter_policy = ow_steer_policy_pre_assoc_counter_create(0, &ctx->probe_req.sta_addr, &mediator);
+    OSW_UT_EVAL(counter_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_pre_assoc_counter_set_config(counter_policy, MEMNDUP(&ctx->config, sizeof(ctx->config)));
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    /* STA connects to second VIF (preferred) */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_1;
+    counter_policy->base->ops.sta_connected_fn(counter_policy->base, &ctx->sta_info);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* STA sends probes on blocked band */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Next probe reqs shouldn't trigger backoff */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Disconnect STA */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_1;
+    counter_policy->base->ops.sta_disconnected_fn(counter_policy->base, &ctx->sta_info);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Now probe requests received on blocked VIF should trigger backoff */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 4);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_BLOCKED);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+
+    /* Next probe req shouldn't trigger backoff */
+    osw_ut_time_advance(OSW_TIME_SEC(1));
+    ctx->sta_info.vif = &ctx->vif_0;
+    ctx->probe_req.snr = 40;
+    counter_policy->base->ops.vif_probe_req_fn(counter_policy->base, &ctx->vif_0, &ctx->probe_req);
+    ow_steer_candidate_list_clear(ctx->candidate_list);
+    OSW_UT_EVAL(schedule_recalc_cnt == 5);
+    counter_policy->base->ops.recalc_fn(counter_policy->base, ctx->candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_0) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_1) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+}
Index: core/src/lib/ow/src/ow_steer_policy_priv.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_priv.h
@@ -0,0 +1,27 @@
+#ifndef OW_STEER_POLICY_PRIV_H
+#define OW_STEER_POLICY_PRIV_H
+
+void*
+ow_steer_policy_get_priv(struct ow_steer_policy *policy);
+
+void
+ow_steer_policy_set_bssid(struct ow_steer_policy *policy,
+                          const struct osw_hwaddr *bssid);
+
+const char*
+ow_steer_policy_get_prefix(const struct ow_steer_policy *policy);
+
+void
+ow_steer_policy_set_active(struct ow_steer_policy *policy,
+                           bool active);
+
+void
+ow_steer_policy_schedule_stack_recalc(struct ow_steer_policy *policy);
+
+void
+ow_steer_policy_trigger_executor(struct ow_steer_policy *policy);
+
+void
+ow_steer_policy_dismiss_executor(struct ow_steer_policy *policy);
+
+#endif /* OW_STEER_POLICY_PRIV_H */
Index: core/src/lib/ow/src/ow_steer_policy_snr_xing.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_snr_xing.c
@@ -0,0 +1,502 @@
+#include <stdbool.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <memutil.h>
+#include <const.h>
+#include <util.h>
+#include <log.h>
+#include <ds_dlist.h>
+#include <osw_util.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_stats.h>
+#include <osw_stats_defs.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_sta.h"
+#include "ow_steer_policy_snr_xing.h"
+
+#define OSW_STEER_POLICY_SNR_XING_SNR_BUF_SIZE 3
+#define OSW_STEER_POLICY_SNR_XING_DELTA_BYTES_BUF_SIZE 3
+
+struct ow_steer_policy_snr_xing_state {
+    unsigned int snr[OSW_STEER_POLICY_SNR_XING_SNR_BUF_SIZE];
+    struct osw_circ_buf snr_buf;
+
+    const struct osw_state_sta_info *sta_info;
+    enum ow_steer_policy_snr_xing_sta_type sta_type;
+
+    uint64_t delta_bytes[OSW_STEER_POLICY_SNR_XING_DELTA_BYTES_BUF_SIZE];
+    struct osw_circ_buf delta_bytes_buf;
+};
+
+struct ow_steer_policy_snr_xing {
+    struct ow_steer_policy *base;
+    struct ow_steer_policy_snr_xing_config config;
+    struct ow_steer_policy_snr_xing_state state;
+};
+
+#define OW_STEER_POLICY_SNR_XING_METRIC_VALUE 1
+
+static const char *g_policy_name = "ow_steer_policy_snr_xing";
+
+static void
+ow_steer_policy_snr_xing_state_reset(struct ow_steer_policy_snr_xing_state *state)
+{
+    ASSERT(state != NULL, "");
+
+    memset(state, 0, sizeof(*state));
+    osw_circ_buf_init(&state->snr_buf, OSW_STEER_POLICY_SNR_XING_SNR_BUF_SIZE);
+    osw_circ_buf_init(&state->delta_bytes_buf, OSW_STEER_POLICY_SNR_XING_DELTA_BYTES_BUF_SIZE);
+    state->sta_type = 0;
+}
+
+const char*
+ow_steer_policy_snr_xing_direction_to_cstr(enum ow_steer_policy_snr_xing_direction direction) {
+    switch (direction) {
+        case OW_STEER_POLICY_SNR_XING_UPPER:
+            return "upper";
+        case OW_STEER_POLICY_SNR_XING_LOWER:
+            return "lower";
+    }
+
+    return "unknown";
+}
+
+char*
+ow_steer_policy_snr_xing_sta_type_to_cstr(enum ow_steer_policy_snr_xing_sta_type sta_type)
+{
+    char *buf = NULL;
+
+    if ((sta_type & OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV) == OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV)
+        strgrow(&buf, "%s11kv", buf != NULL ? " " : "");
+    if ((sta_type & OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV) == OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV)
+        strgrow(&buf, "%snon11kv", buf != NULL ? " " : "");
+    if (buf == NULL)
+        strgrow(&buf, "unknown");
+
+    return buf;
+}
+
+static bool
+ow_steer_policy_snr_xing_check_sta_type_condition(const struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    const struct ow_steer_policy_snr_xing_config *config = &xing_policy->config;
+    const struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+
+    return (state->sta_type & config->sta_types) != 0 ? true : false;
+}
+
+static bool
+ow_steer_policy_snr_xing_eval_snr_condition(const struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    const struct ow_steer_policy_snr_xing_config *config = &xing_policy->config;
+    const struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    size_t i;
+    unsigned int snr;
+
+    if (osw_circ_buf_is_full(&state->snr_buf) == false)
+        return false;
+
+    i = osw_circ_buf_head(&state->snr_buf);
+    i = osw_circ_buf_next(&state->snr_buf, i);
+    snr = state->snr[i];
+
+    switch (config->condition.direction) {
+        case OW_STEER_POLICY_SNR_XING_UPPER:
+            return snr >= config->condition.snr ? true : false;
+        case OW_STEER_POLICY_SNR_XING_LOWER:
+            return snr <= config->condition.snr ? true : false;
+    }
+
+    WARN_ON(1);
+    return false;
+}
+
+static bool
+ow_steer_policy_snr_xing_eval_data_vol_limit_condition(const struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    const struct ow_steer_policy_snr_xing_config *config = &xing_policy->config;
+    const struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    size_t i;
+    uint64_t delta_bytes;
+
+    if (config->data_vol_limit.active == false)
+        return true;
+
+    if (osw_circ_buf_is_full(&state->delta_bytes_buf) == false)
+        return false;
+
+    i = osw_circ_buf_head(&state->delta_bytes_buf);
+    i = osw_circ_buf_next(&state->delta_bytes_buf, i);
+    delta_bytes = state->delta_bytes[i];
+
+    if (delta_bytes < config->data_vol_limit.delta_bytes)
+        return true;
+
+    return false;
+}
+
+static void
+ow_steer_policy_snr_xing_recalc_cb(struct ow_steer_policy *policy,
+                                   struct ow_steer_candidate_list *candidate_list)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(candidate_list != NULL, "");
+
+    struct ow_steer_policy_snr_xing *xing_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    const struct osw_hwaddr *policy_bssid;
+    size_t i;
+    bool result;
+
+    if (state->sta_info == NULL)
+        goto dismiss_executor;
+
+    result = ow_steer_policy_snr_xing_check_sta_type_condition(xing_policy);
+    if (result == false)
+        goto dismiss_executor;
+
+    result = ow_steer_policy_snr_xing_eval_snr_condition(xing_policy);
+    if (result == false)
+        goto dismiss_executor;
+
+    result = ow_steer_policy_snr_xing_eval_data_vol_limit_condition(xing_policy);
+    if (result == false)
+        goto dismiss_executor;
+
+    policy_bssid = ow_steer_policy_get_bssid(xing_policy->base);
+
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        struct ow_steer_candidate *candidate = ow_steer_candidate_list_get(candidate_list, i);
+        const struct osw_hwaddr *candidate_bssid = ow_steer_candidate_get_bssid(candidate);
+        const enum ow_steer_candidate_preference candidate_preference = ow_steer_candidate_get_preference(candidate);
+        bool skip_candidate = true;
+
+        if (osw_hwaddr_cmp(policy_bssid, candidate_bssid) == 0)
+            continue;
+
+        switch (candidate_preference) {
+            case OW_STEER_CANDIDATE_PREFERENCE_OUT_OF_SCOPE:
+            case OW_STEER_CANDIDATE_PREFERENCE_BLOCKED:
+                skip_candidate = true;
+                break;
+            case OW_STEER_CANDIDATE_PREFERENCE_NONE:
+            case OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE:
+                skip_candidate = false;
+                break;
+        }
+
+        if (skip_candidate == true)
+            continue;
+
+        ow_steer_candidate_inc_metric(candidate, OW_STEER_POLICY_SNR_XING_METRIC_VALUE);
+        LOGD("%s bssid: "OSW_HWADDR_FMT" inc metric", ow_steer_policy_get_prefix(policy), OSW_HWADDR_ARG(candidate_bssid));
+    }
+
+    ow_steer_policy_trigger_executor(policy);
+    return;
+
+dismiss_executor:
+    ow_steer_policy_dismiss_executor(policy);
+}
+
+static bool
+ow_steer_policy_snr_xing_check_snr_condition_change(const struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    const struct ow_steer_policy_snr_xing_config *config = &xing_policy->config;
+    const struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    unsigned int prev_snr;
+    unsigned int cur_snr;
+    unsigned int threshold;
+    size_t i;
+
+    if (osw_circ_buf_is_full(&state->snr_buf) == false)
+        return false;
+
+    i = osw_circ_buf_head(&state->snr_buf);
+    prev_snr = state->snr[i];
+    i = osw_circ_buf_next(&state->snr_buf, i);
+    cur_snr = state->snr[i];
+
+    threshold = config->condition.snr;
+    if (prev_snr < threshold && cur_snr >= threshold)
+        return true;
+    if (prev_snr > threshold && cur_snr <= threshold)
+        return true;
+
+    return false;
+}
+
+static bool
+ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(const struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    const struct ow_steer_policy_snr_xing_config *config = &xing_policy->config;
+    const struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    uint64_t prev_delta_bytes;
+    uint64_t cur_delta_bytes;
+    uint64_t threshold;
+    size_t i;
+
+    if (config->data_vol_limit.active == false)
+        return false;
+
+    if (osw_circ_buf_is_full(&state->delta_bytes_buf) == false)
+        return false;
+
+    i = osw_circ_buf_head(&state->delta_bytes_buf);
+    prev_delta_bytes = state->delta_bytes[i];
+    i = osw_circ_buf_next(&state->delta_bytes_buf, i);
+    cur_delta_bytes = state->delta_bytes[i];
+
+    threshold = config->data_vol_limit.delta_bytes;
+    if (prev_delta_bytes < threshold && cur_delta_bytes >= threshold)
+        return true;
+    if (prev_delta_bytes > threshold && cur_delta_bytes <= threshold)
+        return true;
+
+    return false;
+}
+
+static bool
+ow_steer_policy_snr_xing_check_condition_change(const struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    bool snr_xing_triggerd;
+    bool data_vol_limit_triggerd;
+    bool result;
+
+    result = ow_steer_policy_snr_xing_check_sta_type_condition(xing_policy);
+    if (result == false)
+        return false;
+
+    snr_xing_triggerd = ow_steer_policy_snr_xing_check_snr_condition_change(xing_policy);
+    if (snr_xing_triggerd == true)
+        LOGD("%s snr xing condition triggered", ow_steer_policy_get_prefix(xing_policy->base));
+
+    data_vol_limit_triggerd = ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(xing_policy);
+    if (data_vol_limit_triggerd == true)
+        LOGD("%s data vol limit condition triggered", ow_steer_policy_get_prefix(xing_policy->base));
+
+    return snr_xing_triggerd || data_vol_limit_triggerd;
+}
+
+static void
+ow_steer_policy_snr_xing_sta_connected_cb(struct ow_steer_policy *policy,
+                                          const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_policy_snr_xing *xing_policy = ow_steer_policy_get_priv(policy);
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    struct osw_assoc_req_info assoc_req_info;
+    bool result;
+
+    if (WARN_ON(state->sta_info != NULL))
+        return;
+
+    ow_steer_policy_snr_xing_state_reset(&xing_policy->state);
+    state->sta_info = sta_info;
+
+    result = osw_parse_assoc_req_ies(sta_info->assoc_req_ies, sta_info->assoc_req_ies_len, &assoc_req_info);
+    if (result == false) {
+        LOGW("%s failed to parse assoc req ies upon connection", ow_steer_policy_get_prefix(policy));
+        return;
+    }
+
+    if (assoc_req_info.wnm_bss_trans == true && assoc_req_info.rrm_neighbor_report == true)
+        state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV;
+    else
+        state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+
+    LOGD("%s sta connected, sta_type: %s", ow_steer_policy_get_prefix(policy),
+         strdupafree(ow_steer_policy_snr_xing_sta_type_to_cstr(state->sta_type)));
+}
+
+static void
+ow_steer_policy_snr_xing_sta_disconnected_cb(struct ow_steer_policy *policy,
+                                             const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_policy_snr_xing *xing_policy = ow_steer_policy_get_priv(policy);
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+
+    WARN_ON(state->sta_info != NULL);
+
+    ow_steer_policy_snr_xing_state_reset(&xing_policy->state);
+    ow_steer_policy_schedule_stack_recalc(policy);
+
+    LOGD("%s sta disconnected", ow_steer_policy_get_prefix(policy));
+}
+
+static void
+ow_steer_policy_snr_xing_sta_snr_change_cb(struct ow_steer_policy *policy,
+                                           const struct osw_hwaddr *bssid,
+                                           uint32_t snr_db)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(bssid != NULL, "");
+
+    struct ow_steer_policy_snr_xing *xing_policy = ow_steer_policy_get_priv(policy);
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    size_t i;
+    bool result;
+
+    if (state->sta_info == NULL)
+        return;
+
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = snr_db;
+
+    result = ow_steer_policy_snr_xing_check_condition_change(xing_policy);
+    if (result == false)
+        return;
+
+    ow_steer_policy_schedule_stack_recalc(policy);
+}
+
+static void
+ow_steer_policy_snr_xing_sta_data_vol_change_cb(struct ow_steer_policy *policy,
+                                                const struct osw_hwaddr *bssid,
+                                                uint64_t data_vol_bytes)
+{
+    ASSERT(policy != NULL, "");
+    ASSERT(bssid != NULL, "");
+
+    struct ow_steer_policy_snr_xing *xing_policy = ow_steer_policy_get_priv(policy);
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    size_t i;
+    bool result;
+
+    if (state->sta_info == NULL)
+        return;
+
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = data_vol_bytes;
+
+    result = ow_steer_policy_snr_xing_check_condition_change(xing_policy);
+    if (result == false)
+        return;
+
+    ow_steer_policy_schedule_stack_recalc(policy);
+}
+
+static void
+ow_steer_policy_snr_xing_sigusr1_dump_cb(struct ow_steer_policy *policy)
+{
+    ASSERT(policy != NULL, "");
+
+    struct ow_steer_policy_snr_xing *xing_policy = ow_steer_policy_get_priv(policy);
+    const struct ow_steer_policy_snr_xing_config *config = &xing_policy->config;
+    const struct ow_steer_policy_snr_xing_state *state = &xing_policy->state;
+    size_t i = 0;
+    char *buf = NULL;
+
+    LOGI("ow: steer:           config:");
+    LOGI("ow: steer:             bssid: "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&config->bssid));
+    LOGI("ow: steer:             condition:");
+    LOGI("ow: steer:               direction: %s", ow_steer_policy_snr_xing_direction_to_cstr(config->condition.direction));
+    LOGI("ow: steer:               snr: %u", config->condition.snr);
+    LOGI("ow: steer:             sta_types: %s", strdupafree(ow_steer_policy_snr_xing_sta_type_to_cstr(config->sta_types)));
+    LOGI("ow: steer:             data_vol_limit:");
+    LOGI("ow: steer:               active: %s", config->data_vol_limit.active == true ? "true" : "false");
+    LOGI("ow: steer:               delta_bytes: %"PRIu64, config->data_vol_limit.delta_bytes);
+    LOGI("ow: steer:           state:");
+
+    OSW_CIRC_BUF_FOREACH(&state->snr_buf, i)
+        strgrow(&buf, "%s%u", buf != NULL ? " " : "", state->snr[i]);
+
+    LOGI("ow: steer:             snr: %s", buf);
+    FREE(buf);
+    buf = NULL;
+
+    LOGI("ow: steer:             sta_info: %s", state->sta_info != NULL ? "set" : "not set");
+    LOGI("ow: steer:             sta_type: %s", strdupafree(ow_steer_policy_snr_xing_sta_type_to_cstr(state->sta_type)));
+
+    OSW_CIRC_BUF_FOREACH(&state->snr_buf, i)
+        strgrow(&buf, "%s%"PRIu64, buf != NULL ? " " : "", state->delta_bytes[i]);
+
+    LOGI("ow: steer:             delta_bytes: %s", buf);
+    FREE(buf);
+    buf = NULL;
+}
+
+struct ow_steer_policy_snr_xing*
+ow_steer_policy_snr_xing_create(unsigned int priority,
+                                const char *name,
+                                const struct osw_hwaddr *sta_addr,
+                                const struct ow_steer_policy_mediator *mediator)
+{
+    ASSERT(name != NULL, "");
+    ASSERT(sta_addr != NULL, "");
+    ASSERT(mediator != NULL, "");
+
+    const struct ow_steer_policy_ops policy_ops = {
+        .sigusr1_dump_fn = ow_steer_policy_snr_xing_sigusr1_dump_cb,
+        .recalc_fn = ow_steer_policy_snr_xing_recalc_cb,
+        .sta_connected_fn = ow_steer_policy_snr_xing_sta_connected_cb,
+        .sta_disconnected_fn = ow_steer_policy_snr_xing_sta_disconnected_cb,
+        .sta_snr_change_fn = ow_steer_policy_snr_xing_sta_snr_change_cb,
+        .sta_data_vol_change_fn = ow_steer_policy_snr_xing_sta_data_vol_change_cb,
+    };
+
+    struct ow_steer_policy_snr_xing *xing_policy = CALLOC(1, sizeof(*xing_policy));
+
+    xing_policy->base = ow_steer_policy_create(strfmta("%s_%s", g_policy_name, name), priority, sta_addr, &policy_ops, mediator, xing_policy);
+    ow_steer_policy_snr_xing_state_reset(&xing_policy->state);
+
+    return xing_policy;
+}
+
+void
+ow_steer_policy_snr_xing_free(struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    ow_steer_policy_free(xing_policy->base);
+    FREE(xing_policy);
+}
+
+struct ow_steer_policy*
+ow_steer_policy_snr_xing_get_base(struct ow_steer_policy_snr_xing *xing_policy)
+{
+    ASSERT(xing_policy != NULL, "");
+    return xing_policy->base;
+}
+
+void
+ow_steer_policy_snr_xing_set_config(struct ow_steer_policy_snr_xing *xing_policy,
+                                    const struct ow_steer_policy_snr_xing_config *config)
+{
+    ASSERT(xing_policy != NULL, "");
+
+    if (config != NULL && memcmp(&xing_policy->config, config, sizeof(xing_policy->config)) == 0)
+        return;
+
+    LOGI("%s config changed", ow_steer_policy_get_prefix(xing_policy->base));
+
+    if (config != NULL) {
+        memcpy(&xing_policy->config, config, sizeof(xing_policy->config));
+        ow_steer_policy_set_bssid(xing_policy->base, &xing_policy->config.bssid);
+    }
+
+    ow_steer_policy_snr_xing_state_reset(&xing_policy->state);
+    ow_steer_policy_set_active(xing_policy->base, config != NULL);
+}
+
+#include "ow_steer_policy_snr_xing_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_snr_xing.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_snr_xing.h
@@ -0,0 +1,49 @@
+#ifndef OW_STEER_POLICY_SNR_XING_H
+#define OW_STEER_POLICY_SNR_XING_H
+
+enum ow_steer_policy_snr_xing_direction {
+    OW_STEER_POLICY_SNR_XING_UPPER,
+    OW_STEER_POLICY_SNR_XING_LOWER,
+};
+
+struct ow_steer_policy_snr_xing_condition {
+    enum ow_steer_policy_snr_xing_direction direction;
+    unsigned int snr;
+};
+
+enum ow_steer_policy_snr_xing_sta_type {
+    OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV = (1 << 0),
+    OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV = (1 << 1),
+};
+
+struct ow_steer_policy_snr_xing_data_vol_limit {
+    bool active;
+    uint64_t delta_bytes;
+};
+
+struct ow_steer_policy_snr_xing_config {
+    struct osw_hwaddr bssid;
+    struct ow_steer_policy_snr_xing_condition condition;
+    enum ow_steer_policy_snr_xing_sta_type sta_types;
+    struct ow_steer_policy_snr_xing_data_vol_limit data_vol_limit;
+};
+
+struct ow_steer_policy_snr_xing;
+
+struct ow_steer_policy_snr_xing*
+ow_steer_policy_snr_xing_create(unsigned int priority,
+                                const char *name,
+                                const struct osw_hwaddr *sta_addr,
+                                const struct ow_steer_policy_mediator *mediator);
+
+void
+ow_steer_policy_snr_xing_free(struct ow_steer_policy_snr_xing *xing_policy);
+
+struct ow_steer_policy*
+ow_steer_policy_snr_xing_get_base(struct ow_steer_policy_snr_xing *xing_policy);
+
+void
+ow_steer_policy_snr_xing_set_config(struct ow_steer_policy_snr_xing *xing_policy,
+                                    const struct ow_steer_policy_snr_xing_config *config);
+
+#endif /* OW_STEER_POLICY_SNR_XING_H */
Index: core/src/lib/ow/src/ow_steer_policy_snr_xing_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_snr_xing_ut.c
@@ -0,0 +1,684 @@
+#include <osw_ut.h>
+#include "ow_steer_policy_i.h"
+
+/* From osw_util */
+extern const uint8_t osw_util_ut_non_11kv_assoc_ies[];
+extern const size_t osw_util_ut_non_11kv_assoc_ies_len;
+extern const uint8_t osw_util_ut_11kv_assoc_ies[];
+extern const size_t osw_util_ut_11kv_assoc_ies_len;
+
+static void
+ow_steer_policy_snr_xing_ut_mediator_sched_stack_recalc(struct ow_steer_policy *policy,
+                                                        void *priv)
+{
+    OSW_UT_EVAL(priv != NULL);
+    unsigned int *cnt = priv;
+    *cnt = *cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_check_sta_type)
+{
+    struct ow_steer_policy_snr_xing xing_policy;
+    struct ow_steer_policy_snr_xing_config *config = &xing_policy.config;
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy.state;
+
+    memset(&xing_policy, 0, sizeof(xing_policy));
+
+    /*
+     * 11kv STA
+     */
+    config->sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV;
+    state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_sta_type_condition(&xing_policy) == true);
+
+    config->sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+    state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_sta_type_condition(&xing_policy) == false);
+
+    config->sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV | OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+    state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_sta_type_condition(&xing_policy) == true);
+
+    /*
+     * non-11kv STA
+     */
+    config->sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV;
+    state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_sta_type_condition(&xing_policy) == false);
+
+    config->sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+    state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_sta_type_condition(&xing_policy) == true);
+
+    config->sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV | OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+    state->sta_type = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_sta_type_condition(&xing_policy) == true);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_snr_condition_upper_xing)
+{
+    struct ow_steer_policy_snr_xing xing_policy;
+    struct ow_steer_policy_snr_xing_config *config = &xing_policy.config;
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy.state;
+    size_t i;
+
+    memset(&xing_policy, 0, sizeof(xing_policy));
+
+    ow_steer_policy_snr_xing_state_reset(state);
+    config->condition.direction = OW_STEER_POLICY_SNR_XING_UPPER;
+    config->condition.snr = 100;
+
+    /* Add first sample (below threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 90;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == false);
+
+    /* Add next sample (below threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 95;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == false);
+
+    /* Add next sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 105;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == true);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == true);
+
+    /* Add next sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 110;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == true);
+
+    /* Add next sample (below threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 90;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == true);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == false);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_snr_condition_lower_xing)
+{
+    struct ow_steer_policy_snr_xing xing_policy;
+    struct ow_steer_policy_snr_xing_config *config = &xing_policy.config;
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy.state;
+    size_t i;
+
+    memset(&xing_policy, 0, sizeof(xing_policy));
+
+    ow_steer_policy_snr_xing_state_reset(state);
+    config->condition.direction = OW_STEER_POLICY_SNR_XING_LOWER;
+    config->condition.snr = 100;
+
+    /* Add first sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 110;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == false);
+
+    /* Add next sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 105;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == false);
+
+    /* Add next sample (below threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 95;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == true);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == true);
+
+    /* Add next sample (below threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 90;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == true);
+
+    /* Add next sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->snr_buf);
+    state->snr[i] = 105;
+
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_snr_condition_change(&xing_policy) == true);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_snr_condition(&xing_policy) == false);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_data_vol_limit_condition_disabled_limit)
+{
+    struct ow_steer_policy_snr_xing xing_policy;
+    struct ow_steer_policy_snr_xing_config *config = &xing_policy.config;
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy.state;
+    size_t i;
+
+    memset(&xing_policy, 0, sizeof(xing_policy));
+
+    ow_steer_policy_snr_xing_state_reset(state);
+    config->data_vol_limit.active = false;
+    config->data_vol_limit.delta_bytes = 100;
+
+    /* Add few samples */
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 90;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == true);
+
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 95;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == true);
+
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 100;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == true);
+
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 105;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == true);
+
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 95;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == true);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_data_vol_limit_condition_enabled_limit)
+{
+    struct ow_steer_policy_snr_xing xing_policy;
+    struct ow_steer_policy_snr_xing_config *config = &xing_policy.config;
+    struct ow_steer_policy_snr_xing_state *state = &xing_policy.state;
+    size_t i;
+
+    memset(&xing_policy, 0, sizeof(xing_policy));
+
+    ow_steer_policy_snr_xing_state_reset(state);
+    config->data_vol_limit.active = true;
+    config->data_vol_limit.delta_bytes = 100;
+
+    /* Add first sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 105;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == false);
+
+    /* Add next sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 110;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == false);
+
+    /* Add next sample (below threshold) */
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 90;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == true);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == true);
+
+    /* Add next sample (below threshold) */
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 90;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == false);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == true);
+
+    /* Add next sample (above threshold) */
+    i = osw_circ_buf_push_rotate(&state->delta_bytes_buf);
+    state->delta_bytes[i] = 130;
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_check_data_vol_limit_condition_change(&xing_policy) == true);
+    OSW_UT_EVAL(ow_steer_policy_snr_xing_eval_data_vol_limit_condition(&xing_policy) == false);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_hwm)
+{
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct osw_hwaddr bssid = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr other_bssid = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr sta_addr = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    struct osw_drv_vif_state drv_vif_state = {
+        .mac_addr = bssid,
+    };
+    struct osw_state_vif_info vif = {
+        .vif_name = "vif_0",
+        .drv_state = &drv_vif_state,
+    };
+    struct osw_state_sta_info sta_info = {
+        .mac_addr = &sta_addr,
+        .vif = &vif,
+        .assoc_req_ies = &osw_util_ut_11kv_assoc_ies,
+        .assoc_req_ies_len = osw_util_ut_11kv_assoc_ies_len,
+    };
+    struct ow_steer_policy_snr_xing_config config = {
+        .bssid = bssid,
+        .condition = {
+            .direction = OW_STEER_POLICY_SNR_XING_UPPER,
+            .snr = 50,
+        },
+        .sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV | OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV,
+        .data_vol_limit = {
+            .active = true,
+            .delta_bytes = 2000,
+        },
+    };
+    unsigned int schedule_recalc_cnt = 0;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_snr_xing_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_snr_xing *xing_policy;
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_candidate *candidate_cur;
+    struct ow_steer_candidate *candidate_other;
+
+    /*
+     * Setup
+     */
+    xing_policy = ow_steer_policy_snr_xing_create(0, "hwm", &sta_addr, &mediator);
+    OSW_UT_EVAL(xing_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_snr_xing_set_config(xing_policy, &config);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &other_bssid, &channel);
+
+    candidate_cur = ow_steer_candidate_list_lookup(candidate_list, &bssid);
+    candidate_other = ow_steer_candidate_list_lookup(candidate_list, &other_bssid);
+
+    /*
+     * Connect 11kv STA
+     */
+    xing_policy->base->ops.sta_connected_fn(xing_policy->base, &sta_info);
+
+    /*
+     * Report stats (low SNR, high data vol diff)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 40);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report the same stats
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 40);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report high SNR (>HWM)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 60);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report low data vol diff
+     */
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 1000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 1);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_lwm)
+{
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct osw_hwaddr bssid = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr other_bssid = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr sta_addr = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    struct osw_drv_vif_state drv_vif_state = {
+        .mac_addr = bssid,
+    };
+    struct osw_state_vif_info vif = {
+        .vif_name = "vif_0",
+        .drv_state = &drv_vif_state,
+    };
+    struct osw_state_sta_info sta_info = {
+        .mac_addr = &sta_addr,
+        .vif = &vif,
+        .assoc_req_ies = &osw_util_ut_11kv_assoc_ies,
+        .assoc_req_ies_len = osw_util_ut_11kv_assoc_ies_len,
+    };
+    struct ow_steer_policy_snr_xing_config config = {
+        .bssid = bssid,
+        .condition = {
+            .direction = OW_STEER_POLICY_SNR_XING_LOWER,
+            .snr = 50,
+        },
+        .sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV | OW_STEER_POLICY_SNR_XING_STA_TYPE_11KV,
+        .data_vol_limit = {
+            .active = true,
+            .delta_bytes = 2000,
+        },
+    };
+    unsigned int schedule_recalc_cnt = 0;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_snr_xing_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_snr_xing *xing_policy;
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_candidate *candidate_cur;
+    struct ow_steer_candidate *candidate_other;
+
+    /*
+     * Setup
+     */
+    xing_policy = ow_steer_policy_snr_xing_create(0, "lwm", &sta_addr, &mediator);
+    OSW_UT_EVAL(xing_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_snr_xing_set_config(xing_policy, &config);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &other_bssid, &channel);
+
+    candidate_cur = ow_steer_candidate_list_lookup(candidate_list, &bssid);
+    candidate_other = ow_steer_candidate_list_lookup(candidate_list, &other_bssid);
+
+    /*
+     * Connect 11kv STA
+     */
+    xing_policy->base->ops.sta_connected_fn(xing_policy->base, &sta_info);
+
+    /*
+     * Report stats (high SNR, high data vol diff)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 65);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report the same stats
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 65);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report low SNR (<LWM)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 40);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report low data vol diff
+     */
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 1000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 3);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 1);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_bottom_lwm_11kv_sta)
+{
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct osw_hwaddr bssid = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr other_bssid = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr sta_addr = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    struct osw_drv_vif_state drv_vif_state = {
+        .mac_addr = bssid,
+    };
+    struct osw_state_vif_info vif = {
+        .vif_name = "vif_0",
+        .drv_state = &drv_vif_state,
+    };
+    struct osw_state_sta_info sta_info = {
+        .mac_addr = &sta_addr,
+        .vif = &vif,
+        .assoc_req_ies = &osw_util_ut_11kv_assoc_ies,
+        .assoc_req_ies_len = osw_util_ut_11kv_assoc_ies_len,
+    };
+    struct ow_steer_policy_snr_xing_config config = {
+        .bssid = bssid,
+        .condition = {
+            .direction = OW_STEER_POLICY_SNR_XING_LOWER,
+            .snr = 50,
+        },
+        .sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV,
+        .data_vol_limit = {
+            .active = false,
+            .delta_bytes = 0,
+        },
+    };
+    unsigned int schedule_recalc_cnt = 0;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_snr_xing_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_snr_xing *xing_policy;
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_candidate *candidate_cur;
+    struct ow_steer_candidate *candidate_other;
+
+    /*
+     * Setup
+     */
+    xing_policy = ow_steer_policy_snr_xing_create(0, "lwm", &sta_addr, &mediator);
+    OSW_UT_EVAL(xing_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_snr_xing_set_config(xing_policy, &config);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &other_bssid, &channel);
+
+    candidate_cur = ow_steer_candidate_list_lookup(candidate_list, &bssid);
+    candidate_other = ow_steer_candidate_list_lookup(candidate_list, &other_bssid);
+
+    /*
+     * Connect 11kv STA
+     */
+    xing_policy->base->ops.sta_connected_fn(xing_policy->base, &sta_info);
+
+    /*
+     * Report stats (high SNR, high data vol diff)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 65);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report the same stats
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 65);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report low SNR (<Bottom LWM)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 40);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+}
+
+OSW_UT(ow_steer_policy_snr_xing_ut_bottom_lwm_non_11kv_sta)
+{
+    const struct osw_channel channel = { .width = OSW_CHANNEL_20MHZ, .control_freq_mhz = 2412, };
+    const struct osw_hwaddr bssid = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, }, };
+    const struct osw_hwaddr other_bssid = { .octet = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, }, };
+    const struct osw_hwaddr sta_addr = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, }, };
+    struct osw_drv_vif_state drv_vif_state = {
+        .mac_addr = bssid,
+    };
+    struct osw_state_vif_info vif = {
+        .vif_name = "vif_0",
+        .drv_state = &drv_vif_state,
+    };
+    struct osw_state_sta_info sta_info = {
+        .mac_addr = &sta_addr,
+        .vif = &vif,
+        .assoc_req_ies = &osw_util_ut_non_11kv_assoc_ies,
+        .assoc_req_ies_len = osw_util_ut_non_11kv_assoc_ies_len,
+    };
+    struct ow_steer_policy_snr_xing_config config = {
+        .bssid = bssid,
+        .condition = {
+            .direction = OW_STEER_POLICY_SNR_XING_LOWER,
+            .snr = 50,
+        },
+        .sta_types = OW_STEER_POLICY_SNR_XING_STA_TYPE_NON_11KV,
+        .data_vol_limit = {
+            .active = false,
+            .delta_bytes = 0,
+        },
+    };
+    unsigned int schedule_recalc_cnt = 0;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_snr_xing_ut_mediator_sched_stack_recalc,
+        .priv = &schedule_recalc_cnt,
+    };
+    struct ow_steer_policy_snr_xing *xing_policy;
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_candidate *candidate_cur;
+    struct ow_steer_candidate *candidate_other;
+
+    /*
+     * Setup
+     */
+    xing_policy = ow_steer_policy_snr_xing_create(0, "lwm", &sta_addr, &mediator);
+    OSW_UT_EVAL(xing_policy != NULL);
+    OSW_UT_EVAL(schedule_recalc_cnt == 0);
+
+    ow_steer_policy_snr_xing_set_config(xing_policy, &config);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    candidate_list = ow_steer_candidate_list_new();
+    ow_steer_candidate_list_bss_set(candidate_list, &bssid, &channel);
+    ow_steer_candidate_list_bss_set(candidate_list, &other_bssid, &channel);
+
+    candidate_cur = ow_steer_candidate_list_lookup(candidate_list, &bssid);
+    candidate_other = ow_steer_candidate_list_lookup(candidate_list, &other_bssid);
+
+    /*
+     * Connect non-11kv STA
+     */
+    xing_policy->base->ops.sta_connected_fn(xing_policy->base, &sta_info);
+
+    /*
+     * Report stats (high SNR, high data vol diff)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 65);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report the same stats
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 65);
+    xing_policy->base->ops.sta_data_vol_change_fn(xing_policy->base, &bssid, 3000);
+    OSW_UT_EVAL(schedule_recalc_cnt == 1);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 0);
+
+    /*
+     * Report low SNR (<Bottom LWM)
+     */
+    xing_policy->base->ops.sta_snr_change_fn(xing_policy->base, &bssid, 40);
+    OSW_UT_EVAL(schedule_recalc_cnt == 2);
+
+    ow_steer_candidate_list_clear(candidate_list);
+    xing_policy->base->ops.recalc_fn(xing_policy->base, candidate_list);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_cur) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_cur) == 0);
+    OSW_UT_EVAL(ow_steer_candidate_get_preference(candidate_other) == OW_STEER_CANDIDATE_PREFERENCE_NONE);
+    OSW_UT_EVAL(ow_steer_candidate_get_metric(candidate_other) == 1);
+}
Index: core/src/lib/ow/src/ow_steer_policy_stack.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_stack.c
@@ -0,0 +1,298 @@
+#include <assert.h>
+#include <log.h>
+#include <const.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <memutil.h>
+#include <module.h>
+#include <osw_timer.h>
+#include <osw_state.h>
+#include <osw_bss_map.h>
+#include <osw_conf.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_policy_i.h"
+#include "ow_steer_policy_priv.h"
+#include "ow_steer_sta.h"
+#include "ow_steer_sta_priv.h"
+#include "ow_steer_policy_stack.h"
+
+struct ow_steer_policy_stack {
+    struct ds_dlist policy_list;
+    struct ow_steer_sta *sta;
+    struct osw_timer work;
+};
+
+static void
+ow_steer_policy_stack_work_cb(struct osw_timer *timer)
+{
+    struct ow_steer_policy_stack *stack = container_of(timer, struct ow_steer_policy_stack, work);
+    const struct osw_hwaddr *mac_addr = ow_steer_sta_get_addr(stack->sta);
+    struct ow_steer_candidate_list *candidate_list = ow_steer_sta_get_candidate_list(stack->sta);
+    struct ow_steer_candidate_list *candidate_list_copy = ow_steer_candidate_list_copy(candidate_list);
+    struct ow_steer_policy *policy;
+    size_t i;
+
+    LOGI("ow: steer: policy_stack: sta: "OSW_HWADDR_FMT" recalc candidates", OSW_HWADDR_ARG(mac_addr));
+    ow_steer_candidate_list_clear(candidate_list);
+
+    ds_dlist_foreach(&stack->policy_list, policy) {
+        if (policy->active == false)
+            continue;
+        if (WARN_ON(policy->ops.recalc_fn == NULL))
+            continue;
+
+        policy->ops.recalc_fn(policy, candidate_list);
+    }
+
+    for (i = 0; i < ow_steer_candidate_list_get_length(candidate_list); i++) {
+        struct ow_steer_candidate *candidate = ow_steer_candidate_list_get(candidate_list, i);
+        const struct osw_hwaddr *bssid = ow_steer_candidate_get_bssid(candidate);
+        enum ow_steer_candidate_preference preference = ow_steer_candidate_get_preference(candidate);
+
+        if (preference == OW_STEER_CANDIDATE_PREFERENCE_NONE) {
+            ow_steer_candidate_set_preference(candidate, OW_STEER_CANDIDATE_PREFERENCE_AVAILABLE);
+            preference = ow_steer_candidate_get_preference(candidate);
+        }
+
+        LOGI("ow: steer: policy_stack: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" preference: %s",
+             OSW_HWADDR_ARG(mac_addr), OSW_HWADDR_ARG(bssid),
+             ow_steer_candidate_preference_to_cstr(preference));
+     }
+
+    if (ow_steer_candidate_list_cmp(candidate_list, candidate_list_copy) == false)
+        ow_steer_sta_schedule_executor_chain_call(stack->sta);
+
+    ow_steer_candidate_list_free(candidate_list_copy);
+}
+
+struct ow_steer_policy_stack*
+ow_steer_policy_stack_create(struct ow_steer_sta *sta)
+{
+    assert(sta != NULL);
+
+    struct ow_steer_policy_stack *stack = CALLOC(1, sizeof(*stack));
+
+    ds_dlist_init(&stack->policy_list, struct ow_steer_policy, stack_node);
+    stack->sta = sta;
+    osw_timer_init(&stack->work, ow_steer_policy_stack_work_cb);
+
+    return stack;
+}
+
+void
+ow_steer_policy_stack_free(struct ow_steer_policy_stack *stack)
+{
+    assert(stack != NULL);
+
+    osw_timer_disarm(&stack->work);
+    assert(ds_dlist_is_empty(&stack->policy_list) == true);
+    FREE(stack);
+}
+
+void
+ow_steer_policy_stack_add(struct ow_steer_policy_stack *stack,
+                          struct ow_steer_policy *policy)
+{
+    assert(stack != NULL);
+    assert(policy != NULL);
+
+    struct ow_steer_policy *entry;
+
+    ds_dlist_foreach(&stack->policy_list, entry)
+        if (policy->priority <= entry->priority)
+            break;
+
+    if (entry == NULL)
+        ds_dlist_insert_tail(&stack->policy_list, policy);
+    else
+        ds_dlist_insert_before(&stack->policy_list, entry, policy);
+
+    ow_steer_policy_stack_schedule_recalc(stack);
+}
+
+void
+ow_steer_policy_stack_remove(struct ow_steer_policy_stack *stack,
+                             struct ow_steer_policy *policy)
+{
+    assert(stack != NULL);
+    assert(policy != NULL);
+
+    ds_dlist_remove(&stack->policy_list, policy);
+    ow_steer_policy_stack_schedule_recalc(stack);
+}
+
+bool
+ow_steer_policy_stack_is_empty(struct ow_steer_policy_stack *stack)
+{
+    assert(stack != NULL);
+    return ds_dlist_is_empty(&stack->policy_list);
+}
+
+void
+ow_steer_policy_stack_schedule_recalc(struct ow_steer_policy_stack *stack)
+{
+    assert(stack != NULL);
+    osw_timer_arm_at_nsec(&stack->work, 0);
+}
+
+void
+ow_steer_policy_stack_sigusr1_dump(struct ow_steer_policy_stack *stack)
+{
+    assert(stack != NULL);
+
+    struct ow_steer_policy *policy;
+
+    LOGI("ow: steer:       policies:");
+    ds_dlist_foreach(&stack->policy_list, policy) {
+        LOGI("ow: steer:         policy: name: %s", policy->name);
+        LOGI("ow: steer:           active: %s", ow_steer_policy_get_active(policy) == true ? "true" : "false");
+        LOGI("ow: steer:           priority: %u", ow_steer_policy_get_priority(policy));
+        LOGI("ow: steer:           bssid: "OSW_HWADDR_FMT, OSW_HWADDR_ARG(ow_steer_policy_get_bssid(policy)));
+        if (policy->ops.sigusr1_dump_fn != NULL)
+            policy->ops.sigusr1_dump_fn(policy);
+    }
+}
+
+void
+ow_steer_policy_stack_sta_connected(struct ow_steer_policy_stack *stack,
+                                    const struct osw_state_sta_info *sta_info)
+{
+    assert(stack != NULL);
+    assert(sta_info != NULL);
+
+    const struct osw_hwaddr wildcard_bssid = OSW_HWADDR_BROADCAST;
+    const struct osw_hwaddr *bssid = &sta_info->vif->drv_state->mac_addr;
+    struct ow_steer_policy *policy;
+
+    ds_dlist_foreach(&stack->policy_list, policy) {
+        const struct osw_hwaddr *policy_bssid = NULL;
+
+        if (policy->active == false)
+            continue;
+        if (policy->ops.sta_connected_fn == NULL)
+            continue;
+
+        policy_bssid = ow_steer_policy_get_bssid(policy);
+        if (osw_hwaddr_cmp(policy_bssid, bssid) != 0 && osw_hwaddr_cmp(policy_bssid, &wildcard_bssid) != 0)
+            continue;
+
+        policy->ops.sta_connected_fn(policy, sta_info);
+    }
+}
+
+void
+ow_steer_policy_stack_sta_disconnected(struct ow_steer_policy_stack *stack,
+                                       const struct osw_state_sta_info *sta_info)
+{
+    assert(stack != NULL);
+    assert(sta_info != NULL);
+
+    const struct osw_hwaddr wildcard_bssid = OSW_HWADDR_BROADCAST;
+    const struct osw_hwaddr *bssid = &sta_info->vif->drv_state->mac_addr;
+    struct ow_steer_policy *policy;
+
+    ds_dlist_foreach(&stack->policy_list, policy) {
+        const struct osw_hwaddr *policy_bssid = NULL;
+
+        if (policy->active == false)
+            continue;
+        if (policy->ops.sta_disconnected_fn == NULL)
+            continue;
+
+        policy_bssid = ow_steer_policy_get_bssid(policy);
+        if (osw_hwaddr_cmp(policy_bssid, bssid) != 0 && osw_hwaddr_cmp(policy_bssid, &wildcard_bssid) != 0)
+            continue;
+
+        policy->ops.sta_disconnected_fn(policy, sta_info);
+    }
+}
+
+void
+ow_steer_policy_stack_vif_probe_req(struct ow_steer_policy_stack *stack,
+                                    const struct osw_state_vif_info *vif_info,
+                                    const struct osw_drv_report_vif_probe_req *probe_req)
+{
+    assert(stack != NULL);
+    assert(vif_info != NULL);
+    assert(probe_req != NULL);
+
+    const struct osw_hwaddr wildcard_bssid = OSW_HWADDR_BROADCAST;
+    const struct osw_hwaddr *bssid = &vif_info->drv_state->mac_addr;
+    struct ow_steer_policy *policy;
+
+    ds_dlist_foreach(&stack->policy_list, policy) {
+        const struct osw_hwaddr *policy_bssid = NULL;
+
+        if (policy->active == false)
+            continue;
+        if (policy->ops.vif_probe_req_fn == NULL)
+            continue;
+
+        policy_bssid = ow_steer_policy_get_bssid(policy);
+        if (osw_hwaddr_cmp(policy_bssid, bssid) != 0 && osw_hwaddr_cmp(policy_bssid, &wildcard_bssid) != 0)
+            continue;
+
+        policy->ops.vif_probe_req_fn(policy, vif_info, probe_req);
+    }
+}
+
+void
+ow_steer_policy_stack_sta_snr_change(struct ow_steer_policy_stack *stack,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct osw_hwaddr *bssid,
+                                     uint32_t snr_db)
+{
+    assert(stack != NULL);
+    assert(sta_addr != NULL);
+    assert(bssid != NULL);
+
+    const struct osw_hwaddr wildcard_bssid = OSW_HWADDR_BROADCAST;
+    struct ow_steer_policy *policy;
+
+    ds_dlist_foreach(&stack->policy_list, policy) {
+        const struct osw_hwaddr *policy_bssid = NULL;
+
+        if (policy->active == false)
+            continue;
+        if (policy->ops.sta_snr_change_fn == NULL)
+            continue;
+
+        policy_bssid = ow_steer_policy_get_bssid(policy);
+        if (osw_hwaddr_cmp(policy_bssid, bssid) != 0 && osw_hwaddr_cmp(policy_bssid, &wildcard_bssid) != 0)
+            continue;
+
+        policy->ops.sta_snr_change_fn(policy, bssid, snr_db);
+    }
+}
+
+void
+ow_steer_policy_stack_sta_data_vol_change(struct ow_steer_policy_stack *stack,
+                                          const struct osw_hwaddr *sta_addr,
+                                          const struct osw_hwaddr *bssid,
+                                          uint64_t data_vol_bytes)
+{
+    assert(stack != NULL);
+    assert(sta_addr != NULL);
+    assert(bssid != NULL);
+
+    const struct osw_hwaddr wildcard_bssid = OSW_HWADDR_BROADCAST;
+    struct ow_steer_policy *policy;
+
+    ds_dlist_foreach(&stack->policy_list, policy) {
+        const struct osw_hwaddr *policy_bssid = NULL;
+
+        if (policy->active == false)
+            continue;
+        if (policy->ops.sta_data_vol_change_fn == NULL)
+            continue;
+
+        policy_bssid = ow_steer_policy_get_bssid(policy);
+        if (osw_hwaddr_cmp(policy_bssid, bssid) != 0 && osw_hwaddr_cmp(policy_bssid, &wildcard_bssid) != 0)
+            continue;
+
+        policy->ops.sta_data_vol_change_fn(policy, bssid, data_vol_bytes);
+    }
+}
+
+#include "ow_steer_policy_stack_ut.c"
Index: core/src/lib/ow/src/ow_steer_policy_stack.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_stack.h
@@ -0,0 +1,54 @@
+#ifndef OW_STEER_POLICY_STACK_H
+#define OW_STEER_POLICY_STACK_H
+
+struct ow_steer_policy_stack;
+
+struct ow_steer_policy_stack*
+ow_steer_policy_stack_create(struct ow_steer_sta *sta);
+
+void
+ow_steer_policy_stack_free(struct ow_steer_policy_stack *stack);
+
+void
+ow_steer_policy_stack_add(struct ow_steer_policy_stack *stack,
+                          struct ow_steer_policy *policy);
+
+void
+ow_steer_policy_stack_remove(struct ow_steer_policy_stack *stack,
+                             struct ow_steer_policy *policy);
+
+bool
+ow_steer_policy_stack_is_empty(struct ow_steer_policy_stack *stack);
+
+void
+ow_steer_policy_stack_schedule_recalc(struct ow_steer_policy_stack *stack);
+
+void
+ow_steer_policy_stack_sigusr1_dump(struct ow_steer_policy_stack *stack);
+
+void
+ow_steer_policy_stack_sta_connected(struct ow_steer_policy_stack *stack,
+                                    const struct osw_state_sta_info *sta_info);
+
+void
+ow_steer_policy_stack_sta_disconnected(struct ow_steer_policy_stack *stack,
+                                        const struct osw_state_sta_info *sta_info);
+
+void
+ow_steer_policy_stack_vif_probe_req(struct ow_steer_policy_stack *stack,
+                                    const struct osw_state_vif_info *vif_info,
+                                    const struct osw_drv_report_vif_probe_req *probe_req);
+
+void
+ow_steer_policy_stack_sta_snr_change(struct ow_steer_policy_stack *stack,
+                                     const struct osw_hwaddr *sta_addr,
+                                     const struct osw_hwaddr *bssid,
+                                     uint32_t snr_db);
+
+void
+ow_steer_policy_stack_sta_data_vol_change(struct ow_steer_policy_stack *stack,
+                                          const struct osw_hwaddr *sta_addr,
+                                          const struct osw_hwaddr *bssid,
+                                          uint64_t data_vol_bytes);
+
+#endif /* OW_STEER_POLICY_STACK_H */
Index: core/src/lib/ow/src/ow_steer_policy_stack_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_stack_ut.c
@@ -0,0 +1,245 @@
+#include <osw_conf.h>
+#include <osw_ut.h>
+#include "ow_steer_sta_i.h"
+
+struct ow_steer_policy_stack_ut_ctx {
+    unsigned int prio_low;
+    unsigned int prio_mid;
+    unsigned int prio_high;
+
+    struct ow_steer_policy policy_low_0;
+    struct ow_steer_policy policy_low_1;
+    struct ow_steer_policy policy_mid_0;
+    struct ow_steer_policy policy_high_0;
+    struct ow_steer_policy policy_high_1;
+};
+
+struct ow_steer_policy_stack_ut_policy {
+    unsigned int recalc_cnt;
+};
+
+static const char *g_ow_steer_policy_stack_ut_policy_name = "ow_steer_policy_stack_ut_policy";
+
+static struct ow_steer_policy*
+ow_steer_policy_stack_ut_policy_new(const struct osw_hwaddr *sta_addr,
+                                    const struct ow_steer_policy_ops *ops,
+                                    const struct ow_steer_policy_mediator *mediator)
+{
+    struct ow_steer_policy_stack_ut_policy *priv = CALLOC(1, sizeof(*priv));
+    return ow_steer_policy_create(g_ow_steer_policy_stack_ut_policy_name, 0, sta_addr, ops, mediator, priv);
+}
+
+static void
+ow_steer_policy_stack_ut_ctx_init(struct ow_steer_policy_stack_ut_ctx* ctx)
+{
+    assert(ctx != NULL);
+
+    memset(ctx, 0, sizeof(*ctx));
+
+    ctx->prio_low = 2;
+    ctx->prio_mid = 1;
+    ctx->prio_high = 0;
+
+    ctx->policy_low_0.name = "policy_low_0";
+    ctx->policy_low_0.priority = ctx->prio_low;
+    ctx->policy_low_1.name = "policy_low_1";
+    ctx->policy_low_1.priority = ctx->prio_low;
+    ctx->policy_mid_0.name = "policy_policy_mid_0";
+    ctx->policy_mid_0.priority = ctx->prio_mid;
+    ctx->policy_high_0.name = "policy_policy_high_0";
+    ctx->policy_high_0.priority = ctx->prio_high;
+    ctx->policy_high_1.name = "policy_policy_high_1";
+    ctx->policy_high_1.priority = ctx->prio_high;
+}
+
+static void
+ow_steer_policy_stack_ut_policy_recalc_cb(struct ow_steer_policy *policy,
+                                          struct ow_steer_candidate_list *candidate_list)
+{
+    assert(policy != NULL);
+    struct ow_steer_policy_stack_ut_policy *priv = ow_steer_policy_get_priv(policy);
+    priv->recalc_cnt++;
+}
+
+OSW_UT(ow_steer_policy_stack_ut_sorting_policies_1)
+{
+    struct ow_steer_policy_stack_ut_ctx ctx;
+    struct ow_steer_policy_stack *policy_stack;
+    struct ow_steer_policy *policy;
+    struct ow_steer_sta sta = { 0 };
+
+    osw_ut_time_init();
+    ow_steer_policy_stack_ut_ctx_init(&ctx);
+
+    sta.candidate_list = ow_steer_candidate_list_new();
+    policy_stack = ow_steer_policy_stack_create(&sta);
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_low_0);
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_mid_0);
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_high_0);
+    osw_ut_time_advance(0);
+
+    /* Expected policies order:
+     * - policy_high_0
+     * - policy_mid_0
+     * - policy_low_0
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == &ctx.policy_high_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_mid_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == NULL);
+
+    ow_steer_policy_stack_remove(policy_stack, &ctx.policy_mid_0);
+    osw_ut_time_advance(0);
+    /* Expected policies order:
+     * - policy_high_0
+     * - policy_low_0
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == &ctx.policy_high_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == NULL);
+
+    ow_steer_policy_stack_remove(policy_stack, &ctx.policy_high_0);
+    osw_ut_time_advance(0);
+    /* Expected policies order:
+     * - policy_low_0
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == &ctx.policy_low_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == NULL);
+
+    ow_steer_policy_stack_remove(policy_stack, &ctx.policy_low_0);
+    osw_ut_time_advance(0);
+    /* Expected policies order:
+     * (empty)
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == NULL);
+
+    ow_steer_policy_stack_free(policy_stack);
+}
+
+OSW_UT(ow_steer_policy_stack_ut_sorting_policies_2)
+{
+    struct ow_steer_policy_stack_ut_ctx ctx;
+    struct ow_steer_policy_stack *policy_stack;
+    struct ow_steer_policy *policy;
+    struct ow_steer_sta sta = { 0 };
+
+    ow_steer_policy_stack_ut_ctx_init(&ctx);
+
+    policy_stack = ow_steer_policy_stack_create(&sta);
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_low_0);
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_high_0);
+
+    /* Expected policies oerder:
+     * - policy_high_0
+     * - policy_low_0
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == &ctx.policy_high_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == NULL);
+
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_low_1);
+    /* Expected policies oerder:
+     * - policy_high_0
+     * - policy_low_1
+     * - policy_low_0
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == &ctx.policy_high_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_1);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == NULL);
+
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_high_1);
+    /* Expected policies oerder:
+     * - policy_high_1
+     * - policy_high_0
+     * - policy_low_1
+     * - policy_low_0
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == &ctx.policy_high_1);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_high_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_1);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == NULL);
+
+    ow_steer_policy_stack_add(policy_stack, &ctx.policy_mid_0);
+    /* Expected policies oerder:
+     * - policy_high_1
+     * - policy_high_0
+     * - policy_mid_0
+     * - policy_low_1
+     * - policy_low_0
+     */
+    policy = (struct ow_steer_policy*) ds_dlist_head(&policy_stack->policy_list);
+    assert(policy == &ctx.policy_high_1);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_high_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_mid_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_1);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == &ctx.policy_low_0);
+    policy = (struct ow_steer_policy*) ds_dlist_next(&policy_stack->policy_list, policy);
+    assert(policy == NULL);
+}
+
+OSW_UT(ow_steer_policy_stack_ut_lifecycle)
+{
+    const struct osw_hwaddr sta_addr = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA }, };
+    const struct ow_steer_policy_ops ops = {
+        .recalc_fn = ow_steer_policy_stack_ut_policy_recalc_cb,
+    };
+    struct ow_steer_policy_stack *policy_stack;
+    struct ow_steer_policy *policy;
+    struct ow_steer_policy_stack_ut_policy *priv; /* Hold struct ow_steer_policy_stack_ut_policy ptrs to free them at the end */
+    struct ow_steer_policy_mediator mediator;
+    struct ow_steer_sta sta = {
+        .candidate_list = ow_steer_candidate_list_new(),
+    };
+
+    /* Setup */
+    memset(&mediator, 0, sizeof(mediator));
+    policy = ow_steer_policy_stack_ut_policy_new(&sta_addr, &ops, &mediator);
+    priv = ow_steer_policy_get_priv(policy);
+    policy_stack = ow_steer_policy_stack_create(&sta);
+
+    ow_steer_policy_set_active(policy, true);
+
+    assert(priv->recalc_cnt == 0);
+
+    /* Add policy to stack */
+    ow_steer_policy_stack_add(policy_stack, policy);
+    assert(priv->recalc_cnt == 0);
+
+    /* Schedule recalc */
+    ow_steer_policy_stack_schedule_recalc(policy_stack);
+    osw_ut_time_advance(0);
+    assert(priv->recalc_cnt == 1);
+
+    /* Cleanup */
+    ow_steer_policy_stack_remove(policy_stack, policy);
+    ow_steer_policy_free(policy);
+    FREE(priv);
+}
Index: core/src/lib/ow/src/ow_steer_policy_ut.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_policy_ut.c
@@ -0,0 +1,48 @@
+#include <osw_ut.h>
+
+static void
+ow_steer_policy_ut_medaitor_sched_stack_recalc(struct ow_steer_policy *policy,
+                                               void *priv)
+{
+    assert(priv != NULL);
+    unsigned int *stack_recalc_cnt = priv;
+    *stack_recalc_cnt = *stack_recalc_cnt + 1;
+}
+
+OSW_UT(ow_steer_policy_ut_methods)
+{
+    const char *name = "policy_ut";
+    const char *prefix = "ow: steer: policy: policy_ut [sta: aa:aa:aa:aa:aa:aa bssid: bb:bb:bb:bb:bb:bb]:";
+    const unsigned int priority = 14;
+    const struct osw_hwaddr sta_addr = { .octet = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA }, };
+    const struct osw_hwaddr bssid = { .octet = { 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB }, };
+    const struct ow_steer_policy_ops ops;
+    unsigned int stack_recalc_cnt = 0;
+    void *priv = NULL;
+    struct ow_steer_policy *policy = NULL;
+    const struct ow_steer_policy_mediator mediator = {
+        .sched_recalc_stack_fn = ow_steer_policy_ut_medaitor_sched_stack_recalc,
+        .priv = &stack_recalc_cnt,
+    };
+
+    policy = ow_steer_policy_create(name, priority, &sta_addr, &ops, &mediator, priv);
+    ow_steer_policy_set_bssid(policy, &bssid);
+    OSW_UT_EVAL(policy != NULL);
+    OSW_UT_EVAL(ow_steer_policy_get_priv(policy) == priv);
+    OSW_UT_EVAL(osw_hwaddr_cmp(ow_steer_policy_get_sta_addr(policy), &sta_addr) == 0);
+    OSW_UT_EVAL(osw_hwaddr_cmp(ow_steer_policy_get_bssid(policy), &bssid) == 0);
+    OSW_UT_EVAL(strcmp(ow_steer_policy_get_prefix(policy), prefix) == 0);
+
+    OSW_UT_EVAL(stack_recalc_cnt == 0);
+    ow_steer_policy_set_active(policy, true);
+    OSW_UT_EVAL(stack_recalc_cnt == 1);
+    ow_steer_policy_schedule_stack_recalc(policy);
+    OSW_UT_EVAL(stack_recalc_cnt == 2);
+
+    /* Activating an active policy is nop */
+    ow_steer_policy_set_active(policy, true);
+    OSW_UT_EVAL(stack_recalc_cnt == 2);
+
+    /* Cleanup */
+    ow_steer_policy_free(policy);
+}
Index: core/src/lib/ow/src/ow_steer_priv.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_priv.h
@@ -0,0 +1,10 @@
+#ifndef OSW_STEER_PRIV_H
+#define OSW_STEER_PRIV_H
+
+struct ds_dlist*
+ow_steer_get_sta_list(void);
+
+struct osw_conf_mutator*
+ow_steer_get_mutator(void);
+
+#endif /* OSW_STEER_PRIV_H */
Index: core/src/lib/ow/src/ow_steer_sta.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_sta.c
@@ -0,0 +1,248 @@
+#include <memutil.h>
+#include <const.h>
+#include <log.h>
+#include <ds_tree.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_bss_map.h>
+#include <osw_timer.h>
+#include <osw_stats.h>
+#include <osw_stats_defs.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_sta.h"
+#include "ow_steer_sta_priv.h"
+#include "ow_steer_sta_i.h"
+#include "ow_steer_policy_stack.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_chain.h"
+#include "ow_steer_priv.h"
+
+struct ow_steer_sta_set {
+    struct ds_tree sta_tree;
+    struct osw_state_observer state_observer;
+    struct osw_stats_subscriber *stats_sub;
+};
+
+static void
+ow_steer_sta_bss_set_cb(struct osw_bss_map_observer *observer,
+                        const struct osw_hwaddr *bssid,
+                        const struct osw_bss_entry *bss_entry)
+{
+    ASSERT(observer != NULL, "");
+    ASSERT(bssid != NULL, "");
+    ASSERT(bss_entry != NULL, "");
+
+    struct ow_steer_sta *sta = container_of(observer, struct ow_steer_sta, bss_map_observer);
+    const struct osw_channel *channel = osw_bss_get_channel(bssid);
+
+    if (channel != NULL) {
+        LOGD("ow: steer: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" channel: "OSW_CHANNEL_FMT" set candidate",
+             OSW_HWADDR_ARG(&sta->mac_addr), OSW_HWADDR_ARG(bssid), OSW_CHANNEL_ARG(channel));
+        ow_steer_candidate_list_bss_set(sta->candidate_list, bssid, channel);
+    }
+    else {
+        LOGD("ow: steer: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" unset candidate, missing channel",
+             OSW_HWADDR_ARG(&sta->mac_addr), OSW_HWADDR_ARG(bssid));
+        ow_steer_candidate_list_bss_unset(sta->candidate_list, bssid);
+    }
+
+    ow_steer_policy_stack_schedule_recalc(sta->policy_stack);
+}
+
+static void
+ow_steer_sta_bss_unset_cb(struct osw_bss_map_observer *observer,
+                          const struct osw_hwaddr *bssid)
+{
+    ASSERT(observer != NULL, "");
+    ASSERT(bssid != NULL, "");
+
+    struct ow_steer_sta *sta = container_of(observer, struct ow_steer_sta, bss_map_observer);
+
+    ow_steer_candidate_list_bss_unset(sta->candidate_list, bssid);
+    ow_steer_policy_stack_schedule_recalc(sta->policy_stack);
+}
+
+static void
+ow_steer_sta_set_sta_connected_cb(struct osw_state_observer *observer,
+                                  const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(observer != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_sta *sta = container_of(observer, struct ow_steer_sta, state_observer);
+
+    if (WARN_ON(sta_info == NULL))
+        return;
+    if (WARN_ON(sta_info->mac_addr == NULL))
+        return;
+    if (osw_hwaddr_cmp(&sta->mac_addr, sta_info->mac_addr) != 0)
+        return;
+    if (WARN_ON(sta_info->vif == NULL))
+        return;
+    if (WARN_ON(sta_info->vif->drv_state == NULL))
+        return;
+
+    ow_steer_policy_stack_sta_connected(sta->policy_stack, sta_info);
+}
+
+static void
+ow_steer_sta_set_sta_disconnected_cb(struct osw_state_observer *observer,
+                                     const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(observer != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_sta *sta = container_of(observer, struct ow_steer_sta, state_observer);
+
+    if (WARN_ON(sta_info == NULL))
+        return;
+    if (WARN_ON(sta_info->mac_addr == NULL))
+        return;
+    if (osw_hwaddr_cmp(&sta->mac_addr, sta_info->mac_addr) != 0)
+        return;
+    if (WARN_ON(sta_info->vif == NULL))
+        return;
+    if (WARN_ON(sta_info->vif->drv_state == NULL))
+        return;
+
+    ow_steer_policy_stack_sta_disconnected(sta->policy_stack, sta_info);
+}
+
+static void
+ow_steer_sta_set_vif_probe_req_cb(struct osw_state_observer *observer,
+                                  const struct osw_state_vif_info *vif_info,
+                                  const struct osw_drv_report_vif_probe_req *probe_req)
+{
+    ASSERT(observer != NULL, "");
+    ASSERT(vif_info != NULL, "");
+    ASSERT(probe_req != NULL, "");
+
+    struct ow_steer_sta *sta = container_of(observer, struct ow_steer_sta, state_observer);
+
+    if (osw_hwaddr_cmp(&sta->mac_addr, &probe_req->sta_addr) != 0)
+        return;
+    if (WARN_ON(vif_info == NULL))
+        return;
+    if (WARN_ON(vif_info->drv_state == NULL))
+        return;
+
+    ow_steer_policy_stack_vif_probe_req(sta->policy_stack, vif_info, probe_req);
+}
+
+static void
+ow_steer_executor_chain_timer_cb(struct osw_timer *timer)
+{
+    struct ow_steer_sta *sta = container_of(timer, struct ow_steer_sta, executor_chain_timer);
+    uint64_t next_at_nsec = 0;
+
+    ow_steer_executor_chain_call(sta->executor_chain, &sta->mac_addr, sta->candidate_list, sta->mutator, &next_at_nsec);
+    if (next_at_nsec > 0)
+        osw_timer_arm_at_nsec(&sta->executor_chain_timer, next_at_nsec);
+}
+
+struct ow_steer_sta*
+ow_steer_sta_create(const struct osw_hwaddr *mac_addr)
+{
+    ASSERT(mac_addr != NULL, "");
+
+    const struct osw_bss_map_observer bss_map_observer = {
+        .name = "ow_steer_sta",
+        .set_fn = ow_steer_sta_bss_set_cb,
+        .unset_fn = ow_steer_sta_bss_unset_cb,
+    };
+    const struct osw_state_observer state_observer = {
+        .sta_connected_fn = ow_steer_sta_set_sta_connected_cb,
+        .sta_disconnected_fn = ow_steer_sta_set_sta_disconnected_cb,
+        .vif_probe_req_fn = ow_steer_sta_set_vif_probe_req_cb,
+    };
+    
+    struct ow_steer_sta *sta = CALLOC(1, sizeof(*sta));
+
+    memcpy(&sta->mac_addr, mac_addr, sizeof(sta->mac_addr));
+    sta->candidate_list = ow_steer_candidate_list_new();
+    sta->policy_stack = ow_steer_policy_stack_create(sta);
+    sta->executor_chain = ow_steer_executor_chain_create();
+    sta->mutator = ow_steer_get_mutator();
+    memcpy(&sta->bss_map_observer, &bss_map_observer, sizeof(sta->bss_map_observer));
+    memcpy(&sta->state_observer, &state_observer, sizeof(sta->state_observer));
+
+    osw_bss_map_register_observer(&sta->bss_map_observer);
+    osw_state_register_observer(&sta->state_observer);
+
+    osw_timer_init(&sta->executor_chain_timer, ow_steer_executor_chain_timer_cb);
+
+    ds_dlist_insert_tail(ow_steer_get_sta_list(), sta);
+
+    return sta;
+}
+
+void
+ow_steer_sta_free(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    ds_dlist_remove(ow_steer_get_sta_list(), sta);
+
+    osw_bss_map_unregister_observer(&sta->bss_map_observer);
+    osw_state_unregister_observer(&sta->state_observer);
+
+    ow_steer_policy_stack_free(sta->policy_stack);
+    ow_steer_candidate_list_free(sta->candidate_list);
+    ow_steer_executor_chain_free(sta->executor_chain);
+    osw_timer_disarm(&sta->executor_chain_timer);
+    FREE(sta);
+}
+
+const struct osw_hwaddr*
+ow_steer_sta_get_addr(const struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return &sta->mac_addr;
+}
+
+struct ow_steer_candidate_list*
+ow_steer_sta_get_candidate_list(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return sta->candidate_list;
+}
+
+struct ow_steer_policy_stack*
+ow_steer_sta_get_policy_stack(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return sta->policy_stack;
+}
+
+struct ow_steer_executor_chain*
+ow_steer_sta_get_executor_chain(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return sta->executor_chain;
+}
+
+void
+ow_steer_sta_schedule_executor_chain_call(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    osw_timer_arm_at_nsec(&sta->executor_chain_timer, 0);
+}
+
+void
+ow_steer_sta_schedule_policy_stack_recalc(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    ow_steer_policy_stack_schedule_recalc(sta->policy_stack);
+}
+
+void
+ow_steer_sta_conf_mutate(struct ow_steer_sta *sta,
+                         struct ds_tree *phy_tree)
+{
+    ASSERT(sta != NULL, "");
+    ASSERT(phy_tree != NULL, "");
+
+    ow_steer_executor_chain_conf_mutate(sta->executor_chain, &sta->mac_addr, sta->candidate_list, phy_tree);
+}
Index: core/src/lib/ow/src/ow_steer_sta.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_sta.h
@@ -0,0 +1,15 @@
+#ifndef OW_STEER_STA_H
+#define OW_STEER_STA_H
+
+struct ow_steer_sta;
+
+struct ow_steer_sta*
+ow_steer_sta_create(const struct osw_hwaddr *sta_addr);
+
+void
+ow_steer_sta_free(struct ow_steer_sta *sta);
+
+const struct osw_hwaddr*
+ow_steer_sta_get_addr(const struct ow_steer_sta *sta);
+
+#endif /* OW_STEER_STA_H */
Index: core/src/lib/ow/src/ow_steer_sta_i.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_sta_i.h
@@ -0,0 +1,17 @@
+#ifndef OW_STEER_STA_I_H
+#define OW_STEER_STA_I_H
+
+struct ow_steer_sta {
+    struct osw_hwaddr mac_addr;
+    struct ow_steer_candidate_list *candidate_list;
+    struct ow_steer_policy_stack *policy_stack;
+    struct ow_steer_executor_chain *executor_chain;
+    struct osw_conf_mutator *mutator;
+    struct osw_bss_map_observer bss_map_observer;
+    struct osw_state_observer state_observer;
+    struct osw_timer executor_chain_timer;
+
+    struct ds_dlist_node node;
+};
+
+#endif /* OW_STEER_STA_I_H */
Index: core/src/lib/ow/src/ow_steer_sta_priv.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_sta_priv.h
@@ -0,0 +1,23 @@
+#ifndef OW_STEER_STA_PRIV_H
+#define OW_STEER_STA_PRIV_H
+
+struct ow_steer_candidate_list*
+ow_steer_sta_get_candidate_list(struct ow_steer_sta *sta);
+
+struct ow_steer_policy_stack*
+ow_steer_sta_get_policy_stack(struct ow_steer_sta *sta);
+
+struct ow_steer_executor_chain*
+ow_steer_sta_get_executor_chain(struct ow_steer_sta *sta);
+
+void
+ow_steer_sta_schedule_executor_chain_call(struct ow_steer_sta *sta);
+
+void
+ow_steer_sta_schedule_policy_stack_recalc(struct ow_steer_sta *sta);
+
+void
+ow_steer_sta_conf_mutate(struct ow_steer_sta *sta,
+                         struct ds_tree *phy_tree);
+
+#endif /* OW_STEER_STA_PRIV_H */
Index: core/src/lib/ow/src/ow_steer_sta_set.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_sta_set.c
@@ -0,0 +1,341 @@
+#include <memutil.h>
+#include <const.h>
+#include <log.h>
+#include <ds_tree.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_bss_map.h>
+#include <osw_stats.h>
+#include <osw_stats_defs.h>
+#include "ow_steer_candidate_list.h"
+#include "ow_steer_policy.h"
+#include "ow_steer_sta_set.h"
+#include "ow_steer_sta_i.h"
+#include "ow_steer_policy_stack.h"
+#include "ow_steer_executor_action.h"
+#include "ow_steer_executor_chain.h"
+
+struct ow_steer_sta_set {
+    struct ds_tree sta_tree;
+    struct osw_state_observer state_obs;
+    struct osw_stats_subscriber *stats_sub;
+};
+
+static void
+ow_steer_sta_bss_set_cb(struct osw_bss_map_observer *observer,
+                        const struct osw_hwaddr *bssid,
+                        const struct osw_bss_entry *bss_entry)
+{
+    ASSERT(observer != NULL, "");
+    ASSERT(bssid != NULL, "");
+    ASSERT(bss_entry != NULL, "");
+
+    struct ow_steer_sta *sta = container_of(observer, struct ow_steer_sta, bss_map_observer);
+    const struct osw_channel *channel = osw_bss_get_channel(bssid);
+
+    if (channel != NULL) {
+        LOGD("ow: steer: sta_set: sta: "OSW_HWADDR_FMT" bssid: "OSW_HWADDR_FMT" channel: "OSW_CHANNEL_FMT" set",
+             OSW_HWADDR_ARG(&sta->mac_addr), OSW_HWADDR_ARG(bssid), OSW_CHANNEL_ARG(channel));
+        ow_steer_candidate_list_bss_set(sta->candidate_list, bssid, channel);
+    }
+    else {
+        LOGD("ow: steer: sta_set: sta: "OSW_HWADDR_FMT" unset bssid: "OSW_HWADDR_FMT" unset due to missing channel",
+             OSW_HWADDR_ARG(&sta->mac_addr), OSW_HWADDR_ARG(bssid));
+        ow_steer_candidate_list_bss_unset(sta->candidate_list, bssid);
+    }
+
+    ow_steer_policy_stack_schedule_recalc(sta->policy_stack);
+}
+
+static void
+ow_steer_sta_bss_unset_cb(struct osw_bss_map_observer *observer,
+                          const struct osw_hwaddr *bssid)
+{
+    ASSERT(observer != NULL, "");
+    ASSERT(bssid != NULL, "");
+
+    struct ow_steer_sta *sta = container_of(observer, struct ow_steer_sta, bss_map_observer);
+
+    ow_steer_candidate_list_bss_unset(sta->candidate_list, bssid);
+    ow_steer_policy_stack_schedule_recalc(sta->policy_stack);
+}
+
+static struct ow_steer_sta*
+ow_steer_sta_create(const struct osw_hwaddr *mac_addr)
+{
+    ASSERT(mac_addr != NULL, "");
+
+    const struct osw_bss_map_observer bss_map_observer = {
+        .name = "ow_steer_sta",
+        .set_fn = ow_steer_sta_bss_set_cb,
+        .unset_fn = ow_steer_sta_bss_unset_cb,
+    };
+
+    struct ow_steer_sta *sta = CALLOC(1, sizeof(*sta));
+
+    memcpy(&sta->mac_addr, mac_addr, sizeof(sta->mac_addr));
+    sta->candidate_list = ow_steer_candidate_list_new();
+    sta->policy_stack = ow_steer_policy_stack_create(sta);
+    memcpy(&sta->bss_map_observer, &bss_map_observer, sizeof(sta->bss_map_observer));
+    sta->executor_chain = ow_steer_executor_chain_create();
+
+    return sta;
+}
+
+static void
+ow_steer_sta_free(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    osw_bss_map_unregister_observer(&sta->bss_map_observer);
+    ow_steer_policy_stack_free(sta->policy_stack);
+    ow_steer_candidate_list_free(sta->candidate_list);
+    ow_steer_executor_chain_free(sta->executor_chain);
+    FREE(sta);
+}
+
+static void
+ow_steer_sta_sigusr1_dump(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+
+    ow_steer_policy_stack_sigusr1_dump(sta->policy_stack);
+    ow_steer_candidate_list_sigusr1_dump(sta->candidate_list);
+}
+
+static void
+ow_steer_sta_set_sta_connected_cb(struct osw_state_observer *self,
+                                  const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_sta_set *sta_set = container_of(self, struct ow_steer_sta_set, state_obs);
+    struct ow_steer_sta *sta;
+
+    if (WARN_ON(sta_info == NULL))
+        return;
+    if (WARN_ON(sta_info->vif == NULL))
+        return;
+    if (WARN_ON(sta_info->vif->drv_state == NULL))
+        return;
+
+    sta = ds_tree_find(&sta_set->sta_tree, sta_info->mac_addr);
+    if (sta == NULL)
+        return;
+
+    ow_steer_policy_stack_sta_connected(sta->policy_stack, sta_info);
+}
+
+static void
+ow_steer_sta_set_sta_disconnected_cb(struct osw_state_observer *self,
+                                     const struct osw_state_sta_info *sta_info)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(sta_info != NULL, "");
+
+    struct ow_steer_sta_set *sta_set = container_of(self, struct ow_steer_sta_set, state_obs);
+    struct ow_steer_sta *sta;
+
+    if (WARN_ON(sta_info == NULL))
+        return;
+    if (WARN_ON(sta_info->vif == NULL))
+        return;
+    if (WARN_ON(sta_info->vif->drv_state == NULL))
+        return;
+
+    sta = ds_tree_find(&sta_set->sta_tree, sta_info->mac_addr);
+    if (sta == NULL)
+        return;
+
+    ow_steer_policy_stack_sta_disconnected(sta->policy_stack, sta_info);
+}
+
+static void
+ow_steer_sta_set_vif_probe_req_cb(struct osw_state_observer *self,
+                                  const struct osw_state_vif_info *vif_info,
+                                  const struct osw_drv_report_vif_probe_req *probe_req)
+{
+    ASSERT(self != NULL, "");
+    ASSERT(vif_info != NULL, "");
+    ASSERT(probe_req != NULL, "");
+
+    struct ow_steer_sta_set *sta_set = container_of(self, struct ow_steer_sta_set, state_obs);
+    struct ow_steer_sta *sta;
+
+    if (WARN_ON(vif_info == NULL))
+        return;
+    if (WARN_ON(vif_info->drv_state == NULL))
+        return;
+
+    sta = ds_tree_find(&sta_set->sta_tree, &probe_req->sta_addr);
+    if (sta == NULL)
+        return;
+
+    ow_steer_policy_stack_vif_probe_req(sta->policy_stack, vif_info, probe_req);
+}
+
+static void
+ow_steer_sta_set_stats_report_cb(enum osw_stats_id id,
+                                 const struct osw_tlv *data,
+                                 const struct osw_tlv *last,
+                                 void *priv)
+{
+    struct ow_steer_sta_set *sta_set = priv;
+    struct ow_steer_sta *steer_sta;
+    const struct osw_stats_defs *stats_defs = osw_stats_defs_lookup(OSW_STATS_STA);
+    const struct osw_tlv_hdr *tb[OSW_STATS_STA_MAX__] = {0};
+    const struct osw_state_vif_info *vif_info;
+    const struct osw_hwaddr *bssid;
+    const struct osw_hwaddr *sta_addr;
+    const char *phy_name;
+    const char *vif_name;
+
+    if (id != OSW_STATS_STA)
+        return;
+
+    osw_tlv_parse(data->data, data->used, stats_defs->tpolicy, tb, OSW_STATS_STA_MAX__);
+
+    if (tb[OSW_STATS_STA_PHY_NAME] == NULL ||
+        tb[OSW_STATS_STA_VIF_NAME] == NULL ||
+        tb[OSW_STATS_STA_MAC_ADDRESS] == NULL)
+        return;
+    if (tb[OSW_STATS_STA_SNR_DB] == NULL &&
+        (tb[OSW_STATS_STA_TX_BYTES] == NULL && tb[OSW_STATS_STA_RX_BYTES] == NULL))
+        return;
+
+    sta_addr = osw_tlv_get_data(tb[OSW_STATS_STA_MAC_ADDRESS]);
+    steer_sta = ds_tree_find(&sta_set->sta_tree, sta_addr);
+    if (steer_sta == NULL)
+        return;
+
+    phy_name = osw_tlv_get_string(tb[OSW_STATS_STA_PHY_NAME]);
+    vif_name = osw_tlv_get_string(tb[OSW_STATS_STA_VIF_NAME]);
+
+    vif_info = osw_state_vif_lookup(phy_name, vif_name);
+    if (vif_info == NULL)
+        return;
+    if (vif_info->drv_state == NULL)
+        return;
+
+    bssid = &vif_info->drv_state->mac_addr;
+
+    if (tb[OSW_STATS_STA_SNR_DB] != NULL) {
+        const uint32_t snr_db = osw_tlv_get_u32(tb[OSW_STATS_STA_SNR_DB]);
+        ow_steer_policy_stack_sta_snr_change(steer_sta->policy_stack, sta_addr, bssid, snr_db);
+    }
+
+    if (tb[OSW_STATS_STA_TX_BYTES] != NULL || tb[OSW_STATS_STA_RX_BYTES] != NULL) {
+        uint64_t data_vol = 0;
+
+        data_vol += tb[OSW_STATS_STA_TX_BYTES] != NULL ? osw_tlv_get_u32(tb[OSW_STATS_STA_TX_BYTES]) : 0;
+        data_vol += tb[OSW_STATS_STA_RX_BYTES] != NULL ? osw_tlv_get_u32(tb[OSW_STATS_STA_RX_BYTES]) : 0;
+
+        ow_steer_policy_stack_sta_data_vol_change(steer_sta->policy_stack, sta_addr, bssid, data_vol);
+    }
+}
+
+struct ow_steer_sta_set*
+ow_steer_sta_set_create(void)
+{
+    const double stats_period_sec = 0.5;
+    const struct osw_state_observer state_obs = {
+        .sta_connected_fn = ow_steer_sta_set_sta_connected_cb,
+        .sta_disconnected_fn = ow_steer_sta_set_sta_disconnected_cb,
+        .vif_probe_req_fn = ow_steer_sta_set_vif_probe_req_cb,
+    };
+
+    struct ow_steer_sta_set *sta_set = CALLOC(1, sizeof(*sta_set));
+
+    ds_tree_init(&sta_set->sta_tree, (ds_key_cmp_t*) osw_hwaddr_cmp, struct ow_steer_sta, node);
+    memcpy(&sta_set->state_obs, &state_obs, sizeof(sta_set->state_obs));
+    osw_state_register_observer(&sta_set->state_obs);
+    sta_set->stats_sub = osw_stats_subscriber_alloc();
+    osw_stats_subscriber_set_report_seconds(sta_set->stats_sub, stats_period_sec);
+    osw_stats_subscriber_set_poll_seconds(sta_set->stats_sub, stats_period_sec);
+    osw_stats_subscriber_set_report_fn(sta_set->stats_sub, ow_steer_sta_set_stats_report_cb, sta_set);
+    osw_stats_subscriber_set_sta(sta_set->stats_sub, true);
+    osw_stats_register_subscriber(sta_set->stats_sub);
+    return sta_set;
+}
+
+void
+ow_steer_sta_set_free(struct ow_steer_sta_set *sta_set)
+{
+    ASSERT(sta_set != NULL, "");
+
+    struct ow_steer_sta *sta;
+    struct ow_steer_sta *sta_tmp;
+
+    osw_state_unregister_observer(&sta_set->state_obs);
+    ds_tree_foreach_safe(&sta_set->sta_tree, sta, sta_tmp) {
+        ds_tree_remove(&sta_set->sta_tree, sta);
+        ow_steer_sta_free(sta);
+    }
+    osw_stats_unregister_subscriber(sta_set->stats_sub);
+    osw_stats_subscriber_free(sta_set->stats_sub);
+    FREE(sta_set);
+}
+
+void
+ow_steer_sta_set_sigusr1_dump(struct ow_steer_sta_set *sta_set)
+{
+    ASSERT(sta_set != NULL, "");
+
+    struct ow_steer_sta *sta;
+
+    LOGI("ow: steer:   sta_set:");
+    ds_tree_foreach(&sta_set->sta_tree, sta) {
+        LOGI("ow: steer:     sta: mac: "OSW_HWADDR_FMT, OSW_HWADDR_ARG(&sta->mac_addr));
+        ow_steer_sta_sigusr1_dump(sta);
+    }
+}
+
+struct ow_steer_sta*
+ow_steer_sta_set_get_sta(struct ow_steer_sta_set *sta_set,
+                         const struct osw_hwaddr *mac_addr)
+{
+    ASSERT(sta_set != NULL, "");
+    ASSERT(mac_addr != NULL, "");
+
+    struct ow_steer_sta *sta;
+
+    sta = ds_tree_find(&sta_set->sta_tree, mac_addr);
+    if (sta != NULL)
+        return sta;
+
+    sta = ow_steer_sta_create(mac_addr);
+    osw_bss_map_register_observer(&sta->bss_map_observer);
+    ds_tree_insert(&sta_set->sta_tree, sta, &sta->mac_addr);
+
+    return sta;
+}
+
+const struct osw_hwaddr*
+ow_steer_sta_get_mac_addr(const struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return &sta->mac_addr;
+}
+
+struct ow_steer_candidate_list*
+ow_steer_sta_get_candidate_list(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return sta->candidate_list;
+}
+
+struct ow_steer_policy_stack*
+ow_steer_sta_get_policy_stack(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return sta->policy_stack;
+}
+
+struct ow_steer_executor_chain*
+ow_steer_sta_get_executor_chain(struct ow_steer_sta *sta)
+{
+    ASSERT(sta != NULL, "");
+    return sta->executor_chain;
+}
Index: core/src/lib/ow/src/ow_steer_sta_set.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_steer_sta_set.h
@@ -0,0 +1,32 @@
+#ifndef OW_STEER_STA_SET_H
+#define OW_STEER_STA_SET_H
+
+struct ow_steer_sta_set;
+struct ow_steer_sta;
+
+struct ow_steer_sta_set*
+ow_steer_sta_set_create(void);
+
+void
+ow_steer_sta_set_free(struct ow_steer_sta_set *sta_set);
+
+void
+ow_steer_sta_set_sigusr1_dump(struct ow_steer_sta_set *sta_set);
+
+struct ow_steer_sta*
+ow_steer_sta_set_get_sta(struct ow_steer_sta_set *sta_set,
+                         const struct osw_hwaddr *mac_addr);
+
+const struct osw_hwaddr*
+ow_steer_sta_get_mac_addr(const struct ow_steer_sta *sta);
+
+struct ow_steer_candidate_list*
+ow_steer_sta_get_candidate_list(struct ow_steer_sta *sta);
+
+struct ow_steer_policy_stack*
+ow_steer_sta_get_policy_stack(struct ow_steer_sta *sta);
+
+struct ow_steer_executor_chain*
+ow_steer_sta_get_executor_chain(struct ow_steer_sta *sta);
+
+#endif /* OW_STEER_STA_SET_H */
Index: core/src/lib/ow/src/ow_webconfig.c
===================================================================
--- core.orig/src/lib/ow/src/ow_webconfig.c
+++ core/src/lib/ow/src/ow_webconfig.c
@@ -88,7 +88,8 @@ ow_webconfig_macmode2aclpolicy(wifi_mac_
 }
 
 static void
-ow_webconfig_fill_security(const wifi_vap_info_t *vap,
+ow_webconfig_fill_security(const char *vif_name,
+                           const wifi_vap_info_t *vap,
                            struct osw_wpa *wpa)
 {
     const wifi_front_haul_bss_t *bss = &vap->u.bss_info;
@@ -99,10 +100,10 @@ ow_webconfig_fill_security(const wifi_va
         case wifi_security_mode_none:
             return;
         case wifi_security_mode_wep_64:
-            LOGW("%s: wep 64 not supported", vap->vap_name);
+            LOGW("%s: wep 64 not supported", vif_name);
             return;
         case wifi_security_mode_wep_128:
-            LOGW("%s: wep 128 not supported", vap->vap_name);
+            LOGW("%s: wep 128 not supported", vif_name);
             return;
         case wifi_security_mode_wpa_personal:
             wpa->wpa = true;
@@ -121,13 +122,13 @@ ow_webconfig_fill_security(const wifi_va
             is_key = true;
             break;
         case wifi_security_mode_wpa_enterprise:
-            LOGI("%s: wpa enterprise not supported", vap->vap_name);
+            LOGI("%s: wpa enterprise not supported", vif_name);
             break;
         case wifi_security_mode_wpa2_enterprise:
-            LOGI("%s: wpa2 enterprise not supported", vap->vap_name);
+            LOGI("%s: wpa2 enterprise not supported", vif_name);
             break;
         case wifi_security_mode_wpa_wpa2_enterprise:
-            LOGI("%s: wpa1+2 enterprise not supported", vap->vap_name);
+            LOGI("%s: wpa1+2 enterprise not supported", vif_name);
             break;
         case wifi_security_mode_wpa3_personal:
             wpa->rsn = true;
@@ -141,7 +142,10 @@ ow_webconfig_fill_security(const wifi_va
             is_key = true;
             break;
         case wifi_security_mode_wpa3_enterprise:
-            LOGI("%s: wpa3 enterprise not supported", vap->vap_name);
+            LOGI("%s: wpa3 enterprise not supported", vif_name);
+            break;
+        default:
+            LOGI("%s: Unsupported security mode %d", vif_name, sec->mode);
             break;
     }
 
@@ -167,7 +171,7 @@ ow_webconfig_fill_security(const wifi_va
         wpa->akm_sae == true &&
         wpa->akm_psk == true) {
         wpa->akm_psk = false;
-        LOGI("%s: overriding: disabling wpa3 transition", vap->vap_name);
+        LOGI("%s: overriding: disabling wpa3 transition", vif_name);
     }
 
     wpa->group_rekey_seconds = sec->rekey_interval;
@@ -190,7 +194,7 @@ ow_webconfig_fill_security(const wifi_va
                  * the structure and setting shall be handled outside.
                  */
                 if (WARN_ON(strnlen(sec->u.key.key, max) >= max) == false)
-                    ow_conf_vif_set_ap_psk(vap->vap_name, -1, bss->security.u.key.key);
+                    ow_conf_vif_set_ap_psk(vif_name, -1, bss->security.u.key.key);
                 break;
         }
     }
@@ -231,7 +235,7 @@ ow_webconfig_set_vif_ap(const char *phy_
     ow_conf_vif_set_ap_isolated(vif_name, &isolated);
 
     struct osw_wpa wpa = {0};
-    ow_webconfig_fill_security(vap, &wpa);
+    ow_webconfig_fill_security(vif_name, vap, &wpa);
     ow_conf_vif_set_ap_wpa(vif_name, &wpa.wpa);
     ow_conf_vif_set_ap_rsn(vif_name, &wpa.rsn);
     ow_conf_vif_set_ap_pairwise_tkip(vif_name, &wpa.pairwise_tkip);
@@ -311,16 +315,8 @@ ow_webconfig_get_phy(const char *phy_nam
      */
 }
 
-static void
-ow_webconfig_module_init_cb(void *arg)
+OSW_MODULE(ow_webconfig)
 {
+    OSW_MODULE_LOAD(ow_conf);
+    return NULL;
 }
-
-static void
-ow_webconfig_module_fini_cb(void *arg)
-{
-}
-
-MODULE(ow_webconfig_module,
-       ow_webconfig_module_init_cb,
-       ow_webconfig_module_fini_cb);
Index: core/src/lib/ow/src/ow_xphy_csa_conf.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_xphy_csa_conf.c
@@ -0,0 +1,352 @@
+#include <log.h>
+#include <const.h>
+#include <util.h>
+#include <memutil.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <osw_types.h>
+#include <osw_conf.h>
+#include <osw_state.h>
+#include <osw_module.h>
+#include <osw_ut.h>
+
+/**
+ * @brief Cross-PHY CSA support
+ *
+ * This is intended to handle cases where one radio's STA
+ * interface receives a CSA intent with a target channel
+ * that isn't part of the receiving radio's supported
+ * channel list. Instead, if another radio supports that
+ * channel it should inherit the STA interface configuration
+ * and continue (uplink) operation on that other radio.
+ *
+ * This uses the osw_conf module to mutate the configuration
+ * at the end, after base configs, like. ow_conf is already
+ * done providing the baseline.
+ *
+ * The expectation is that the configuration entity will
+ * eventually update it's data model and ow_conf will
+ * get reconfigured with uplink to the new radio.
+ */
+
+struct ow_xphy_csa_conf {
+    struct osw_state_observer obs;
+    struct osw_conf_mutator mut;
+
+    struct osw_ifname phy_name;
+    struct osw_channel channel;
+    bool active;
+};
+
+static void
+ow_xphy_csa_conf_set(struct ow_xphy_csa_conf *csa,
+                     const char *phy_name,
+                     const struct osw_channel *c)
+{
+    csa->active = true;
+    csa->channel = *c;
+    STRSCPY_WARN(csa->phy_name.buf, phy_name);
+}
+
+static void
+ow_xphy_csa_conf_state_cb(struct osw_state_observer *self,
+                          const struct osw_state_vif_info *vif,
+                          const struct osw_state_phy_info *to_phy,
+                          const struct osw_channel *c)
+{
+    struct ow_xphy_csa_conf *csa = container_of(self, struct ow_xphy_csa_conf, obs);
+    LOGI("csa: moving from %s to %s for "OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+         vif->phy->phy_name,
+         to_phy->phy_name,
+         OSW_CHANNEL_ARG(&vif->drv_state->u.sta.link.channel),
+         OSW_CHANNEL_ARG(c));
+    ow_xphy_csa_conf_set(csa, to_phy->phy_name, c);
+    osw_conf_invalidate(&csa->mut);
+}
+
+static void
+ow_xphy_csa_conf_apply_vsta(struct osw_conf_vif *from,
+                           struct osw_conf_vif *to)
+{
+    from->enabled = false;
+    to->enabled = true;
+
+    struct osw_conf_net *net;
+    while ((net = ds_dlist_remove_head(&to->u.sta.net_list)) != NULL) {
+        LOGT("csa: applying: %s: removing "OSW_SSID_FMT,
+             to->vif_name,
+             OSW_SSID_ARG(&net->ssid));
+        FREE(net);
+    }
+
+    ds_dlist_foreach(&from->u.sta.net_list, net) {
+        struct osw_conf_net *n = MEMNDUP(net, sizeof(*net));
+        LOGT("csa: applying %s: adding "OSW_SSID_FMT,
+             to->vif_name,
+             OSW_SSID_ARG(&n->ssid));
+        memset(&n->node, 0, sizeof(n->node));
+        ds_dlist_insert_tail(&to->u.sta.net_list, n);
+    }
+}
+
+static void
+ow_xphy_csa_conf_apply_channel(struct ow_xphy_csa_conf *csa,
+                              struct osw_conf_phy *phy)
+{
+    struct osw_conf_vif *vif;
+    ds_tree_foreach(&phy->vif_tree, vif) {
+        if (vif->vif_type != OSW_VIF_AP) continue;
+        LOGT("csa: applying %s: "OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+             vif->vif_name,
+             OSW_CHANNEL_ARG(&vif->u.ap.channel),
+             OSW_CHANNEL_ARG(&csa->channel));
+        vif->u.ap.channel = csa->channel;
+    }
+}
+
+static void
+ow_xphy_csa_conf_disarm__(struct ow_xphy_csa_conf *csa)
+{
+    if (csa->active == false) return;
+    LOGI("csa: disarming override for %s to "OSW_CHANNEL_FMT,
+         csa->phy_name.buf,
+         OSW_CHANNEL_ARG(&csa->channel));
+    csa->active = false;
+    osw_conf_invalidate(&csa->mut);
+}
+
+enum ow_xphy_csa_conf_result {
+    OW_XPHY_CSA_CONF_INACTIVE,
+    OW_XPHY_CSA_CONF_MULTI_VSTA,
+    OW_XPHY_CSA_CONF_NO_CSA_VSTA,
+    OW_XPHY_CSA_CONF_NO_CUR_VSTA,
+    OW_XPHY_CSA_CONF_DISARM,
+    OW_XPHY_CSA_CONF_APPLIED,
+};
+
+static enum ow_xphy_csa_conf_result
+ow_xphy_csa_conf_apply(struct ow_xphy_csa_conf *csa,
+                       struct ds_tree *phy_tree)
+{
+    if (csa->active == false) return OW_XPHY_CSA_CONF_INACTIVE;
+
+    LOGD("csa: applying override for %s to "OSW_CHANNEL_FMT,
+         csa->phy_name.buf,
+         OSW_CHANNEL_ARG(&csa->channel));
+
+    struct osw_conf_phy *phy;
+    struct osw_conf_vif *vif;
+    struct osw_conf_vif *cur_vsta = NULL;
+    struct osw_conf_vif *csa_vsta = NULL;
+    struct osw_conf_phy *csa_phy = NULL;
+    size_t n_vsta_enabled = 0;
+
+    ds_tree_foreach(phy_tree, phy) {
+        const bool is_csa_phy = (strcmp(phy->phy_name, csa->phy_name.buf) == 0);
+        ds_tree_foreach(&phy->vif_tree, vif) {
+            if (vif->vif_type != OSW_VIF_STA) continue;
+            if (vif->enabled == true) n_vsta_enabled++;
+            if (vif->enabled == true && is_csa_phy == false) cur_vsta = vif;
+            if (is_csa_phy == true) csa_vsta = vif;
+        }
+        if (is_csa_phy == true) csa_phy = phy;
+    }
+
+    if (n_vsta_enabled > 1) {
+        /* In theory this could happen during onboarding. In
+         * that case better do nothing. If link is lost the
+         * system will backoff and use another STA
+         * configuration. If there are no other STA link
+         * configurations anymore, it'll eventually go
+         * through to apply_vsta() below on next try.
+         */
+        LOGI("csa: unable to handle multi-vsta configurations, ignoring for now");
+        return OW_XPHY_CSA_CONF_MULTI_VSTA;
+    }
+
+    if (csa_vsta == NULL) {
+        LOGI("csa: unable to override: %s has no sta vif", csa->phy_name.buf);
+        return OW_XPHY_CSA_CONF_NO_CSA_VSTA;
+    }
+
+    if (csa_vsta->enabled == true) {
+        LOGI("csa: already on target phy, stopping");
+        return OW_XPHY_CSA_CONF_DISARM;
+    }
+
+    if (cur_vsta == NULL) {
+        LOGI("csa: unable to override: there's no current sta link to inherit info from");
+        return OW_XPHY_CSA_CONF_NO_CUR_VSTA;
+    }
+
+    ow_xphy_csa_conf_apply_vsta(cur_vsta, csa_vsta);
+    ow_xphy_csa_conf_apply_channel(csa, csa_phy);
+    return OW_XPHY_CSA_CONF_APPLIED;
+}
+
+static void
+ow_xphy_csa_conf_mutate_cb(struct osw_conf_mutator *self,
+                           struct ds_tree *phy_tree)
+{
+    struct ow_xphy_csa_conf *csa = container_of(self, struct ow_xphy_csa_conf, mut);
+    switch (ow_xphy_csa_conf_apply(csa, phy_tree)) {
+        case OW_XPHY_CSA_CONF_INACTIVE:
+        case OW_XPHY_CSA_CONF_MULTI_VSTA:
+        case OW_XPHY_CSA_CONF_NO_CSA_VSTA:
+        case OW_XPHY_CSA_CONF_NO_CUR_VSTA:
+        case OW_XPHY_CSA_CONF_APPLIED:
+            break;
+        case OW_XPHY_CSA_CONF_DISARM:
+            ow_xphy_csa_conf_disarm__(csa);
+            break;
+    }
+}
+
+void
+ow_xphy_csa_conf_disarm(struct ow_xphy_csa_conf *m)
+{
+    ow_xphy_csa_conf_disarm__(m);
+}
+
+static void
+mod_init(struct ow_xphy_csa_conf *m)
+{
+    const struct osw_state_observer obs = {
+        .name = __FILE__,
+        .vif_csa_to_phy_fn = ow_xphy_csa_conf_state_cb,
+    };
+    const struct osw_conf_mutator mut = {
+        .name = __FILE__,
+        .mutate_fn = ow_xphy_csa_conf_mutate_cb,
+        .type = OSW_CONF_TAIL,
+    };
+    m->obs = obs;
+    m->mut = mut;
+}
+
+static void
+mod_attach(struct ow_xphy_csa_conf *m)
+{
+    OSW_MODULE_LOAD(osw_state);
+    OSW_MODULE_LOAD(osw_conf);
+    osw_state_register_observer(&m->obs);
+    osw_conf_register_mutator(&m->mut);
+}
+
+OSW_MODULE(ow_xphy_csa_conf)
+{
+    static struct ow_xphy_csa_conf m;
+    mod_init(&m);
+    mod_attach(&m);
+    return &m;
+}
+
+OSW_UT(ow_xphy_csa_conf_ut)
+{
+    struct ds_tree phy_tree;
+    struct osw_conf_net n1 = {
+        .ssid = { .buf = "foo", .len = 3 },
+    };
+    struct osw_conf_net n2 = {
+        .ssid = { .buf = "fubar", .len = 5 },
+    };
+    struct osw_conf_phy p1 = {
+        .phy_name = "phy1",
+    };
+    struct osw_conf_phy p2 = {
+        .phy_name = "phy2",
+    };
+    struct osw_conf_vif vsta1 = {
+        .vif_name = "vsta1",
+        .vif_type = OSW_VIF_STA,
+        .enabled = true,
+    };
+    struct osw_conf_vif vsta2 = {
+        .vif_name = "vsta2",
+        .vif_type = OSW_VIF_STA,
+        .enabled = false,
+    };
+    struct osw_conf_vif vap1_1 = {
+        .vif_name = "vap1_1",
+        .vif_type = OSW_VIF_AP,
+        .enabled = true,
+        .u = { .ap = { .channel = { .control_freq_mhz = 2412 } } },
+    };
+    struct osw_conf_vif vap1_2 = {
+        .vif_name = "vap1_2",
+        .vif_type = OSW_VIF_AP,
+        .enabled = true,
+        .u = { .ap = { .channel = { .control_freq_mhz = 2412 } } },
+    };
+    struct osw_conf_vif vap2_1 = {
+        .vif_name = "vap2_1",
+        .vif_type = OSW_VIF_AP,
+        .enabled = true,
+        .u = { .ap = { .channel = { .control_freq_mhz = 5180 } } },
+    };
+    struct osw_conf_vif vap2_2 = {
+        .vif_name = "vap2_2",
+        .vif_type = OSW_VIF_AP,
+        .enabled = true,
+        .u = { .ap = { .channel = { .control_freq_mhz = 5180 } } },
+    };
+    struct osw_channel c1 = {
+        .control_freq_mhz = 5200,
+    };
+    struct osw_channel c2 = {
+        .control_freq_mhz = 2417,
+    };
+
+    ds_tree_init(&phy_tree, ds_str_cmp, struct osw_conf_phy, conf_node);
+    ds_tree_init(&p1.vif_tree, ds_str_cmp, struct osw_conf_vif, phy_node);
+    ds_tree_init(&p2.vif_tree, ds_str_cmp, struct osw_conf_vif, phy_node);
+    ds_dlist_init(&vsta1.u.sta.net_list, struct osw_conf_net, node);
+    ds_dlist_init(&vsta2.u.sta.net_list, struct osw_conf_net, node);
+
+    ds_tree_insert(&phy_tree, &p1, p1.phy_name);
+    ds_tree_insert(&phy_tree, &p2, p2.phy_name);
+    ds_tree_insert(&p1.vif_tree, &vsta1, vsta1.vif_name);
+    ds_tree_insert(&p1.vif_tree, &vap1_1, vap1_1.vif_name);
+    ds_tree_insert(&p1.vif_tree, &vap1_2, vap1_2.vif_name);
+    ds_tree_insert(&p2.vif_tree, &vsta2, vsta2.vif_name);
+    ds_tree_insert(&p2.vif_tree, &vap2_1, vap2_1.vif_name);
+    ds_tree_insert(&p2.vif_tree, &vap2_2, vap2_2.vif_name);
+    ds_dlist_insert_tail(&vsta1.u.sta.net_list, MEMNDUP(&n1, sizeof(n1)));
+    ds_dlist_insert_tail(&vsta1.u.sta.net_list, MEMNDUP(&n2, sizeof(n2)));
+
+    struct ow_xphy_csa_conf csa = {0};
+
+    OSW_UT_EVAL(ow_xphy_csa_conf_apply(&csa, &phy_tree) == OW_XPHY_CSA_CONF_INACTIVE);
+
+    ow_xphy_csa_conf_set(&csa, "phy2", &c1);
+    OSW_UT_EVAL(ow_xphy_csa_conf_apply(&csa, &phy_tree) == OW_XPHY_CSA_CONF_APPLIED);
+    OSW_UT_EVAL(ds_dlist_head(&vsta2.u.sta.net_list) != NULL);
+    struct osw_conf_net *n3 = ds_dlist_head(&vsta2.u.sta.net_list);
+    struct osw_conf_net *n4 = ds_dlist_tail(&vsta2.u.sta.net_list);
+    OSW_UT_EVAL(memcmp(&n1.ssid, &n3->ssid, sizeof(n1.ssid)) == 0);
+    OSW_UT_EVAL(memcmp(&n2.ssid, &n4->ssid, sizeof(n2.ssid)) == 0);
+    OSW_UT_EVAL(ow_xphy_csa_conf_apply(&csa, &phy_tree) == OW_XPHY_CSA_CONF_DISARM);
+    OSW_UT_EVAL(vsta1.enabled == false);
+    OSW_UT_EVAL(vsta2.enabled == true);
+    OSW_UT_EVAL(vap2_1.u.ap.channel.control_freq_mhz == c1.control_freq_mhz);
+
+    vsta1.enabled = true;
+    vsta2.enabled = true;
+    OSW_UT_EVAL(ow_xphy_csa_conf_apply(&csa, &phy_tree) == OW_XPHY_CSA_CONF_MULTI_VSTA);
+
+    ow_xphy_csa_conf_set(&csa, "phy1", &c2);
+    vsta1.enabled = false;
+    vsta2.enabled = false;
+    OSW_UT_EVAL(ow_xphy_csa_conf_apply(&csa, &phy_tree) == OW_XPHY_CSA_CONF_NO_CUR_VSTA);
+
+    vsta1.vif_type = OSW_VIF_AP;
+    vsta2.enabled = true;
+    OSW_UT_EVAL(ow_xphy_csa_conf_apply(&csa, &phy_tree) == OW_XPHY_CSA_CONF_NO_CSA_VSTA);
+
+    vsta1.vif_type = OSW_VIF_STA;
+    OSW_UT_EVAL(ow_xphy_csa_conf_apply(&csa, &phy_tree) == OW_XPHY_CSA_CONF_APPLIED);
+    struct osw_conf_net *n5 = ds_dlist_head(&vsta1.u.sta.net_list);
+    struct osw_conf_net *n6 = ds_dlist_tail(&vsta1.u.sta.net_list);
+    OSW_UT_EVAL(memcmp(&n1.ssid, &n5->ssid, sizeof(n1.ssid)) == 0);
+    OSW_UT_EVAL(memcmp(&n2.ssid, &n6->ssid, sizeof(n2.ssid)) == 0);
+}
Index: core/src/lib/ow/src/ow_xphy_csa_conf.h
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_xphy_csa_conf.h
@@ -0,0 +1,9 @@
+#ifndef OW_XPHY_CSA_CONF_H_INCLUDED
+#define OW_XPHY_CSA_CONF_H_INCLUDED
+
+struct ow_xphy_csa_conf;
+
+void
+ow_xphy_csa_conf_disarm(struct ow_xphy_csa_conf *m);
+
+#endif /* OW_XPHY_CSA_CONF_H_INCLUDED */
Index: core/src/lib/ow/src/ow_xphy_csa_ovsdb.c
===================================================================
--- /dev/null
+++ core/src/lib/ow/src/ow_xphy_csa_ovsdb.c
@@ -0,0 +1,80 @@
+#include <log.h>
+#include <util.h>
+#include <osw_module.h>
+#include <osw_state.h>
+
+#define LOG_PREFIX "ow: csa xphy: ovsdb: "
+
+struct ow_csa_xphy_ovsdb {
+    struct osw_state_observer state_obs;
+};
+
+static void
+ow_csa_xphy_ovsdb_cb(struct osw_state_observer *obs,
+                     const struct osw_state_vif_info *vif,
+                     const struct osw_state_phy_info *to_phy,
+                     const struct osw_channel *to_chan)
+{
+    if (vif->drv_state->vif_type != OSW_VIF_STA) return;
+
+    const struct osw_drv_vif_state_sta_link *link = &vif->drv_state->u.sta.link;
+    const bool connected = (link->status == OSW_DRV_VIF_STATE_STA_LINK_CONNECTED);
+    const struct osw_hwaddr *bssid = connected ? &link->bssid : NULL;
+    struct osw_hwaddr_str bssid_strbuf;
+    const char *bssid_str = "";
+    const char *bssid_str_test = getenv("OW_XPHY_CSA_OVSDB_BSSID_TEST");
+    if (bssid != NULL) {
+        bssid_str = osw_hwaddr2str(bssid, &bssid_strbuf);
+    }
+    if (bssid_str_test != NULL) {
+        bssid_str = bssid_str_test;
+    }
+
+    char chan_str[32] = {0};
+    const int freq = to_chan->control_freq_mhz;
+    const int chan = osw_freq_to_chan(freq);
+    snprintf(chan_str, sizeof(chan_str), "%d", chan);
+
+    const char *phy_name = to_phy->phy_name;
+    const char *output = strexa("/usr/opensync/bin/parentchange.sh",
+                                phy_name,
+                                bssid_str,
+                                chan_str);
+
+    const char *vif_name = vif->vif_name;
+    const struct osw_hwaddr bssid0 = {0};
+
+    LOGN(LOG_PREFIX"parent change: from %s to %s @ "OSW_HWADDR_FMT" (arg %s) on "OSW_CHANNEL_FMT" (arg %s): output = '%s'",
+         vif_name,
+         phy_name,
+         OSW_HWADDR_ARG(bssid ?: &bssid0),
+         bssid_str,
+         OSW_CHANNEL_ARG(to_chan),
+         chan_str,
+         output ?: "");
+}
+
+static void
+mod_init(struct ow_csa_xphy_ovsdb *m)
+{
+    const struct osw_state_observer obs = {
+        .name = __FILE__,
+        .vif_csa_to_phy_fn = ow_csa_xphy_ovsdb_cb,
+    };
+    m->state_obs = obs;
+}
+
+static void
+mod_attach(struct ow_csa_xphy_ovsdb *m)
+{
+    OSW_MODULE_LOAD(osw_state);
+    osw_state_register_observer(&m->state_obs);
+}
+
+OSW_MODULE(ow_xphy_csa_ovsdb)
+{
+    static struct ow_csa_xphy_ovsdb m;
+    mod_init(&m);
+    mod_attach(&m);
+    return &m;
+}
Index: core/src/lib/ow/unit.mk
===================================================================
--- core.orig/src/lib/ow/unit.mk
+++ core/src/lib/ow/unit.mk
@@ -1,6 +1,6 @@
 ###############################################################################
 #
-# OneWiFi Library
+# Opensync Wireless / One Wifi Core
 #
 ###############################################################################
 UNIT_DISABLE := $(if $(CONFIG_OW),n,y)
@@ -13,21 +13,52 @@ UNIT_SRC += src/ow_core.c
 UNIT_SRC += src/ow_core_thread.c
 UNIT_SRC += src/ow_conf.c
 UNIT_SRC += src/ow_conf_barrier.c
-UNIT_SRC += src/ow_bus.c
 UNIT_SRC += $(if $(wildcard $(PKG_CONFIG_SYSROOT_DIR)/usr/include/ccsp)$(wildcard $(UNIT_PATH)/inc/ccsp),src/ow_webconfig.c,)
-UNIT_SRC += src/ow_ovsdb.c
-UNIT_SRC += src/ow_ovsdb_ms.c
+#UNIT_SRC += src/ow_ovsdb.c
+#UNIT_SRC += src/ow_ovsdb_ms.c
+#UNIT_SRC += src/ow_ovsdb_cconf.c
+#UNIT_SRC += src/ow_ovsdb_stats.c
+#UNIT_SRC += src/ow_ovsdb_dfs_backup.c
+#UNIT_SRC += src/ow_ovsdb_csa.c
 UNIT_SRC += src/ow_sigalrm.c
-UNIT_SRC += src/ow_ovsdb_steer.c
+#UNIT_SRC += src/ow_ovsdb_steer.c
 UNIT_SRC += src/ow_steer.c
-UNIT_SRC += src/ow_steer_ue.c
+UNIT_SRC += src/ow_steer_sta.c
+UNIT_SRC += src/ow_steer_candidate_list.c
+UNIT_SRC += src/ow_steer_policy.c
+UNIT_SRC += src/ow_steer_policy_stack.c
+UNIT_SRC += src/ow_steer_policy_bss_filter.c
+UNIT_SRC += src/ow_steer_policy_band_filter.c
+UNIT_SRC += src/ow_steer_policy_force_kick.c
+UNIT_SRC += src/ow_steer_policy_pre_assoc_counter.c
 UNIT_SRC += src/ow_acl_kick.c
+UNIT_SRC += src/ow_demo_stats.c
+UNIT_SRC += src/ow_stats_conf.c
+UNIT_SRC += src/ow_stats_conf_file.c
+UNIT_SRC += src/ow_ev_timer.c
+UNIT_SRC += src/ow_steer_policy_snr_xing.c
+UNIT_SRC += src/ow_steer_policy_directed_home.c
+UNIT_SRC += src/ow_steer_policy_directed_away.c
+UNIT_SRC += src/ow_steer_executor_action.c
+UNIT_SRC += src/ow_steer_executor_chain.c
+UNIT_SRC += src/ow_steer_executor_action_acl.c
+UNIT_SRC += src/ow_steer_executor_action_deauth.c
+UNIT_SRC += src/ow_steer_executor_action_btm.c
+UNIT_SRC += src/ow_sta_channel_override.c
+UNIT_SRC += src/ow_sta_log_snr.c
+UNIT_SRC += src/ow_state_watchdog.c
+UNIT_SRC += src/ow_dfs_backup.c
+UNIT_SRC += src/ow_xphy_csa_conf.c
+UNIT_SRC += src/ow_xphy_csa_ovsdb.c
+UNIT_SRC += src/ow_steer_bm.c
 
 UNIT_EXPORT_CFLAGS += -I$(UNIT_PATH)/inc
 UNIT_CFLAGS += -I$(UNIT_PATH)/inc
+UNIT_CFLAGS += -D_GNU_SOURCE
 UNIT_DEPS += src/lib/osw
 
 # ow_drv_target (to be removed eventually):
 UNIT_DEPS += src/lib/target
 UNIT_DEPS += src/lib/schema
 UNIT_DEPS += src/lib/ovsdb
+UNIT_DEPS += src/lib/datapipeline
